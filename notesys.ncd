<!DOCTYPE NoteCase-File>
<!--LastNote:49-->
<HTML>
<HEAD>
<meta content="text/html;charset=UTF-8" http-equiv="Content-Type">
<meta name="generator" content="NoteCase 1.9.8">
<TITLE></TITLE>
</HEAD>
<BODY>
<DL>
<DT>C#研究代码</DT>
<!--property:date_created=1515136331-->
<!--property:date_modified=1515136331-->
<DD>
<DL>
<DT>开关机</DT>
<!--property:date_created=1515136346-->
<!--property:date_modified=1515136858-->
<DD>
// 程序开机自动启动<BR>
void autostart()<BR>
{<BR>
    HKEY hKey;<BR>
    QString strRegPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot;;<BR>
<BR>
    //1、找到系统的启动项  <BR>
    if (RegOpenKeyEx(HKEY_CURRENT_USER, strRegPath.toStdString().c_str(), 0, KEY_ALL_ACCESS, &amp;hKey) == ERROR_SUCCESS) ///打开启动项       <BR>
    {<BR>
        //2、得到本程序自身的全路径<BR>
        TCHAR strExeFullDir[MAX_PATH];<BR>
        GetModuleFileName(NULL, strExeFullDir, MAX_PATH);<BR>
<BR>
        //3、判断注册表项是否已经存在<BR>
        TCHAR strDir[MAX_PATH] = {};<BR>
        DWORD nLength = MAX_PATH;<BR>
        long result = RegGetValue(hKey, nullptr, &quot;GISRestart&quot;, RRF_RT_REG_SZ, 0, strDir, &amp;nLength);<BR>
<BR>
        //4、已经存在<BR>
        if (result != ERROR_SUCCESS || _tcscmp(strExeFullDir, strDir) != 0)<BR>
        {<BR>
            //5、添加一个子Key,并设置值，&quot;GISRestart&quot;是应用程序名字（不加后缀.exe） <BR>
            RegSetValueEx(hKey, &quot;GISRestart&quot;, 0, REG_SZ, (LPBYTE)strExeFullDir, (lstrlen(strExeFullDir) + 1)*sizeof(TCHAR));<BR>
<BR>
            //6、关闭注册表<BR>
            RegCloseKey(hKey);<BR>
        }<BR>
    }<BR>
    else<BR>
    {<BR>
        QMessageBox::warning(0, QString::fromLocal8Bit(&quot;警告&quot;), QString::fromLocal8Bit(&quot;\n系统参数错误,不能随系统启动n&quot;));<BR>
    }<BR>
}<BR>
<BR>
// 取消开机自动启动<BR>
void SGISRestartDlg::cancelAutoStart()<BR>
{<BR>
    HKEY hKey;<BR>
    QString strRegPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot;;<BR>
<BR>
    //1、找到系统的启动项  <BR>
    if (RegOpenKeyEx(HKEY_CURRENT_USER, strRegPath.toStdString().c_str(), 0, KEY_ALL_ACCESS, &amp;hKey) == ERROR_SUCCESS)<BR>
    {<BR>
        //2、删除值<BR>
        RegDeleteValue(hKey, &quot;GISRestart&quot;);<BR>
<BR>
        //3、关闭注册表<BR>
        RegCloseKey(hKey);<BR>
    }<BR>
}<BR>
<BR>
<BR>
//定时关机<BR>
Process p = new Process();<BR>
           p.StartInfo.FileName = &quot;cmd.exe &quot;;<BR>
           p.StartInfo.UseShellExecute = false;<BR>
           p.StartInfo.RedirectStandardInput = true;<BR>
           p.StartInfo.RedirectStandardOutput = true;<BR>
           p.StartInfo.RedirectStandardError = true;<BR>
           p.StartInfo.CreateNoWindow = true;<BR>
           p.Start();<BR>
           p.StandardInput.WriteLine(&quot;at time shutdown -s&quot;);   //填CMD命令<BR>
           p.StandardInput.WriteLine(&quot;exit &quot;);<BR>
           string strRst = p.StandardOutput.ReadToEnd();<BR>
           MessageBox.Show(strRst);<BR>
           p.WaitForExit();<BR>
<BR>
<BR>
//定时关机<BR>
ProcessStartInfo psi = new ProcessStartInfo(&quot;shutdown&quot;, &quot;/s /t 300 /c 关机了&quot;);<BR>
Process.Start(psi);<BR>
<BR>
//定时开机<BR>
[DllImport(&quot;kernel32.dll&quot;)]<BR>
    public static extern SafeWaitHandle CreateWaitableTimer(IntPtr lpTimerAttributes, bool bManualReset, string lpTimerName);<BR>
<BR>
    [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]<BR>
    [return: MarshalAs(UnmanagedType.Bool)]<BR>
    public static extern bool SetWaitableTimer(SafeWaitHandle hTimer, [In] ref long pDueTime, int lPeriod, IntPtr pfnCompletionRoutine, IntPtr lpArgToCompletionRoutine, bool fResume);<BR>
    /// &lt;summary&gt;<BR>
    /// 设置唤醒时间<BR>
    /// &lt;/summary&gt;<BR>
    private void SetWaitForWakeUpTime(DateTime OnTime)<BR>
    {<BR>
      DateTime utc = OnTime;<BR>
      long duetime = utc.ToFileTime();<BR>
            using (SafeWaitHandle handle = CreateWaitableTimer(IntPtr.Zero, true, &quot;MyWaitabletimer&quot;))<BR>
      {<BR>
        if (SetWaitableTimer(handle, ref duetime, 0, IntPtr.Zero, IntPtr.Zero, true))<BR>
        {<BR>
          using (EventWaitHandle wh = new EventWaitHandle(false, EventResetMode.AutoReset))<BR>
          {<BR>
            wh.SafeWaitHandle = handle;<BR>
            Application.SetSuspendState(PowerState.Hibernate, true, false);<BR>
            wh.WaitOne();<BR>
          }<BR>
        }<BR>
        else<BR>
        {<BR>
          throw new Win32Exception(Marshal.GetLastWin32Error());<BR>
        }<BR>
      }<BR>
<BR>
    }<BR>

</DD>
</DL>

</DD>
<DT>pjsip</DT>
<!--property:date_created=1515478068-->
<!--property:date_modified=1515727977-->
<DD>
     今天抽空写下以GB28181的方式获取摄像机视频流以备后用，同时也希望能帮助到正着手开发GB28181对接视频的同学，这块的资料实在不多。<BR>
<BR>
今天讲的内容不涉及到平台对接，平台对接下次有时间再讲，平台对接相对更麻烦点。通过GB28181获取摄像机视频流，首先需要摄像机支持GB28181<BR>
<BR>
，如何知道摄像机是否支持GB28181协议呢？请看下图：<BR>
<BR>
<BR>
<BR>
                                                            图1.摄像机28181协议配置图<BR>
<BR>
图1 展示了海康摄像机配置GB28181页面，其他厂家摄像机GB28181配置页面（我遇到的）基本跟海康配置的页面相同。<BR>
<BR>
下面介绍下各配置项基本意义：<BR>
<BR>
   本地端口：默认为5060，SIP服务发送命令给摄像机时需要知道摄像机GB28181端口号，要不向哪发？<BR>
<BR>
SIP服务器ID:说简单就是 服务器的标识，只不过这个标识有一定的要求，具体请参见28181-2001标准安全防范视频监控联网系统信息传输交换控制技术要求.pdf<BR>
<BR>
                    当然也可以参考新点的文档，新旧文档这部分差异不大。文档在从群里下载。<BR>
<BR>
SIP服务域：实际就是SIP服务器ID前10位。<BR>
<BR>
SIP服务器地址：SIP服务所在机器的IP地址（如果存在多网卡建议将不用的网卡禁用掉）。<BR>
<BR>
SIP服务器端口：SIP服务Port，其他SIP服务发送命令到此端口与之通信。<BR>
<BR>
其他的配置默认即可。<BR>
<BR>
   GB28181配置好以后，需要启动摄像机GB28181服务。<BR>
<BR>
启动摄像机GB28181的方法是勾选“启用”选项，启动成功后，摄像机会向SIP Server发送注册消息，通过抓包可以看到具体的注册消息内容：<BR>
<BR>
<BR>
<BR>
                            图2 摄像机发送注册消息图<BR>
<BR>
看下注册消息的具体内容：<BR>
<BR>
<BR>
<BR>
                                       图3 具体注册消息图<BR>
<BR>
重要是是Cantact信息，包含了摄像机GB28181 SIP ID 以及IP地址和端口号，这样与摄像机通信的SIP服务就知道往哪里回应答消息。<BR>
<BR>
     摄像机端基本介绍了完了（摄像机端相当于SIP Client），下面 介绍CG28181 服务端也即 SIP Server,这正是我们要实现的。<BR>
<BR>
实现CG28181服务端可以借助于现有的开源库 PJSIP,自己实现开发量还是很大的,具体的实现步骤如下：<BR>
<BR>
一. 将PJSIP运行起来，毕竟人家是一个服务。只有运行以后才能接收客户端发来的消息。<BR>
<BR>
bool Init(std::string concat, int logLevel)<BR>
{<BR>
    this-&gt;concat = concat;<BR>
    pj_log_set_level(logLevel);<BR>
    auto status = pj_init();<BR>
 <BR>
    status = pjlib_util_init();<BR>
 <BR>
    pj_caching_pool_init(&amp;cachingPool, &amp;pj_pool_factory_default_policy, 0);<BR>
 <BR>
    status = pjsip_endpt_create(&amp;cachingPool.factory, nullptr, &amp;endPoint);<BR>
                 <BR>
    status = pjsip_tsx_layer_init_module(endPoint);<BR>
 <BR>
    status = pjsip_ua_init_module(endPoint, nullptr);<BR>
 <BR>
    pool = pj_pool_create(&amp;cachingPool.factory, &quot;proxyapp&quot;, 4000, 4000, nullptr);<BR>
    auto pjStr =StrToPjstr(GetAddr());<BR>
 <BR>
    pj_sockaddr_in pjAddr;<BR>
    pjAddr.sin_family = pj_AF_INET();<BR>
    pj_inet_aton(&amp;pjStr, &amp;pjAddr.sin_addr);<BR>
 <BR>
    auto port = GetPort();<BR>
    pjAddr.sin_port = pj_htons(static_cast&lt;pj_uint16_t&gt;(GetPort()));<BR>
　　　　status = pjsip_udp_transport_start(endPoint, &amp;pjAddr, nullptr, 1, nullptr);<BR>
      if (status != PJ_SUCCESS) return status;<BR>
 <BR>
      auto realm = StrToPjstr(GetLocalDomain());<BR>
      return pjsip_auth_srv_init(pool, &amp;authentication, &amp;realm, lookup, 0) == PJ_SUCCESS ? true : false;<BR>
         <BR>
}<BR>
　　以上是PJSip初始化的代码，需要将服务将要监听的端口传给PJSIP,这样服务就在监听的端口接收SIP 消息了。<BR>
<BR>
二. 应答注册消息<BR>
<BR>
     摄像机端发送来Register消息后，如过服务端不应答，摄像机端会一直发送直到收到服务端应答为止。如果服务器端重新运行，需要手动再次<BR>
<BR>
开启摄像机，如果等摄像机自己再次发送注册消息可能是一个小时以后，我们当然不希望那么久。<BR>
<BR>
服务端应答注册消息代码<BR>
bool OnReceive(pjsip_rx_data* rdata) override<BR>
{<BR>
    if(rdata-&gt;msg_info.cseq-&gt;method.id == PJSIP_REGISTER_METHOD)<BR>
    {<BR>
    　　auto expires = static_cast&lt;pjsip_expires_hdr*&gt;(pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_EXPIRES, nullptr));<BR>
    　　auto authHdr = static_cast&lt;pjsip_authorization_hdr*&gt;(pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_AUTHORIZATION, nullptr));<BR>
    　　if(expires &amp;&amp; expires-&gt;ivalue &gt; 0 )<BR>
    　　{<BR>
        if(authHdr)<BR>
        {<BR>
        　　cout &lt;&lt;&quot;receive register info&quot;&lt;&lt;endl;<BR>
        　　response(rdata, PJSIP_SC_OK, DateHead);<BR>
        　　QureryDeviceInfo(rdata);<BR>
        }<BR>
        else<BR>
        {<BR>
        　　response(rdata, PJSIP_SC_UNAUTHORIZED, AuthenHead);<BR>
        }<BR>
        return true;<BR>
    　　}<BR>
    }<BR>
    return false;<BR>
}<BR>
　　<BR>
OnReceive 是服务端接收注册消息以后的响应方法，也就是说要将OnReceive作为入参传给PJSIP,完成此项功能在初始化&lt;br data-filtered=&quot;filtered&quot;&gt;PJSIP Moudle时。至于PJSIP moudle，<BR>
这里不多解释，想要知道细节的话，可以查看PJSIP文档，文档群里有，<BR>
代码如下：<BR>
bool  Init(std::string concat, int loglevel)<BR>
{<BR>
　　bool ret = false;<BR>
  if(!mainModule)<BR>
　{<BR>
    ret = context.Init(concat,loglevel);<BR>
    if(!ret) return ret;<BR>
 <BR>
    static struct pjsip_module moudle =<BR>
    {<BR>
    　　nullptr, nullptr,<BR>
      { &quot;MainModule&quot;, 10 },<BR>
      -1,<BR>
     PJSIP_MOD_PRIORITY_APPLICATION,<BR>
     nullptr,<BR>
     nullptr,<BR>
     nullptr,<BR>
     nullptr,<BR>
    nullptr,<BR>
    &amp;CGSipMedia::OnReceive,<BR>
    nullptr,<BR>
    nullptr,<BR>
    nullptr,<BR>
    };<BR>
    mainModule = &amp;moudle;<BR>
    pjsip_inv_callback callback;<BR>
    pj_bzero(&amp;callback, sizeof(callback));<BR>
    callback.on_state_changed = &amp;onStateChanged;<BR>
    callback.on_new_session = &amp;onNewSession;<BR>
    callback.on_tsx_state_changed = &amp;onTsxStateChanged;<BR>
    callback.on_rx_offer = &amp;onRxOffer;<BR>
    callback.on_rx_reinvite = &amp;onRxReinvite;<BR>
    callback.on_create_offer = &amp;onCreateOffer;<BR>
    callback.on_send_ack = &amp;onSendAck;<BR>
    ret = context.RegisterCallback(&amp;callback);<BR>
    if(!ret ) return ret;<BR>
 <BR>
    context.InitModule();<BR>
    ret  = context.RegisterModule(mainModule);<BR>
    if(!ret ) return ret;<BR>
 <BR>
    CGSipModule::GetInstance().Init();<BR>
    ret = context.CreateWorkThread(&amp;proc,workthread,nullptr,&quot;proxy&quot;);<BR>
    }<BR>
    return ret;<BR>
    }<BR>
　<BR>
<BR>
OnReceive方法内Resonse方法实现了发送响应数据到客户端（摄像机）:<BR>
 void Response(pjsip_rx_data* rdata, int st_code,int headType) <BR>
 {<BR>
  　　std::lock_guard&lt;mutex&gt; lk(lock);<BR>
     pjsip_tx_data* tdata;<BR>
   　pjsip_endpt_create_response(endPoint, rdata, st_code, nullptr, &amp;tdata);<BR>
     auto date = DateTimeFormatter::format(LocalDateTime(), &quot;%Y-%m-%dT%H:%M:%S&quot;);<BR>
     pj_str_t c;<BR>
     pj_str_t key;<BR>
     pjsip_hdr *hdr;<BR>
     switch(headType)<BR>
      {<BR>
           case DateHead:                                                        <BR>
           　　key = pj_str(&quot;Date&quot;);<BR>
           　　hdr = reinterpret_cast&lt;pjsip_hdr*&gt;(pjsip_date_hdr_create(pool, &amp;key, pj_cstr(&amp;c, date.c_str())));<BR>
          　　 pjsip_msg_add_hdr(tdata-&gt;msg, hdr);<BR>
          　　 break;<BR>
           case AuthenHead:<BR>
           　　pjsip_auth_srv_challenge(&amp;authentication, nullptr, nullptr, nullptr, PJ_FALSE, tdata);<BR>
           　　break;<BR>
              default:<BR>
               break;<BR>
       }<BR>
      pjsip_response_addr addr;<BR>
      pjsip_get_response_addr(pool, rdata, &amp;addr);<BR>
      pjsip_endpt_send_response(endPoint, &amp;addr, tdata, nullptr, nullptr);<BR>
   }<BR>
<BR>
<BR>
实际也就是利用发PJSIP发送一些字符串给客户端。具体发送了些什么，可以抓个包看下。<BR>
<BR>
<BR>
<BR>
图4 SIP服务应答注册消息<BR>
<BR>
SIP 服务实际回了“200 OK” 给摄像机端。看下具体的消息内容：<BR>
<BR>
<BR>
<BR>
                                  图5  “200 OK” 具体内容<BR>
<BR>
      SIP服务端响应注册命令后，发送Invite请求，请求catalog信息，也就是设备基本信息，具体的方法上面已<BR>
<BR>
给出具体的内容是：<BR>
<BR>
void QueryDeviveInfo(GBDevice *device, const string&amp; scheme = &quot;Catalog&quot;)<BR>
{<BR>
　　char szQuerInfo[200] = { 0 };<BR>
　　pj_ansi_snprintf(szQuerInfo, 200,<BR>
   &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;<BR>
   &quot;&lt;Query&gt;\n&quot;<BR>
  &quot;&lt;CmdType&gt;%s&lt;/CmdType&gt;\n&quot;<BR>
  &quot;&lt;SN&gt;17430&lt;/SN&gt;\n&quot;<BR>
  &quot;&lt;DeviceID&gt;%s&lt;/DeviceID&gt;\n&quot;<BR>
  &quot;&lt;/Query&gt;\n&quot;, scheme.c_str(), device-&gt;GetUser()<BR>
  );<BR>
　　pjsip_tx_data *tdata;<BR>
　　const pjsip_method method = { PJSIP_OTHER_METHOD,{ &quot;MESSAGE&quot;, 7 } };<BR>
　　auto text = StrToPjstr(string(szQuerInfo));<BR>
　　pjsip_endpt_create_request(endPoint, &amp;method, &amp;StrToPjstr(device-&gt;GetSipIpUrl()), &amp;StrToPjstr(concat), &amp;StrToPjstr(device-&gt;GetSipCodecUrl()),&amp;StrToPjstr(concat), nullptr, -1, &amp;text, &amp;tdata);<BR>
　　tdata-&gt;msg-&gt;body-&gt;content_type.type = pj_str(&quot;Application&quot;);<BR>
　　tdata-&gt;msg-&gt;body-&gt;content_type.subtype = pj_str(&quot;MANSCDP+xml&quot;);<BR>
　　pjsip_endpt_send_request(endPoint, tdata, -1, nullptr, nullptr);&lt;br data-filtered=&quot;filtered&quot;&gt;}<BR>
　<BR>
<BR>
SIP服务端 发送了请求catalog  消息，摄像机端收到消息发送其自身的catalog消息，SIP 服务端将在OnReceive中收到具体的catalog消息。取catalog消息的方法如下：<BR>
<BR>
bool OnReceive(pjsip_rx_data* rdata) override<BR>
{<BR>
　　if (rdata-&gt;msg_info.cseq-&gt;method.id == PJSIP_OTHER_METHOD)<BR>
　　{<BR>
    CGXmlParser xmlParser(context.GetMessageBody(rdata));<BR>
    CGDynamicStruct dynamicStruct;<BR>
    dynamicStruct.Set(xmlParser.GetXml());<BR>
 <BR>
    auto cmd = xmlParser.GetXml()-&gt;firstChild()-&gt;nodeName();<BR>
    auto cmdType = dynamicStruct.Get&lt;std::string&gt;(&quot;CmdType&quot;);<BR>
    if (cmdType != &quot;Catalog&quot;) return false;<BR>
             <BR>
    auto DeviceID = dynamicStruct.Get&lt;std::string&gt;(&quot;DeviceID&quot;);<BR>
                 <BR>
    Vector deviceList = dynamicStruct.Get&lt;Vector&gt;(&quot;DeviceList&quot;);<BR>
 <BR>
    for (auto&amp; x : deviceList)<BR>
    {<BR>
    　　CGCatalogInfo devinfo;<BR>
    try<BR>
    {<BR>
    　　devinfo.PlatformAddr = rdata-&gt;pkt_info.src_name;<BR>
    　　devinfo.PlatformPort = rdata-&gt;pkt_info.src_port;<BR>
 <BR>
    　　devinfo.Address = x[&quot;Address&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Name = WstringToString(x[&quot;Name&quot;].convert&lt;wstring&gt;());<BR>
    　　devinfo.Manufacturer = x[&quot;Manufacturer&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Model = x[&quot;Model&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Owner = x[&quot;Owner&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Civilcode = x[&quot;CivilCode&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Registerway = x[&quot;RegisterWay&quot;].convert&lt;int&gt;();<BR>
    　　devinfo.Secrecy = x[&quot;Secrecy&quot;].convert&lt;int&gt;();<BR>
    　　//devinfo.IPAddress = x[&quot;IPAddress&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.DeviceID = x[&quot;DeviceID&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Status= x[&quot;Status&quot;].convert&lt;string&gt;();<BR>
    }<BR>
    catch (...)<BR>
    {<BR>
        //continue;<BR>
    }<BR>
    if(callback)<BR>
    {<BR>
        callback(user, &amp;devinfo);<BR>
    }<BR>
    //SipControlModule::GetInstance().CatalogCallBack(devinfo);<BR>
    }<BR>
         <BR>
    response(rdata, PJSIP_SC_OK,NoHead);<BR>
    return true;<BR>
　　SIP服务取都摄像机的信息后就可以发送请求视频信息了，请求视频最为关键的是SDP，下面看下SDP信息如何填写:<BR>
<BR>
static string createSDP(MediaContext&amp; mediaContext)<BR>
{<BR>
    char str[500] = { 0 };<BR>
    pj_ansi_snprintf(str, 500,<BR>
    &quot;v=0\n&quot;<BR>
    &quot;o=%s 0 0 IN IP4 %s\n&quot;<BR>
    &quot;s=Play\n&quot;<BR>
    &quot;c=IN IP4 %s\n&quot;<BR>
    &quot;t=0 0\n&quot;<BR>
    &quot;m=video %d RTP/AVP 96 98 97\n&quot;<BR>
    &quot;a=recvonly\n&quot;<BR>
    &quot;a=rtpmap:96 PS/90000\n&quot;<BR>
    &quot;a=rtpmap:98 H264/90000\n&quot;<BR>
    &quot;a=rtpmap:97 MPEG4/90000\n&quot;<BR>
    &quot;y=0100000001\n&quot;,<BR>
    mediaContext.GetDeviceId().c_str(),<BR>
    mediaContext.GetRecvAddress().c_str(),<BR>
    mediaContext.GetRecvAddress().c_str(),<BR>
    mediaContext.GetRecvPort()<BR>
            );<BR>
    return str;<BR>
}<BR>
　　发送请求视频命令到摄像机端当然也是通过PJSIP API实现代码如下：<BR>
bool Invite(pjsip_dialog *dlg, MediaContext mediaContext, string sdp)<BR>
{<BR>
    pjsip_inv_session *inv;<BR>
    if (PJ_SUCCESS != pjsip_inv_create_uac(dlg, nullptr, 0, &amp;inv)) return false;<BR>
    pjsip_tx_data *tdata;<BR>
    if (PJ_SUCCESS != pjsip_inv_invite(inv, &amp;tdata)) return false;<BR>
    pjsip_media_type type;<BR>
    type.type = pj_str(&quot;application&quot;);<BR>
    type.subtype = pj_str(&quot;sdp&quot;);<BR>
    auto text = pj_str(const_cast&lt;char *&gt;(sdp.c_str()));<BR>
    try<BR>
    {<BR>
        tdata-&gt;msg-&gt;body = pjsip_msg_body_create(pool, &amp;type.type, &amp;type.subtype, &amp;text);<BR>
 <BR>
        auto hName = pj_str(&quot;Subject&quot;);<BR>
        auto subjectUrl = mediaContext.GetDeviceId() + &quot;:&quot; + SiralNum + &quot;,&quot; + GetInstance().GetCode() + &quot;:&quot; + SiralNum;<BR>
        auto hValue = pj_str(const_cast&lt;char*&gt;(subjectUrl.c_str()));<BR>
        auto hdr = pjsip_generic_string_hdr_create(pool, &amp;hName, &amp;hValue);<BR>
        pjsip_msg_add_hdr(tdata-&gt;msg, reinterpret_cast&lt;pjsip_hdr*&gt;(hdr));<BR>
        pjsip_inv_send_msg(inv, tdata);<BR>
    }<BR>
    catch (...)<BR>
    {<BR>
    }<BR>
    return true;<BR>
}<BR>
　　代码就不解释了，要想知道到底发了什么还是抓个包看看，无论你用什么方法只要抓包的数据是正确定说明发送成功了。<BR>
<BR>
<BR>
<BR>
                                                图6 服务端发送invite视频消息<BR>
<BR>
摄像机端收到Invite请求后，会将视频数据以rtp的方式推送到指定的端口，端口在invite消息指定。<BR>
<BR>
这样在指定的地址（ip + port）就可以拿到数据了。<BR>
<BR>
最后提供一个测试demo，demo的作用是可以让大家抓包，看看双方都发了些什么。<BR>
<BR>
demo运行界面如下：<BR>
<BR>
<BR>
<BR>
                                                                             图6 demo运行初始界面<BR>
<BR>
1.运行demo后，首先配置好配置，如果不知道可以默认，但IP地址需要修改，端口不能被占用。<BR>
<BR>
2.完成配置各配置项以后点击获取视频源按钮 等待摄像机端注册。<BR>
<BR>
3.摄像机端开启28181功能：具体的方法可以是：平台选择方式下拉框先选择一个非28181方式，点击保存，再选择28181方式并点击保存。<BR>
<BR>
4.摄像机端成功开启28181功能以后，视频源下拉框中会显示摄像机的名称信息。<BR>
<BR>
5.选中视频源下拉框中出现的选项并点击播放按钮，正常情况下会可以播放从摄像机端过来的视频流。<BR>
<BR>
   成功接入视频源并播放的运行界面如下。<DL>
<DT>code</DT>
<!--property:date_created=1515478081-->
<!--property:date_modified=1515566957-->
<DD>
//初始化pjsip服务<BR>
bool Init(std::string concat, int logLevel)<BR>
{<BR>
    this-&gt;concat = concat;<BR>
    pj_log_set_level(logLevel);<BR>
    auto status = pj_init();<BR>
 <BR>
    status = pjlib_util_init();<BR>
 <BR>
    pj_caching_pool_init(&amp;cachingPool, &amp;pj_pool_factory_default_policy, 0);<BR>
 <BR>
    status = pjsip_endpt_create(&amp;cachingPool.factory, nullptr, &amp;endPoint);<BR>
                 <BR>
    status = pjsip_tsx_layer_init_module(endPoint);<BR>
 <BR>
    status = pjsip_ua_init_module(endPoint, nullptr);<BR>
 <BR>
    pool = pj_pool_create(&amp;cachingPool.factory, &quot;proxyapp&quot;, 4000, 4000, nullptr);<BR>
    auto pjStr =StrToPjstr(GetAddr());<BR>
 <BR>
    pj_sockaddr_in pjAddr;<BR>
    pjAddr.sin_family = pj_AF_INET();<BR>
    pj_inet_aton(&amp;pjStr, &amp;pjAddr.sin_addr);<BR>
 <BR>
    auto port = GetPort();<BR>
    pjAddr.sin_port = pj_htons(static_cast&lt;pj_uint16_t&gt;(GetPort()));<BR>
　　　　status = pjsip_udp_transport_start(endPoint, &amp;pjAddr, nullptr, 1, nullptr);<BR>
      if (status != PJ_SUCCESS) return status;<BR>
 <BR>
      auto realm = StrToPjstr(GetLocalDomain());<BR>
      return pjsip_auth_srv_init(pool, &amp;authentication, &amp;realm, lookup, 0) == PJ_SUCCESS ? true : false;<BR>
         <BR>
}<BR>
<BR>
//摄像机发送注册消息，服务器返回应答消息<BR>
bool OnReceive(pjsip_rx_data* rdata) override<BR>
{<BR>
    if(rdata-&gt;msg_info.cseq-&gt;method.id == PJSIP_REGISTER_METHOD)<BR>
    {<BR>
    　　auto expires = static_cast&lt;pjsip_expires_hdr*&gt;(pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_EXPIRES, nullptr));<BR>
    　　auto authHdr = static_cast&lt;pjsip_authorization_hdr*&gt;(pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_AUTHORIZATION, nullptr));<BR>
    　　if(expires &amp;&amp; expires-&gt;ivalue &gt; 0 )<BR>
    　　{<BR>
        if(authHdr)<BR>
        {<BR>
        　　cout &lt;&lt;&quot;receive register info&quot;&lt;&lt;endl;<BR>
        　　response(rdata, PJSIP_SC_OK, DateHead);<BR>
        　　QureryDeviceInfo(rdata);<BR>
        }<BR>
        else<BR>
        {<BR>
        　　response(rdata, PJSIP_SC_UNAUTHORIZED, AuthenHead);<BR>
        }<BR>
        return true;<BR>
    　　}<BR>
    }<BR>
    return false;<BR>
}<BR>
<BR>
<BR>
//上面的回答消息要作为参数传给pjsip服务器<BR>
bool  Init(std::string concat, int loglevel)<BR>
{<BR>
　　bool ret = false;<BR>
  if(!mainModule)<BR>
　{<BR>
    ret = context.Init(concat,loglevel);<BR>
    if(!ret) return ret;<BR>
 <BR>
    static struct pjsip_module moudle =<BR>
    {<BR>
    　　nullptr, nullptr,<BR>
      { &quot;MainModule&quot;, 10 },<BR>
      -1,<BR>
     PJSIP_MOD_PRIORITY_APPLICATION,<BR>
     nullptr,<BR>
     nullptr,<BR>
     nullptr,<BR>
     nullptr,<BR>
    nullptr,<BR>
    &amp;CGSipMedia::OnReceive,<BR>
    nullptr,<BR>
    nullptr,<BR>
    nullptr,<BR>
    };<BR>
    mainModule = &amp;moudle;<BR>
    pjsip_inv_callback callback;<BR>
    pj_bzero(&amp;callback, sizeof(callback));<BR>
    callback.on_state_changed = &amp;onStateChanged;<BR>
    callback.on_new_session = &amp;onNewSession;<BR>
    callback.on_tsx_state_changed = &amp;onTsxStateChanged;<BR>
    callback.on_rx_offer = &amp;onRxOffer;<BR>
    callback.on_rx_reinvite = &amp;onRxReinvite;<BR>
    callback.on_create_offer = &amp;onCreateOffer;<BR>
    callback.on_send_ack = &amp;onSendAck;<BR>
    ret = context.RegisterCallback(&amp;callback);<BR>
    if(!ret ) return ret;<BR>
 <BR>
    context.InitModule();<BR>
    ret  = context.RegisterModule(mainModule);<BR>
    if(!ret ) return ret;<BR>
 <BR>
    CGSipModule::GetInstance().Init();<BR>
    ret = context.CreateWorkThread(&amp;proc,workthread,nullptr,&quot;proxy&quot;);<BR>
    }<BR>
    return ret;<BR>
    }<BR>
}<BR>
<BR>
OnReceive方法内Response方法实现了发送响应数据到客户端（摄像机）:<BR>
void Response(pjsip_rx_data* rdata, int st_code,int headType) <BR>
 {<BR>
  　　std::lock_guard&lt;mutex&gt; lk(lock);<BR>
     pjsip_tx_data* tdata;<BR>
   　pjsip_endpt_create_response(endPoint, rdata, st_code, nullptr, &amp;tdata);<BR>
     auto date = DateTimeFormatter::format(LocalDateTime(), &quot;%Y-%m-%dT%H:%M:%S&quot;);<BR>
     pj_str_t c;<BR>
     pj_str_t key;<BR>
     pjsip_hdr *hdr;<BR>
     switch(headType)<BR>
      {<BR>
           case DateHead:                                                        <BR>
           　　key = pj_str(&quot;Date&quot;);<BR>
           　　hdr = reinterpret_cast&lt;pjsip_hdr*&gt;(pjsip_date_hdr_create(pool, &amp;key, pj_cstr(&amp;c, date.c_str())));<BR>
          　　 pjsip_msg_add_hdr(tdata-&gt;msg, hdr);<BR>
          　　 break;<BR>
           case AuthenHead:<BR>
           　　pjsip_auth_srv_challenge(&amp;authentication, nullptr, nullptr, nullptr, PJ_FALSE, tdata);<BR>
           　　break;<BR>
              default:<BR>
               break;<BR>
       }<BR>
      pjsip_response_addr addr;<BR>
      pjsip_get_response_addr(pool, rdata, &amp;addr);<BR>
      pjsip_endpt_send_response(endPoint, &amp;addr, tdata, nullptr, nullptr);<BR>
   }<BR>
<BR>
<BR>
//服务器请求catalog消息<BR>
void QueryDeviveInfo(GBDevice *device, const string&amp; scheme = &quot;Catalog&quot;)<BR>
{<BR>
　　char szQuerInfo[200] = { 0 };<BR>
　　pj_ansi_snprintf(szQuerInfo, 200,<BR>
   &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;<BR>
   &quot;&lt;Query&gt;\n&quot;<BR>
  &quot;&lt;CmdType&gt;%s&lt;/CmdType&gt;\n&quot;<BR>
  &quot;&lt;SN&gt;17430&lt;/SN&gt;\n&quot;<BR>
  &quot;&lt;DeviceID&gt;%s&lt;/DeviceID&gt;\n&quot;<BR>
  &quot;&lt;/Query&gt;\n&quot;, scheme.c_str(), device-&gt;GetUser()<BR>
  );<BR>
　　pjsip_tx_data *tdata;<BR>
　　const pjsip_method method = { PJSIP_OTHER_METHOD,{ &quot;MESSAGE&quot;, 7 } };<BR>
　　auto text = StrToPjstr(string(szQuerInfo));<BR>
　　pjsip_endpt_create_request(endPoint, &amp;method, &amp;StrToPjstr(device-&gt;GetSipIpUrl()), &amp;StrToPjstr(concat), &amp;StrToPjstr(device-&gt;GetSipCodecUrl()),&amp;StrToPjstr(concat), nullptr, -1, &amp;text, &amp;tdata);<BR>
　　tdata-&gt;msg-&gt;body-&gt;content_type.type = pj_str(&quot;Application&quot;);<BR>
　　tdata-&gt;msg-&gt;body-&gt;content_type.subtype = pj_str(&quot;MANSCDP+xml&quot;);<BR>
　　pjsip_endpt_send_request(endPoint, tdata, -1, nullptr, nullptr);<BR>
}<BR>
<BR>
//服务器接收摄像机传回的catalog消息<BR>
bool OnReceive(pjsip_rx_data* rdata) override<BR>
{<BR>
　　if (rdata-&gt;msg_info.cseq-&gt;method.id == PJSIP_OTHER_METHOD)<BR>
　　{<BR>
    CGXmlParser xmlParser(context.GetMessageBody(rdata));<BR>
    CGDynamicStruct dynamicStruct;<BR>
    dynamicStruct.Set(xmlParser.GetXml());<BR>
 <BR>
    auto cmd = xmlParser.GetXml()-&gt;firstChild()-&gt;nodeName();<BR>
    auto cmdType = dynamicStruct.Get&lt;std::string&gt;(&quot;CmdType&quot;);<BR>
    if (cmdType != &quot;Catalog&quot;) return false;<BR>
             <BR>
    auto DeviceID = dynamicStruct.Get&lt;std::string&gt;(&quot;DeviceID&quot;);<BR>
                 <BR>
    Vector deviceList = dynamicStruct.Get&lt;Vector&gt;(&quot;DeviceList&quot;);<BR>
 <BR>
    for (auto&amp; x : deviceList)<BR>
    {<BR>
    　　CGCatalogInfo devinfo;<BR>
    try<BR>
    {<BR>
    　　devinfo.PlatformAddr = rdata-&gt;pkt_info.src_name;<BR>
    　　devinfo.PlatformPort = rdata-&gt;pkt_info.src_port;<BR>
 <BR>
    　　devinfo.Address = x[&quot;Address&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Name = WstringToString(x[&quot;Name&quot;].convert&lt;wstring&gt;());<BR>
    　　devinfo.Manufacturer = x[&quot;Manufacturer&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Model = x[&quot;Model&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Owner = x[&quot;Owner&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Civilcode = x[&quot;CivilCode&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Registerway = x[&quot;RegisterWay&quot;].convert&lt;int&gt;();<BR>
    　　devinfo.Secrecy = x[&quot;Secrecy&quot;].convert&lt;int&gt;();<BR>
    　　//devinfo.IPAddress = x[&quot;IPAddress&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.DeviceID = x[&quot;DeviceID&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Status= x[&quot;Status&quot;].convert&lt;string&gt;();<BR>
    }<BR>
    catch (...)<BR>
    {<BR>
        //continue;<BR>
    }<BR>
    if(callback)<BR>
    {<BR>
        callback(user, &amp;devinfo);<BR>
    }<BR>
    //SipControlModule::GetInstance().CatalogCallBack(devinfo);<BR>
    }<BR>
         <BR>
    response(rdata, PJSIP_SC_OK,NoHead);<BR>
    return true;<BR>
}<BR>
<BR>
//服务器接收到catalog消息后，解析摄像机信息，然后回执SDP，请求视频信息<BR>
static string createSDP(MediaContext&amp; mediaContext)<BR>
{<BR>
    char str[500] = { 0 };<BR>
    pj_ansi_snprintf(str, 500,<BR>
    &quot;v=0\n&quot;<BR>
    &quot;o=%s 0 0 IN IP4 %s\n&quot;<BR>
    &quot;s=Play\n&quot;<BR>
    &quot;c=IN IP4 %s\n&quot;<BR>
    &quot;t=0 0\n&quot;<BR>
    &quot;m=video %d RTP/AVP 96 98 97\n&quot;<BR>
    &quot;a=recvonly\n&quot;<BR>
    &quot;a=rtpmap:96 PS/90000\n&quot;<BR>
    &quot;a=rtpmap:98 H264/90000\n&quot;<BR>
    &quot;a=rtpmap:97 MPEG4/90000\n&quot;<BR>
    &quot;y=0100000001\n&quot;,<BR>
    mediaContext.GetDeviceId().c_str(),<BR>
    mediaContext.GetRecvAddress().c_str(),<BR>
    mediaContext.GetRecvAddress().c_str(),<BR>
    mediaContext.GetRecvPort()<BR>
            );<BR>
    return str;<BR>
}<BR>
<BR>
<BR>
//请求视频函数<BR>
bool Invite(pjsip_dialog *dlg, MediaContext mediaContext, string sdp)<BR>
{<BR>
    pjsip_inv_session *inv;<BR>
    if (PJ_SUCCESS != pjsip_inv_create_uac(dlg, nullptr, 0, &amp;inv)) return false;<BR>
    pjsip_tx_data *tdata;<BR>
    if (PJ_SUCCESS != pjsip_inv_invite(inv, &amp;tdata)) return false;<BR>
    pjsip_media_type type;<BR>
    type.type = pj_str(&quot;application&quot;);<BR>
    type.subtype = pj_str(&quot;sdp&quot;);<BR>
    auto text = pj_str(const_cast&lt;char *&gt;(sdp.c_str()));<BR>
    try<BR>
    {<BR>
        tdata-&gt;msg-&gt;body = pjsip_msg_body_create(pool, &amp;type.type, &amp;type.subtype, &amp;text);<BR>
 <BR>
        auto hName = pj_str(&quot;Subject&quot;);<BR>
        auto subjectUrl = mediaContext.GetDeviceId() + &quot;:&quot; + SiralNum + &quot;,&quot; + GetInstance().GetCode() + &quot;:&quot; + SiralNum;<BR>
        auto hValue = pj_str(const_cast&lt;char*&gt;(subjectUrl.c_str()));<BR>
        auto hdr = pjsip_generic_string_hdr_create(pool, &amp;hName, &amp;hValue);<BR>
        pjsip_msg_add_hdr(tdata-&gt;msg, reinterpret_cast&lt;pjsip_hdr*&gt;(hdr));<BR>
        pjsip_inv_send_msg(inv, tdata);<BR>
    }<BR>
    catch (...)<BR>
    {<BR>
    }<BR>
    return true;<BR>
}<BR>
<BR>
//摄像机接收到请求信息后将视频以rtp的方式传输给指定----端口ip地址
</DD>
</DL>

</DD>
<DT>GB28181</DT>
<!--property:date_created=1515740245-->
<!--property:date_modified=1515740245-->
<DD>
<DL>
<DT>平台接入</DT>
<!--property:date_created=1515740253-->
<!--property:date_modified=1515740259-->
<DD>
libosip+libexosip+libxml<BR>
<BR>
前面两者负责sip协议的实现，libxml用来封装和解析实体信令<BR>
<BR>
  流媒体方面：从编码中获取的h.264+g711的视音频帧，进行PS媒体协议封装（自己写的PS封装协议），再经过RTP传输协议（自己实现）发送至平台<BR>
<BR>
 平台对收到的RTP流媒体进行解RTP,解PS，再进行h.264+g711的解码。<BR>
<BR>
<BR>
opensips,pjproject,ffmpeg<BR>
<BR>
<BR>
<BR>
uac功能实现<BR>
/*<BR>
  2  ===============================================================<BR>
  3  GBT28181 基于eXosip2,osip库实现注册UAC功能<BR>
  4  作者：程序人生<BR>
  5  博客地址：http://blog.csdn.net/hiwubihe<BR>
  6  QQ：1269122125<BR>
  7  注：请尊重原作者劳动成果，仅供学习使用，请勿盗用，违者必究！<BR>
  8  ================================================================<BR>
  9  */<BR>
 10 <BR>
 11 #include &lt;iostream&gt;<BR>
 12 #include &lt;string&gt;<BR>
 13 #include &lt;sstream&gt;<BR>
 14 #include &lt;osipparser2/osip_message.h&gt;<BR>
 15 #include &lt;osipparser2/osip_parser.h&gt;<BR>
 16 #include &lt;osipparser2/osip_port.h&gt;<BR>
 17 <BR>
 18 #include &lt;eXosip2/eXosip.h&gt;<BR>
 19 #include &lt;eXosip2/eX_setup.h&gt;<BR>
 20 #include &lt;eXosip2/eX_register.h&gt;<BR>
 21 #include &lt;eXosip2/eX_options.h&gt;<BR>
 22 #include &lt;eXosip2/eX_message.h&gt;<BR>
 23 #include &lt;arpa/inet.h&gt;<BR>
 24 #include &lt;sys/types.h&gt;<BR>
 25 #include &lt;sys/socket.h&gt;<BR>
 26 <BR>
 27 using namespace std;<BR>
 28 <BR>
 29 //本地监听IP<BR>
 30 #define LISTEN_ADDR (&quot;192.168.50.57&quot;)<BR>
 31 //本地监听端口<BR>
 32 #define UACPORT (&quot;5061&quot;)<BR>
 33 #define UACPORTINT (5061)<BR>
 34 //本UAC地址编码<BR>
 35 #define UACCODE (&quot;100110000201000000&quot;)<BR>
 36 //本地UAC密码<BR>
 37 #define UACPWD (&quot;12345&quot;)<BR>
 38 //远程UAS IP<BR>
 39 #define UAS_ADDR (&quot;192.168.50.57&quot;)<BR>
 40 //远程UAS 端口<BR>
 41 #define UAS_PORT (&quot;5060&quot;)<BR>
 42 //超时<BR>
 43 #define EXPIS 300<BR>
 44 <BR>
 45 //当前服务状态 1 已经注册 0 未注册<BR>
 46 static int iCurrentStatus;<BR>
 47 //注册成功HANDLE<BR>
 48 static int iHandle = -1;<BR>
 49 <BR>
 50 //SIP From/To 头部<BR>
 51 class CSipFromToHeader<BR>
 52 {<BR>
 53 public:<BR>
 54     CSipFromToHeader()<BR>
 55     {<BR>
 56     }<BR>
 57     ~CSipFromToHeader()<BR>
 58     {<BR>
 59     }<BR>
 60     void SetHeader(string addrCod, string addrI, string addrPor)<BR>
 61     {<BR>
 62         addrCode = addrCod;<BR>
 63         addrIp = addrI;<BR>
 64         addrPort = addrPor;<BR>
 65     }<BR>
 66     string GetFormatHeader()<BR>
 67     {<BR>
 68         std::stringstream stream;<BR>
 69         stream &lt;&lt; &quot;sip: &quot; &lt;&lt; addrCode &lt;&lt; &quot;@&quot; &lt;&lt; addrIp &lt;&lt; &quot;:&quot; &lt;&lt; addrPort;<BR>
 70         return stream.str();<BR>
 71     }<BR>
 72     //主机名称<BR>
 73     string GetCode()<BR>
 74     {<BR>
 75         std::stringstream stream;<BR>
 76         stream &lt;&lt; addrCode;<BR>
 77         return stream.str();<BR>
 78     }<BR>
 79     //主机地址<BR>
 80     string GetAddr()<BR>
 81     {<BR>
 82         std::stringstream stream;<BR>
 83         stream &lt;&lt; addrIp;<BR>
 84         return stream.str();<BR>
 85     }<BR>
 86     //端口<BR>
 87     string GetPort()<BR>
 88     {<BR>
 89         std::stringstream stream;<BR>
 90         stream &lt;&lt; addrPort;<BR>
 91         return stream.str();<BR>
 92     }<BR>
 93 <BR>
 94 private:<BR>
 95     string addrCode;<BR>
 96     string addrIp;<BR>
 97     string addrPort;<BR>
 98 };<BR>
 99 <BR>
100 //SIP Contract头部<BR>
101 class CContractHeader: public CSipFromToHeader<BR>
102 {<BR>
103 public:<BR>
104     CContractHeader()<BR>
105     {<BR>
106     }<BR>
107     ~CContractHeader()<BR>
108     {<BR>
109     }<BR>
110     void SetContractHeader(string addrCod, string addrI, string addrPor)<BR>
111     {<BR>
112         SetHeader(addrCod, addrI, addrPor);<BR>
113     }<BR>
114     string GetContractFormatHeader()<BR>
115     {<BR>
116 <BR>
117         std::stringstream stream;<BR>
118         stream &lt;&lt; &quot;&lt;sip:&quot; &lt;&lt; GetCode() &lt;&lt; &quot;@&quot; &lt;&lt; GetAddr() &lt;&lt; &quot;:&quot; &lt;&lt; GetPort()<BR>
119                 &lt;&lt; &quot;&gt;&quot;;<BR>
120         return stream.str();<BR>
121     }<BR>
122 };<BR>
123 <BR>
124 //发送注册信息<BR>
125 int SendRegister(int&amp; registerId, CSipFromToHeader &amp;from, CSipFromToHeader &amp;to,<BR>
126         CContractHeader &amp;contact, const string&amp; userName, const string&amp; pwd,<BR>
127         const int expires, int iType)<BR>
128 {<BR>
129     cout &lt;&lt; &quot;=============================================&quot; &lt;&lt; endl;<BR>
130     if (iType == 0)<BR>
131     {<BR>
132         cout &lt;&lt; &quot;注册请求信息：&quot; &lt;&lt; endl;<BR>
133     }<BR>
134     else if (iType == 1)<BR>
135     {<BR>
136         cout &lt;&lt; &quot;刷新注册信息：&quot; &lt;&lt; endl;<BR>
137     }<BR>
138     else<BR>
139     {<BR>
140         cout &lt;&lt; &quot;注销信息:&quot; &lt;&lt; endl;<BR>
141     }<BR>
142     cout &lt;&lt; &quot;registerId &quot; &lt;&lt; registerId &lt;&lt; endl;<BR>
143     cout &lt;&lt; &quot;from &quot; &lt;&lt; from.GetFormatHeader() &lt;&lt; endl;<BR>
144     cout &lt;&lt; &quot;to &quot; &lt;&lt; to.GetFormatHeader() &lt;&lt; endl;<BR>
145     cout &lt;&lt; &quot;contact&quot; &lt;&lt; contact.GetContractFormatHeader() &lt;&lt; endl;<BR>
146     cout &lt;&lt; &quot;userName&quot; &lt;&lt; userName &lt;&lt; endl;<BR>
147     cout &lt;&lt; &quot;pwd&quot; &lt;&lt; pwd &lt;&lt; endl;<BR>
148     cout &lt;&lt; &quot;expires&quot; &lt;&lt; expires &lt;&lt; endl;<BR>
149     cout &lt;&lt; &quot;=============================================&quot; &lt;&lt; endl;<BR>
150     //服务器注册<BR>
151     static osip_message_t *regMsg = 0;<BR>
152     int ret;<BR>
153 <BR>
154     ::eXosip_add_authentication_info(userName.c_str(), userName.c_str(),<BR>
155             pwd.c_str(), &quot;MD5&quot;, NULL);<BR>
156     eXosip_lock();<BR>
157     //发送注册信息 401响应由eXosip2库自动发送<BR>
158     if (0 == registerId)<BR>
159     {<BR>
160         // 注册消息的初始化<BR>
161         registerId = ::eXosip_register_build_initial_register(<BR>
162                 from.GetFormatHeader().c_str(), to.GetFormatHeader().c_str(),<BR>
163                 contact.GetContractFormatHeader().c_str(), expires, &amp;regMsg);<BR>
164         if (registerId &lt;= 0)<BR>
165         {<BR>
166             return -1;<BR>
167         }<BR>
168     }<BR>
169     else<BR>
170     {<BR>
171         // 构建注册消息<BR>
172         ret = ::eXosip_register_build_register(registerId, expires, &amp;regMsg);<BR>
173         if (ret != OSIP_SUCCESS)<BR>
174         {<BR>
175             return ret;<BR>
176         }<BR>
177         //添加注销原因<BR>
178         if (expires == 0)<BR>
179         {<BR>
180             osip_contact_t *contact = NULL;<BR>
181             char tmp[128];<BR>
182 <BR>
183             osip_message_get_contact(regMsg, 0, &amp;contact);<BR>
184             {<BR>
185                 sprintf(tmp, &quot;&lt;sip:%s@%s:%s&gt;;expires=0&quot;,<BR>
186                         contact-&gt;url-&gt;username, contact-&gt;url-&gt;host,<BR>
187                         contact-&gt;url-&gt;port);<BR>
188             }<BR>
189             //osip_contact_free(contact);<BR>
190             //reset contact header<BR>
191             osip_list_remove(&amp;regMsg-&gt;contacts, 0);<BR>
192             osip_message_set_contact(regMsg, tmp);<BR>
193             osip_message_set_header(regMsg, &quot;Logout-Reason&quot;, &quot;logout&quot;);<BR>
194         }<BR>
195     }<BR>
196     // 发送注册消息<BR>
197     ret = ::eXosip_register_send_register(registerId, regMsg);<BR>
198     if (ret != OSIP_SUCCESS)<BR>
199     {<BR>
200         registerId = 0;<BR>
201     }eXosip_unlock();<BR>
202 <BR>
203     return ret;<BR>
204 }<BR>
205 <BR>
206 //注册<BR>
207 void Register()<BR>
208 {<BR>
209     if (iCurrentStatus == 1)<BR>
210     {<BR>
211         cout &lt;&lt; &quot;当前已经注册&quot; &lt;&lt; endl;<BR>
212         return;<BR>
213     }<BR>
214     CSipFromToHeader stFrom;<BR>
215     stFrom.SetHeader(UACCODE, UAS_ADDR, UAS_PORT);<BR>
216     CSipFromToHeader stTo;<BR>
217     stTo.SetHeader(UACCODE, UAS_ADDR, UAS_PORT);<BR>
218     CContractHeader stContract;<BR>
219     stContract.SetContractHeader(UACCODE, LISTEN_ADDR, UACPORT);<BR>
220     //发送注册信息<BR>
221     int registerId = 0;<BR>
222     if (0 &gt; SendRegister(registerId, stFrom, stTo, stContract, UACCODE, UACPWD,<BR>
223             3000, 0))<BR>
224     {<BR>
225         cout &lt;&lt; &quot;发送注册失败&quot; &lt;&lt; endl;<BR>
226         return;<BR>
227     }<BR>
228     iCurrentStatus = 1;<BR>
229     iHandle = registerId;<BR>
230 }<BR>
231 //刷新注册<BR>
232 void RefreshRegister()<BR>
233 {<BR>
234     if (iCurrentStatus == 0)<BR>
235     {<BR>
236         cout &lt;&lt; &quot;当前未注册，不允许刷新&quot; &lt;&lt; endl;<BR>
237         return;<BR>
238     }<BR>
239     CSipFromToHeader stFrom;<BR>
240     stFrom.SetHeader(UACCODE, UAS_ADDR, UAS_PORT);<BR>
241     CSipFromToHeader stTo;<BR>
242     stTo.SetHeader(UACCODE, UAS_ADDR, UAS_PORT);<BR>
243     CContractHeader stContract;<BR>
244     stContract.SetContractHeader(UACCODE, LISTEN_ADDR, UACPORT);<BR>
245     //发送注册信息<BR>
246     if (0 &gt; SendRegister(iHandle, stFrom, stTo, stContract, UACCODE, UACPWD,<BR>
247             3000, 1))<BR>
248     {<BR>
249         cout &lt;&lt; &quot;发送刷新注册失败&quot; &lt;&lt; endl;<BR>
250         return;<BR>
251     }<BR>
252 }<BR>
253 //注销<BR>
254 void UnRegister()<BR>
255 {<BR>
256     if (iCurrentStatus == 0)<BR>
257     {<BR>
258         cout &lt;&lt; &quot;当前未注册，不允许注销&quot; &lt;&lt; endl;<BR>
259         return;<BR>
260     }<BR>
261     CSipFromToHeader stFrom;<BR>
262     stFrom.SetHeader(UACCODE, UAS_ADDR, UAS_PORT);<BR>
263     CSipFromToHeader stTo;<BR>
264     stTo.SetHeader(UACCODE, UAS_ADDR, UAS_PORT);<BR>
265     CContractHeader stContract;<BR>
266     stContract.SetContractHeader(UACCODE, LISTEN_ADDR, UACPORT);<BR>
267     //发送注册信息<BR>
268269     if (0 &gt; SendRegister( iHandle, stFrom, stTo, stContract, UACCODE, UACPWD,<BR>
270             0, 2))<BR>
271     {<BR>
272         cout &lt;&lt; &quot;发送注销失败&quot; &lt;&lt; endl;<BR>
273         return;<BR>
274     }<BR>
275     iCurrentStatus = 0;<BR>
276     iHandle = -1;<BR>
277 }<BR>
278 static void help()<BR>
279 {<BR>
280     const char<BR>
281             *b =<BR>
282     &quot;-------------------------------------------------------------------------------\n&quot;<BR>
283     &quot;SIP Library test process - uac v 1.0 (June 13, 2014)\n\n&quot;<BR>
284     &quot;SIP UAC端 注册,刷新注册,注销实现\n\n&quot;<BR>
285     &quot;Author: 程序人生\n\n&quot;<BR>
286     &quot;博客地址:http://blog.csdn.net/hiwubihe QQ:1269122125\n\n&quot;<BR>
287     &quot;-------------------------------------------------------------------------------\n&quot;<BR>
288     &quot;\n&quot;<BR>
289     &quot;              0:Register\n&quot;<BR>
290     &quot;              1:RefreshRegister\n&quot;<BR>
291     &quot;              2:UnRegister\n&quot;<BR>
292     &quot;              3:clear scream\n&quot;<BR>
293     &quot;              4:exit\n&quot;<BR>
294     &quot;-------------------------------------------------------------------------------\n&quot;<BR>
295     &quot;\n&quot;;<BR>
296     fprintf(stderr, b, strlen(b));<BR>
297     cout &lt;&lt; &quot;please select method :&quot;;<BR>
298 }<BR>
299 //服务处理线程<BR>
300 void *serverHandle(void *pUser)<BR>
301 {<BR>
302     sleep(3);<BR>
303     help();<BR>
304     char ch = getchar();<BR>
305     getchar();<BR>
306     while (1)<BR>
307     {<BR>
308         switch (ch)<BR>
309         {<BR>
310         case '0':<BR>
311             //注册<BR>
312             Register();<BR>
313             break;<BR>
314         case '1':<BR>
315             //刷新注册<BR>
316             RefreshRegister();<BR>
317             break;<BR>
318         case '2':<BR>
319             //注销<BR>
320             UnRegister();<BR>
321             break;<BR>
322         case '3':<BR>
323             if (system(&quot;clear&quot;) &lt; 0)<BR>
324             {<BR>
325                 cout &lt;&lt; &quot;clear scream error&quot; &lt;&lt; endl;<BR>
326                 exit(1);<BR>
327             }<BR>
328             break;<BR>
329         case '4':<BR>
330             cout &lt;&lt; &quot;exit sipserver......&quot; &lt;&lt; endl;<BR>
331             getchar();<BR>
332             exit(0);<BR>
333         default:<BR>
334             cout &lt;&lt; &quot;select error&quot; &lt;&lt; endl;<BR>
335             break;<BR>
336         }<BR>
337         cout &lt;&lt; &quot;press any key to continue......&quot; &lt;&lt; endl;<BR>
338         getchar();<BR>
339         help();<BR>
340         ch = getchar();<BR>
341         getchar();<BR>
342     }<BR>
343     return NULL;<BR>
344 }<BR>
345 <BR>
346 //事件处理线程<BR>
347 void *eventHandle(void *pUser)<BR>
348 {<BR>
349     eXosip_event_t* osipEventPtr = (eXosip_event_t*) pUser;<BR>
350     switch (osipEventPtr-&gt;type)<BR>
351     {<BR>
352     //需要继续验证REGISTER是什么类型<BR>
353     case EXOSIP_REGISTRATION_SUCCESS:<BR>
354     case EXOSIP_REGISTRATION_FAILURE:<BR>
355     {<BR>
356         cout&lt;&lt;&quot;收到状态码:&quot;&lt;&lt;osipEventPtr-&gt;response-&gt;status_code&lt;&lt;&quot;报文&quot;&lt;&lt;endl;<BR>
357         if(osipEventPtr-&gt;response-&gt;status_code == 401)<BR>
358         {<BR>
359             cout&lt;&lt;&quot;发送鉴权报文&quot;&lt;&lt;endl;<BR>
360         }<BR>
361         else if(osipEventPtr-&gt;response-&gt;status_code == 200)<BR>
362         {<BR>
363             cout&lt;&lt;&quot;接收成功&quot;&lt;&lt;endl;<BR>
364         }<BR>
365         else<BR>
366         {}<BR>
367     }<BR>
368         break;<BR>
369     default:<BR>
370         cout &lt;&lt; &quot;The sip event type that not be precessed.the event &quot;<BR>
371             &quot;type is : &quot; &lt;&lt; osipEventPtr-&gt;type &lt;&lt; endl;<BR>
372         break;<BR>
373     }<BR>
374     eXosip_event_free(osipEventPtr);<BR>
375     return NULL;<BR>
376 }<BR>
377 <BR>
378 int main()<BR>
379 {<BR>
380     iCurrentStatus = 0;<BR>
381     //库处理结果<BR>
382     int result = OSIP_SUCCESS;<BR>
383     //初始化库<BR>
384     if (OSIP_SUCCESS != (result = eXosip_init()))<BR>
385     {<BR>
386         printf(&quot;eXosip_init failure.\n&quot;);<BR>
387         return 1;<BR>
388     }<BR>
389     cout &lt;&lt; &quot;eXosip_init success.&quot; &lt;&lt; endl;<BR>
390     eXosip_set_user_agent(NULL);<BR>
391     //监听<BR>
392     if (OSIP_SUCCESS != eXosip_listen_addr(IPPROTO_UDP, NULL, UACPORTINT,<BR>
393             AF_INET, 0))<BR>
394     {<BR>
395         printf(&quot;eXosip_listen_addr failure.\n&quot;);<BR>
396         return 1;<BR>
397     }<BR>
398     //设置监听网卡<BR>
399     if (OSIP_SUCCESS != eXosip_set_option(<BR>
400     EXOSIP_OPT_SET_IPV4_FOR_GATEWAY,<BR>
401             LISTEN_ADDR))<BR>
402     {<BR>
403         return -1;<BR>
404     }<BR>
405     //开启服务线程<BR>
406     pthread_t pthser;<BR>
407     if (0 != pthread_create(&amp;pthser, NULL, serverHandle, NULL))<BR>
408     {<BR>
409         printf(&quot;创建主服务失败\n&quot;);<BR>
410         return -1;<BR>
411     }<BR>
412     //事件用于等待<BR>
413     eXosip_event_t* osipEventPtr = NULL;<BR>
414     //开启事件循环<BR>
415     while (true)<BR>
416     {<BR>
417         //等待事件 0的单位是秒，500是毫秒<BR>
418         osipEventPtr = ::eXosip_event_wait(0, 200);<BR>
419         //处理eXosip库默认处理<BR>
420         {<BR>
421             usleep(500 * 1000);<BR>
422             eXosip_lock();<BR>
423             //一般处理401/407采用库默认处理<BR>
424             eXosip_default_action(osipEventPtr);<BR>
425             eXosip_unlock();<BR>
426         }<BR>
427         //事件空继续等待<BR>
428         if (NULL == osipEventPtr)<BR>
429         {<BR>
430             continue;<BR>
431         }<BR>
432         //开启线程处理事件并在事件处理完毕将事件指针释放<BR>
433         pthread_t pth;<BR>
434         if (0 != pthread_create(&amp;pth, NULL, eventHandle, (void*) osipEventPtr))<BR>
435         {<BR>
436             printf(&quot;创建线程处理事件失败\n&quot;);<BR>
437             continue;<BR>
438         }<BR>
439         osipEventPtr = NULL;<BR>
440     }<BR>
441 }
</DD>
<DT>UAC</DT>
<!--property:date_created=1515740275-->
<!--property:date_modified=1515740280-->
<DD>
代理客户端程序<BR>
<BR>
/** <BR>
 * 一个使用了 osip 和 eXosip 库的 UAC 代理客户端的演示程序 <BR>
 *  <BR>
 * - 只是简单的演示了使用了 osip 和 eXosip2 库的 UAC 代理客户端的如下几个功能： <BR>
 * * i 发起呼叫 INVITE 请求 <BR>
 * * h 挂断会话 <BR>
 * * s 执行方法 INFO  <BR>
 * * m 执行方法 MESSAGE <BR>
 *  <BR>
 * 编 译：g++ -I/usr/local/include -L/usr/local/lib ua_client.cpp -o ua_client -leXosip2 -losip2 -losipparser2 -lpthread <BR>
 *  <BR>
 */  <BR>
  <BR>
#include &lt;osip2/osip_mt.h&gt;  <BR>
#include &lt;eXosip2/eXosip.h&gt;  <BR>
  <BR>
#include &lt;netinet/in.h&gt;  <BR>
#include &lt;sys/socket.h&gt;  <BR>
#include &lt;sys/types.h&gt;  <BR>
  <BR>
#include &lt;iostream&gt;  <BR>
#include &lt;string&gt;  <BR>
  <BR>
using namespace std;  <BR>
  <BR>
int main(int argc, char* argv[])  <BR>
{  <BR>
    eXosip_event_t *je;  <BR>
    osip_message_t *reg = NULL;  <BR>
    osip_message_t *invite = NULL;  <BR>
    osip_message_t *ack = NULL;  <BR>
    osip_message_t *info = NULL;  <BR>
    osip_message_t *message = NULL;  <BR>
    int call_id, dialog_id;  <BR>
    int i,flag;  <BR>
    int flag1 = 1;  <BR>
    int id;  <BR>
      <BR>
    string strIdentity = &quot;sip:136@133.37.55.136&quot;;  <BR>
    string strRegisterer = &quot;sip:133.37.55.136:5060&quot;; // server ip  <BR>
  <BR>
    string strSrcCall = &quot;sip:136@133.37.55.136&quot;;  <BR>
    string strDestCall = &quot;sip:136@133.37.55.136:5060&quot;; // server ip  <BR>
  <BR>
      <BR>
    char command;  <BR>
    char tmp[4096];  <BR>
    char localip[128];  <BR>
  <BR>
    string strHelp = string(&quot;\n\t--&gt; 命令字符 功能描述 &lt;--\n\n&quot;)  <BR>
                        + &quot;\t\tr 向服务器注册\n&quot;  <BR>
                        + &quot;\t\tc 取消注册\n&quot;  <BR>
                        + &quot;\t\ti 发起呼叫请求\n&quot;  <BR>
                        + &quot;\t\th 挂断\n&quot;  <BR>
                        + &quot;\t\tq 退出程序\n&quot;  <BR>
                        + &quot;\t\ts 执行方法 INFO\n&quot;  <BR>
                        + &quot;\t\tm 执行方法 MESSAGE\n&quot;  <BR>
                        + &quot;\t\te 帮助\n\n&quot;;  <BR>
    cout &lt;&lt; strHelp;  <BR>
  <BR>
    string strMsg;  <BR>
  <BR>
    i = eXosip_init ();  <BR>
    if (i != 0)  <BR>
    {  <BR>
        cout &lt;&lt; &quot;\t--&gt; Couldn't initialize eXosip! &lt;--\n&quot;;  <BR>
        return -1;  <BR>
    }  <BR>
    else  <BR>
    {  <BR>
        cout &lt;&lt; &quot;\t--&gt; eXosip_init successfully! &lt;-- \n\n&quot;;  <BR>
    }  <BR>
  <BR>
    i = eXosip_listen_addr (IPPROTO_UDP, NULL, 5061, AF_INET, 0);  <BR>
    if (i != 0)  <BR>
    {  <BR>
        eXosip_quit ();  <BR>
        cerr &lt;&lt; &quot;\n\t--&gt; Couldn't initialize transport layer! &lt;-- \n\n&quot;;  <BR>
        return -1;  <BR>
    }  <BR>
    flag = 1;  <BR>
    while (flag)  <BR>
    {  <BR>
        cout &lt;&lt; &quot;请输入一个命令字符：\t&quot;;  <BR>
        cin &gt;&gt; command;  <BR>
        <BR>
        switch (command)  <BR>
        {  <BR>
        case 'r':  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; This modal isn't commpleted! \n&quot; &lt;&lt; endl;  <BR>
            break;  <BR>
  <BR>
        case 'i': // 初始化的 INVITE 请求  <BR>
            i = eXosip_call_build_initial_invite (&amp;invite,   <BR>
                                                  strDestCall.c_str(),   <BR>
                                                  strSrcCall.c_str(),   <BR>
                                                  NULL,   <BR>
                                                  &quot;This is a call for a conversation&quot;);  <BR>
            if (i != 0)  <BR>
            {  <BR>
                cout &lt;&lt; &quot;\n --&gt; Intial INVITE failed! &lt;-- \n&quot;;  <BR>
                break;  <BR>
            }  <BR>
  <BR>
            // 符合 SDP 格式, 其中属性 a 是自定义格式,也就是说可以存放自己的信息,   <BR>
            // 但是只能是两列,比如帐户信息  <BR>
            // 但是经测试,格式: v o t必不可少,原因未知,估计是协议栈在传输时需要检查的  <BR>
  <BR>
            strMsg = string(&quot;v=0\r\n&quot;)  <BR>
                   + &quot;o=anonymous 0 0 IN IP4 0.0.0.0\r\n&quot;  <BR>
                   + &quot;t=1 10\r\n&quot;  <BR>
                   + &quot;a=username:bluesea\r\n&quot;  <BR>
                   + &quot;a=password:123456\r\n&quot;;  <BR>
  <BR>
            osip_message_set_body (invite, strMsg.c_str(), strMsg.length());  <BR>
            osip_message_set_content_type (invite, &quot;application/sdp&quot;);  <BR>
        <BR>
            // 这里使用了锁机制以保证同步  <BR>
            eXosip_lock ();  <BR>
            i = eXosip_call_send_initial_invite (invite);  <BR>
            eXosip_unlock ();  <BR>
            flag1 = 1;  <BR>
            while (flag1)  <BR>
            {  <BR>
                je = eXosip_event_wait (0, 200);  <BR>
                if (je == NULL)  <BR>
                {  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; No response or the time is over! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
                }  <BR>
            <BR>
                switch (je-&gt;type)  <BR>
                {  <BR>
                case EXOSIP_CALL_INVITE:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; a new invite reveived! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                // announce processing by a remote app  <BR>
                case EXOSIP_CALL_PROCEEDING:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; proceeding! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                // announce ringback  <BR>
                case EXOSIP_CALL_RINGING:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; ringing! &lt;--\n&quot;   <BR>
                         &lt;&lt; &quot;\n\tcall_id is &quot; &lt;&lt; je-&gt;cid   <BR>
                         &lt;&lt; &quot;, dialog_id is &quot; &lt;&lt; je-&gt;did &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                // 收到请求，表示连接成功，下面发送回复确认  <BR>
                case EXOSIP_CALL_ANSWERED:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; ok! connected! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    call_id = je-&gt;cid;  <BR>
                    dialog_id = je-&gt;did;  <BR>
                    cout &lt;&lt; &quot;\n\tcall_id is &quot; &lt;&lt; je-&gt;cid   <BR>
                         &lt;&lt; &quot;, dialog_id is &quot; &lt;&lt; je-&gt;did &lt;&lt; endl;  <BR>
                    eXosip_call_build_ack (je-&gt;did, &amp;ack);  <BR>
                    eXosip_call_send_ack (je-&gt;did, ack);  <BR>
                    flag1 = 0;  <BR>
                    break;  <BR>
  <BR>
                case EXOSIP_CALL_CLOSED:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; the other sid closed! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                case EXOSIP_CALL_ACK:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; ACK received! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                default:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; other response!\n&quot; &lt;&lt;endl;  <BR>
                    break;  <BR>
                }  <BR>
            <BR>
                eXosip_event_free (je);  <BR>
            }  <BR>
  <BR>
            break;  <BR>
  <BR>
        case 'h':  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; Holded ! \n&quot; &lt;&lt; endl;  <BR>
        <BR>
            eXosip_lock ();  <BR>
            eXosip_call_terminate (call_id, dialog_id);  <BR>
            eXosip_unlock ();  <BR>
            break;  <BR>
  <BR>
        case 'c':  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; This modal isn't commpleted! \n&quot; &lt;&lt; endl;  <BR>
            break;  <BR>
  <BR>
        case 's':  <BR>
            // 传输 INFO 方法  <BR>
            eXosip_call_build_info (dialog_id, &amp;info);  <BR>
              <BR>
            snprintf (tmp , 4096, &quot;hello,bluesea&quot;);  <BR>
            osip_message_set_body (info, tmp, strlen(tmp));  <BR>
  <BR>
            // 格式可以任意设定, text/plain 代表文本信息  <BR>
            osip_message_set_content_type (info, &quot;text/plain&quot;);  <BR>
            eXosip_call_send_request (dialog_id, info);  <BR>
            break;  <BR>
  <BR>
        case 'm':  <BR>
            // 传输 MESSAGE方法,也就是即时消息，  <BR>
            // 和 INFO 方法相比，主要区别，是 MESSAGE 不用建立连接，直接传输信息，  <BR>
            // 而 INFO 必须在建立 INVITE 的基础上传输。  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; the mothed :MESSAGE \n&quot; &lt;&lt; endl;  <BR>
            eXosip_message_build_request (&amp;message,   <BR>
                                          &quot;MESSAGE&quot;,   <BR>
                                          strDestCall.c_str(),   <BR>
                                          strSrcCall.c_str(),   <BR>
                                          NULL);  <BR>
            strMsg = &quot;message: hello bluesea!&quot;;  <BR>
            osip_message_set_body (message, strMsg.c_str(), strMsg.length());  <BR>
        <BR>
            // 假设格式是xml  <BR>
            osip_message_set_content_type (message, &quot;text/xml&quot;);  <BR>
            eXosip_message_send_request (message);  <BR>
            break;  <BR>
  <BR>
        case 'q':  <BR>
            eXosip_quit ();  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; Exit the setup! \n&quot; &lt;&lt; endl;;  <BR>
            flag = 0;  <BR>
            break;  <BR>
  <BR>
        case 'e':  <BR>
            cout &lt;&lt; strHelp &lt;&lt; endl;  <BR>
            break;  <BR>
  <BR>
        default:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; 不支持的命令 &lt;--\n&quot; &lt;&lt; endl;  <BR>
            break;  <BR>
        }  <BR>
    }  <BR>
  <BR>
    return 0;  <BR>
}  <BR>
<BR>
<BR>
<BR>
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、<BR>
	USA代理服务器程序<BR>
<BR>
<BR>
/** <BR>
 * 一个使用了 osip 和 eXosip 库的 UAS 代理服务端的演示程序 <BR>
 *  <BR>
 * - 只是简单的演示了使用了 osip 和 eXosip2 库的 UAS 代理服务端的如下几个功能： <BR>
 *  <BR>
 * 编 译：g++ -I/usr/local/include -L/usr/local/lib ua_server.cpp -o ua_server -leXosip2 -losip2 -losipparser2 -lpthread <BR>
 *  <BR>
 */  <BR>
  <BR>
#include &lt;eXosip2/eXosip.h&gt;  <BR>
  <BR>
#include &lt;netinet/in.h&gt;  <BR>
#include &lt;sys/socket.h&gt;  <BR>
#include &lt;sys/types.h&gt;  <BR>
  <BR>
#include &lt;iostream&gt;  <BR>
#include &lt;fstream&gt;  <BR>
#include &lt;string&gt;  <BR>
  <BR>
using namespace std;  <BR>
  <BR>
int main()  <BR>
{  <BR>
    eXosip_event_t *je = NULL;  <BR>
    osip_message_t *ack = NULL;  <BR>
    osip_message_t *invite = NULL;  <BR>
    osip_message_t *answer = NULL;  <BR>
    sdp_message_t *remote_sdp = NULL;  <BR>
    int call_id, dialog_id;  <BR>
    int i,j;  <BR>
    int id;  <BR>
  <BR>
    char *sour_call = &quot;sip:136@133.37.55.136&quot;;  <BR>
    char *dest_call = &quot;sip:136@133.37.55.136:5061&quot;; //client ip/port  <BR>
  <BR>
    char command;  <BR>
    char tmp[4096];  <BR>
    char localip[128];  <BR>
    int pos = 0;  <BR>
  <BR>
    // 初始化 sip  <BR>
    i = eXosip_init ();  <BR>
    if (i != 0)  <BR>
    {  <BR>
        cerr &lt;&lt; &quot;\n\t--&gt; Can't initialize eXosip!\n&quot;;  <BR>
        return -1;  <BR>
    }  <BR>
    else  <BR>
    {  <BR>
        cout &lt;&lt; &quot;\n\t--&gt; eXosip_init successfully!\n&quot;;  <BR>
    }  <BR>
      <BR>
    i = eXosip_listen_addr (IPPROTO_UDP, NULL, 5060, AF_INET, 0);  <BR>
    if (i != 0)  <BR>
    {  <BR>
        eXosip_quit ();  <BR>
        cerr &lt;&lt; &quot;\n\t--&gt; eXosip_listen_addr error! Couldn't initialize transport layer!\n&quot;;  <BR>
    }  <BR>
  <BR>
    for(;;)  <BR>
    {  <BR>
        // 侦听是否有消息到来  <BR>
        je = eXosip_event_wait (0, 50);   <BR>
  <BR>
        // 协议栈带有此语句,具体作用未知  <BR>
        eXosip_lock ();  <BR>
        eXosip_default_action (je);  <BR>
        eXosip_automatic_refresh ();  <BR>
        eXosip_unlock ();  <BR>
  <BR>
        if (je == NULL) // 没有接收到消息，继续  <BR>
        {  <BR>
            continue;  <BR>
        }  <BR>
  <BR>
        switch (je-&gt;type)  <BR>
        {  <BR>
        case EXOSIP_MESSAGE_NEW: // 新的消息到来  <BR>
            cout &lt;&lt; &quot;\n\t*** EXOSIP_MESSAGE_NEW!\n&quot; &lt;&lt; endl;  <BR>
  <BR>
            if (MSG_IS_MESSAGE (je-&gt;request)) // 如果接收到的消息类型是 MESSAGE  <BR>
            {  <BR>
                {  <BR>
                    osip_body_t *body;  <BR>
                    osip_message_get_body (je-&gt;request, 0, &amp;body);   <BR>
                    cout &lt;&lt; &quot;I get the msg is: &quot; &lt;&lt; body-&gt;body &lt;&lt; endl;  <BR>
                }  <BR>
  <BR>
                // 按照规则，需要回复 OK 信息  <BR>
                eXosip_message_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
                eXosip_message_send_answer (je-&gt;tid, 200, answer);  <BR>
            }  <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_INVITE: // INVITE 请求消息  <BR>
            // 得到接收到消息的具体信息  <BR>
            cout &lt;&lt; &quot;\n\tReceived a INVITE msg from &quot; &lt;&lt; je-&gt;request-&gt;req_uri-&gt;host   <BR>
                 &lt;&lt; &quot; : &quot; &lt;&lt; je-&gt;request-&gt;req_uri-&gt;port   <BR>
                 &lt;&lt; &quot;, username is &quot; &lt;&lt; je-&gt;request-&gt;req_uri-&gt;username &lt;&lt; endl;  <BR>
  <BR>
            // 得到消息体,认为该消息就是 SDP 格式.  <BR>
            remote_sdp = eXosip_get_remote_sdp (je-&gt;did);  <BR>
            call_id = je-&gt;cid;  <BR>
            dialog_id = je-&gt;did;  <BR>
          <BR>
            eXosip_lock ();  <BR>
  <BR>
            eXosip_call_send_answer (je-&gt;tid, 180, NULL);  <BR>
            i = eXosip_call_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
            if (i != 0)  <BR>
            {  <BR>
                cout &lt;&lt; &quot;\n\t--&gt; This request msg is invalid! Cann't response!\n&quot; &lt;&lt; endl;  <BR>
                eXosip_call_send_answer (je-&gt;tid, 400, NULL);  <BR>
            }  <BR>
            else  <BR>
            {  <BR>
                snprintf (tmp, 4096,  <BR>
                    &quot;v=0\r\n&quot;  <BR>
                    &quot;o=anonymous 0 0 IN IP4 0.0.0.0\r\n&quot;  <BR>
                    &quot;t=1 10\r\n&quot;  <BR>
                    &quot;a=username:rainfish\r\n&quot;  <BR>
                    &quot;a=password:123\r\n&quot;);  <BR>
              <BR>
                // 设置回复的SDP消息体,下一步计划分析消息体  <BR>
                // 没有分析消息体，直接回复原来的消息，这一块做的不好。  <BR>
                osip_message_set_body (answer, tmp, strlen(tmp));  <BR>
                osip_message_set_content_type (answer, &quot;application/sdp&quot;);  <BR>
              <BR>
                eXosip_call_send_answer (je-&gt;tid, 200, answer);  <BR>
                cout &lt;&lt; &quot;\n\t--&gt; send 200 over!&quot; &lt;&lt; endl;  <BR>
            }  <BR>
  <BR>
            eXosip_unlock ();  <BR>
          <BR>
            // 显示出在 sdp 消息体中的 attribute 的内容,里面计划存放我们的信息  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; The INFO is :\n&quot; ;  <BR>
            while (!osip_list_eol ( &amp;(remote_sdp-&gt;a_attributes), pos))  <BR>
            {  <BR>
                sdp_attribute_t *at;  <BR>
              <BR>
                //这里解释了为什么在SDP消息体中属性a里面存放必须是两列  <BR>
                at = (sdp_attribute_t *) osip_list_get ( &amp;remote_sdp-&gt;a_attributes, pos);  <BR>
                cout &lt;&lt; &quot;\n\t&quot; &lt;&lt; at-&gt;a_att_field   <BR>
                     &lt;&lt; &quot; : &quot; &lt;&lt; at-&gt;a_att_value &lt;&lt; endl;  <BR>
              <BR>
                pos ++;  <BR>
            }  <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_ACK:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; ACK recieved!\n&quot; &lt;&lt; endl;  <BR>
            // printf (&quot;the cid is %s, did is %s\n&quot;, je-&gt;did, je-&gt;cid);   <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_CLOSED:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; the remote hold the session!\n&quot; &lt;&lt; endl;  <BR>
            // eXosip_call_build_ack(dialog_id, &amp;ack);  <BR>
            // eXosip_call_send_ack(dialog_id, ack);   <BR>
            i = eXosip_call_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
            if (i != 0)  <BR>
            {  <BR>
                printf (&quot;This request msg is invalid!Cann't response!\n&quot;);  <BR>
                eXosip_call_send_answer (je-&gt;tid, 400, NULL);  <BR>
            }  <BR>
            else  <BR>
            {  <BR>
                eXosip_call_send_answer (je-&gt;tid, 200, answer);  <BR>
                cout &lt;&lt; &quot;\n\t--&gt; bye send 200 over!\n&quot;;  <BR>
            }   <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_MESSAGE_NEW:  <BR>
  <BR>
            cout &lt;&lt; &quot;\n\t*** EXOSIP_CALL_MESSAGE_NEW\n&quot; &lt;&lt; endl;  <BR>
            if (MSG_IS_INFO(je-&gt;request) ) // 如果传输的是 INFO 方法  <BR>
            {  <BR>
                eXosip_lock ();  <BR>
                i = eXosip_call_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
                if (i == 0)  <BR>
                {  <BR>
                    eXosip_call_send_answer (je-&gt;tid, 200, answer);  <BR>
                }  <BR>
  <BR>
                eXosip_unlock ();  <BR>
  <BR>
                {  <BR>
                    osip_body_t *body;  <BR>
                    osip_message_get_body (je-&gt;request, 0, &amp;body);  <BR>
                    cout &lt;&lt; &quot;the body is &quot; &lt;&lt; body-&gt;body &lt;&lt; endl;  <BR>
                }  <BR>
            }  <BR>
            break;   <BR>
  <BR>
        default:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; Could not parse the msg!\n&quot; &lt;&lt; endl;  <BR>
        }  <BR>
    }   <BR>
  <BR>
    return 0;  <BR>
}  
</DD>
<DT>opencv</DT>
<!--property:date_created=1515740310-->
<!--property:date_modified=1515740318-->
<!--property:expanded-->
<DD>
clone opencv 和 opencv_conrib<BR>
<BR>
现在CMake<BR>
<BR>
configure<BR>
<BR>
配置<BR>
OPENCV_EXTRA_MODULES_PATH = opencv_contirb的path<DL>
<DT>编译</DT>
<!--property:date_created=1515740334-->
<!--property:date_modified=1515740334-->
<DT>人脸识别</DT>
<!--property:date_created=1515740503-->
<!--property:date_modified=1515740503-->
<!--property:expanded-->
<DD>
<DL>
<DT>基于python</DT>
<!--property:date_created=1515740512-->
<!--property:date_modified=1515740538-->
<DD>
openCV3的安装这里我说一下mac上的安装方法<BR>
<BR>
openCV3 在mac采用brew安装  如果brew没用过可以看下我之前写的安装Libpng的帖子里面有一些注意事项<BR>
<BR>
brew update #更新brew<BR>
<BR>
brew install opencv3 --with-contrib --with-python3 --without-python  #安装opencv3 保证python为3.x<BR>
<BR>
正常情况下就开始安装了 安装之后 找到opencv的so文件 <BR>
<BR>
默认在  /usr/local/Cellar/opencv3/3.1.0_4/lib/python3.6/site-packages/   #根据你的版本会有差异<BR>
<BR>
找到你python的安装位置的site-packages 目录<BR>
<BR>
默认在  /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/ #根据你的版本会有差异<BR>
<BR>
然后做一个软链<BR>
<BR>
ln -s /usr/local/Cellar/opencv3/3.2.0/lib/python3.6/site-packages/cv2.cpython-36m-darwin.so ./cv2<BR>
<BR>
<BR>
import cv2  <BR>
import numpy as np  <BR>
#指定图片的人脸识别然后存储  <BR>
img = cv2.imread(&quot;./333.jpg&quot;)  <BR>
color = (0, 255, 0)  <BR>
  <BR>
grey = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  <BR>
  <BR>
classfier = cv2.CascadeClassifier(&quot;./data/haarcascades/haarcascade_frontalface_alt2.xml&quot;)  <BR>
  <BR>
faceRects = classfier.detectMultiScale(grey, scaleFactor=1.2, minNeighbors=3, minSize=(32, 32))  <BR>
if len(faceRects) &gt; 0:  # 大于0则检测到人脸  <BR>
    for faceRect in faceRects:  # 单独框出每一张人脸  <BR>
        x, y, w, h = faceRect  <BR>
        cv2.rectangle(img, (x - 10, y - 10), (x + w + 10, y + h + 10), color, 3) #5控制绿色框的粗细  <BR>
  <BR>
# 写入图像  <BR>
cv2.imwrite('./aaa.jpg',img)  
</DD>
</DL>

</DD>
</DL>

</DD>
</DL>

</DD>
<DT>opencv</DT>
<!--property:date_created=1515752319-->
<!--property:date_modified=1515752319-->
<DD>
<DL>
<DT>opencv编译</DT>
<!--property:date_created=1515752333-->
<!--property:date_modified=1515752900-->
<DD>
https://github.com/opencv/opencv_3rdparty/branches/all<BR>
第三方库<BR>
<BR>
ffmpeg处理<BR>
1.解压压缩文件，获得目录中的三个文件 ffmpeg_version.cmake/opencv_ffmpeg.dll/opencv_ffmpeg_64.dll<BR>
<BR>
复制到opencv/sources/3rdparty/ffmpeg目录下<BR>
<BR>
编辑 ffmpeg.cmake<BR>
message(STATUS &quot;FFMPEG: Package successfully downloaded&quot;)<BR>
include(${CMAKE_CURRENT_LIST_DIR}/ffmpeg_version.cmake)<BR>
<BR>
ipppicv配置<BR>
解压文件<BR>
创建文件夹<BR>
unpack,解压得到的ippicv_win复制到新建的unpack中<BR>
将downloader.cmake内容修改为<BR>
#<BR>
# The script downloads ICV package<BR>
#<BR>
# On return this will define:<BR>
# OPENCV_ICV_PATH - path to unpacked downloaded package<BR>
#<BR>
<BR>
function(_icv_downloader)<BR>
  # Commit SHA in the opencv_3rdparty repo<BR>
  set(IPPICV_BINARIES_COMMIT &quot;81a676001ca8075ada498583e4166079e5744668&quot;)<BR>
  # Define actual ICV versions<BR>
  if(APPLE)<BR>
    set(OPENCV_ICV_PACKAGE_NAME &quot;ippicv_macosx_20151201.tgz&quot;)<BR>
    set(OPENCV_ICV_PACKAGE_HASH &quot;4ff1fde9a7cfdfe7250bfcd8334e0f2f&quot;)<BR>
    set(OPENCV_ICV_PLATFORM &quot;macosx&quot;)<BR>
    set(OPENCV_ICV_PACKAGE_SUBDIR &quot;/ippicv_osx&quot;)<BR>
  elseif(UNIX)<BR>
    if(ANDROID AND NOT (ANDROID_ABI STREQUAL x86 OR ANDROID_ABI STREQUAL x86_64))<BR>
      return()<BR>
    endif()<BR>
    set(OPENCV_ICV_PACKAGE_NAME &quot;ippicv_linux_20151201.tgz&quot;)<BR>
    set(OPENCV_ICV_PACKAGE_HASH &quot;808b791a6eac9ed78d32a7666804320e&quot;)<BR>
    set(OPENCV_ICV_PLATFORM &quot;linux&quot;)<BR>
    set(OPENCV_ICV_PACKAGE_SUBDIR &quot;/ippicv_lnx&quot;)<BR>
  elseif(WIN32 AND NOT ARM)<BR>
    set(OPENCV_ICV_PACKAGE_NAME &quot;ippicv_windows_20151201.zip&quot;)<BR>
    set(OPENCV_ICV_PACKAGE_HASH &quot;04e81ce5d0e329c3fbc606ae32cad44d&quot;)<BR>
    set(OPENCV_ICV_PLATFORM &quot;windows&quot;)<BR>
    set(OPENCV_ICV_PACKAGE_SUBDIR &quot;/ippicv_win&quot;)<BR>
  else()<BR>
    return() # Not supported<BR>
  endif()<BR>
<BR>
  set(OPENCV_ICV_UNPACK_PATH &quot;${CMAKE_CURRENT_LIST_DIR}/unpack&quot;)<BR>
  set(OPENCV_ICV_PATH &quot;${OPENCV_ICV_UNPACK_PATH}${OPENCV_ICV_PACKAGE_SUBDIR}&quot;)<BR>
<BR>
  message(STATUS &quot;ICV: Package successfully downloaded&quot;)<BR>
  set(OPENCV_ICV_PATH &quot;${OPENCV_ICV_PATH}&quot; PARENT_SCOPE)<BR>
endfunction()<BR>
<BR>
_icv_downloader()<BR>
<BR>
处理face_landmark_model.dat文件下载失败原因<BR>
<BR>

</DD>
<DT>New node</DT>
<!--property:date_created=1516249394-->
<!--property:date_modified=1516249394-->
</DL>

</DD>
<DT>Osip2&amp;Exosip2</DT>
<!--property:date_created=1515575286-->
<!--property:date_modified=1515575473-->
<DD>
<BR>
库名	功能<BR>
Osip2	一个开源的SIP协议栈，使用C编写，主要提供解析SIP和SDP消息的API和事物处理的状态机。<BR>
Exosip2	是对Osip2协议栈的封装和调用，作为Osip2的一个扩展协议集，使得Osip2更容易被使用。<BR>
Boost	一个准标准库，相当于对STL的的延续和扩充。<BR>
Loki	C++的模板类库<BR>
<BR>
sip事务的概念：一个sip请求以及由它触发的一系列应答（包括临时应答和一个最终应答）。<BR>
<BR>
sip请求有6种（核心规范定义的，也有扩展），也叫6个方法(Method字段标识)：INVITE, ACK, OPTIONS, BYE, CANCEL, REGISTER<BR>
<BR>
sip 请求的格式包括请求行(如INVITE sip:192.168.101.30 SIP/2.0)，sip应答的格式包括状态行(如SIP/2.0 100 Trying)；sip应答的状态码从100到699，其中100~199是临时(provisional)应答。<BR>
<BR>
INVITE请求是三次握手机制，其他请求都采用两次握手机制。<BR>
<BR>
CANCEL 请求用于取消悬而未决的事务，我的理解是一方发出INVITE，但是另一方始终没有做出应答，发出200OK消息（超过了默认的振铃时长），那么UAC会 自动发出一个CANCEL请求，UAS返回200OK，并且同时发出487状态码的应答，UAC再对收到的487消息发出ACK确认，即最开始的 INVITE和487以及ACK构成三次握手。<BR>
<BR>
OPTIONS请求用于询问服务器的性能情况，包括这个服务器所支持的方法（可能会有扩展方法）和会话描述协议。<BR>
<BR>
代理服务器的三种类型：保留呼叫状态代理、保留状态代理、不保留状态代理。这三种类型的代理在处理能力和所占用资源上有差别，在代理分发中我们采用网络核心无状态，而在流量较小的网络边界采用智能性高的保留（呼叫）状态服务器处理路由。<BR>
<BR>
sip消息编码采用文本方式（即使用字符串），相对的是二进制的编码方式，前者易于调试和扩展，后者则有利于节省带宽。<BR>
<BR>
sip标题头：<BR>
CALL-ID 字 段用于标识一个特定邀请以及与这个邀请相关的所有后续事务（即标识一个会话），比如一方发起邀请加入一个国际象棋的会话，那么INVITE请求以及应答， BYE请求以及应答都共享一个CALL-ID，因为这两个事务都属于一个特定邀请。而两个用户之间可以同时存在多个邀请（比如在下象棋的同时发起聊天的邀 请），那么一个邀请中的后续事务将通过这个邀请特有的CALL-ID来区分，如一方发出BYE消息来结束聊天，但是下棋仍然进行中，那么另一方将根据 BYE消息的CALL-ID来确定要结束的究竟是哪一个会话。 <BR>
<BR>
CSeq 字段是用来给同一个会话中的 事务进行排序的。可以理解为，会话由CALL-ID来标识，会话中的事务则由CSeq标识。除了ACK请求和CANCEL请求，INVITE之后的请求中 CSeq字段的数字是最初请求(INVITE)的CSeq递增的结果。而ACK和CANCEL请求则拥有与它所确认（取消）的请求相同的CSeq数字部 分，只是方法名不同。<BR>
(sip标题头续)<BR>
Contact 字段是被呼叫方发送200OK消息时带上的，包含了被叫方的真实IP，这样sip服务器在路由第一个INVITE请求之后就可以被卸载掉（越过），不再需要存在于信令路径中。<BR>
<BR>
Recode-Route和Route字 段是用来使sip服务器保留在每次请求中，不被绕过。Record-Route字段由信令路径上的服务器添加（每经过一个信令路径上必须存在的代理，就添 加一个Record-Route标题头），maddr参数包含该代理的IP地址。被叫方发出的200OK应答包含Record-Route和 Contact字段（Record-Route可能有多个），呼叫方收到200OK后根据这两个字段创建用于后续请求的Route标题头（可能有多个）， 其包含的是信令路径上的下一跳的下一跳的（hehe，有点别扭，不过意思是对的）真实IP。<BR>
<BR>
To 字段 总是包含被呼叫方的地址（通过sip代理时是公用地址，点对点时是真实ip），要注意的是区别该标题头和sip消息请求行中的Request-URI。 To在信令路径中不会被代理改变，然而Request-URI包含的是信令路径中下一跳的地址，因此在路途中被每个代理改变。<BR>
<BR>
Via 字 段存储所有处理请求的代理地址（包括用户代理和sip代理），它可以用来检测路由循环，也用于使应答消息经过请求消息来时相同的路径（方向相反）。因此， 在请求消息发送时，via标题头的数量是随着跳数逐渐增加的，而应答消息返回时，via标题头的数量则逐渐递减（每经过一跳则剥离一个有它自己地址的 Via标题头）。<BR>
(sip标题头完)<BR>
<BR>
sip消息可能含有消息体（一个或多个），通常是会话描述符，也可以是照片或其他附件。一般情况下，消息体只对UA有意义，因此可被端到端加密。有时候，sip代理处于控制的原因也需要检查被交换媒体的信息。 <BR>
 NVITE事务：<BR>
<BR>
SIP使用UDP传输协议来传送INVITE消息时，要使用逐 跳重传机制保证INVITE的最终传送，即用户代理UA和sip代理proxy都要保证INVITE到达下一跳，下一跳收到时会返回一个临时应答 （proxy返回100Trying，UA返回100Trying和180ringing），代理在限定时间内收不到应答即会重传INVITE。<BR>
<BR>
临时应答（100~199）用于阻止逐跳INVITE重传，没有端到端的可靠传输，也就是说当被叫方返回180应答时，如果在路径中途丢失，也不会重传。<BR>
<BR>
最终应答（200~699）能被保证到达它们想要去的目的地。<BR>
成 功应答（200~299）被可靠地传送到呼叫方UA，但不是使用逐跳重传机制。只有呼叫方UA能为最终成功应答发送一个ACK（直接发送到被叫方UA）， 如果成功应答在路径中途丢失或者UA发出的ACK丢失，那么被叫方会在限定时间内收不到ACK时重新发送最终应答，直到收到ACK的确认。<BR>
非成功最终应答（300~699）使用和INVITE一样的逐跳机制。被叫方用户代理将持续重传非成功应答（给前一跳），直到收到ACK为止（proxy也可以为非成功应答发送ACK）。<BR>
CANCEL事务：<BR>
CANCEL事务与INVITE事务都是逐跳事务，但是处理方法不同，路径上的每一个代理收到CANCEL请求时，都会发送一个最终应答来响应（而不是发出临时应答），并且向下一跳发送一个CANCEL请求。
</DD>
<DT>osip</DT>
<!--property:date_created=1515669641-->
<!--property:date_modified=1515669654-->
<DD>
ares_platform.h,<BR>
<BR>
ares_platform.c,<BR>
<BR>
ares_create_query.c<DL>
<DT>UAC代理</DT>
<!--property:date_created=1515731364-->
<!--property:date_modified=1515731372-->
<!--property:expanded-->
<DD>
    ----------- UAC 代理客户端的代码整理 ---------------  <BR>
   <BR>
/** <BR>
 * 一个使用了 osip 和 eXosip 库的 UAC 代理客户端的演示程序 <BR>
 *  <BR>
 * - 只是简单的演示了使用了 osip 和 eXosip2 库的 UAC 代理客户端的如下几个功能： <BR>
 * * i 发起呼叫 INVITE 请求 <BR>
 * * h 挂断会话 <BR>
 * * s 执行方法 INFO  <BR>
 * * m 执行方法 MESSAGE <BR>
 *  <BR>
 * 编 译：g++ -I/usr/local/include -L/usr/local/lib ua_client.cpp -o ua_client -leXosip2 -losip2 -losipparser2 -lpthread <BR>
 *  <BR>
 */  <BR>
  <BR>
#include &lt;osip2/osip_mt.h&gt;  <BR>
#include &lt;eXosip2/eXosip.h&gt;  <BR>
  <BR>
#include &lt;netinet/in.h&gt;  <BR>
#include &lt;sys/socket.h&gt;  <BR>
#include &lt;sys/types.h&gt;  <BR>
  <BR>
#include &lt;iostream&gt;  <BR>
#include &lt;string&gt;  <BR>
  <BR>
using namespace std;  <BR>
  <BR>
int main(int argc, char* argv[])  <BR>
{  <BR>
    eXosip_event_t *je;  <BR>
    osip_message_t *reg = NULL;  <BR>
    osip_message_t *invite = NULL;  <BR>
    osip_message_t *ack = NULL;  <BR>
    osip_message_t *info = NULL;  <BR>
    osip_message_t *message = NULL;  <BR>
    int call_id, dialog_id;  <BR>
    int i,flag;  <BR>
    int flag1 = 1;  <BR>
    int id;  <BR>
      <BR>
    string strIdentity = &quot;sip:136@133.37.55.136&quot;;  <BR>
    string strRegisterer = &quot;sip:133.37.55.136:5060&quot;; // server ip  <BR>
  <BR>
    string strSrcCall = &quot;sip:136@133.37.55.136&quot;;  <BR>
    string strDestCall = &quot;sip:136@133.37.55.136:5060&quot;; // server ip  <BR>
  <BR>
      <BR>
    char command;  <BR>
    char tmp[4096];  <BR>
    char localip[128];  <BR>
  <BR>
    string strHelp = string(&quot;\n\t--&gt; 命令字符 功能描述 &lt;--\n\n&quot;)  <BR>
                        + &quot;\t\tr 向服务器注册\n&quot;  <BR>
                        + &quot;\t\tc 取消注册\n&quot;  <BR>
                        + &quot;\t\ti 发起呼叫请求\n&quot;  <BR>
                        + &quot;\t\th 挂断\n&quot;  <BR>
                        + &quot;\t\tq 退出程序\n&quot;  <BR>
                        + &quot;\t\ts 执行方法 INFO\n&quot;  <BR>
                        + &quot;\t\tm 执行方法 MESSAGE\n&quot;  <BR>
                        + &quot;\t\te 帮助\n\n&quot;;  <BR>
    cout &lt;&lt; strHelp;  <BR>
  <BR>
    string strMsg;  <BR>
  <BR>
    i = eXosip_init ();  <BR>
    if (i != 0)  <BR>
    {  <BR>
        cout &lt;&lt; &quot;\t--&gt; Couldn't initialize eXosip! &lt;--\n&quot;;  <BR>
        return -1;  <BR>
    }  <BR>
    else  <BR>
    {  <BR>
        cout &lt;&lt; &quot;\t--&gt; eXosip_init successfully! &lt;-- \n\n&quot;;  <BR>
    }  <BR>
  <BR>
    i = eXosip_listen_addr (IPPROTO_UDP, NULL, 5061, AF_INET, 0);  <BR>
    if (i != 0)  <BR>
    {  <BR>
        eXosip_quit ();  <BR>
        cerr &lt;&lt; &quot;\n\t--&gt; Couldn't initialize transport layer! &lt;-- \n\n&quot;;  <BR>
        return -1;  <BR>
    }  <BR>
    flag = 1;  <BR>
    while (flag)  <BR>
    {  <BR>
        cout &lt;&lt; &quot;请输入一个命令字符：\t&quot;;  <BR>
        cin &gt;&gt; command;  <BR>
        <BR>
        switch (command)  <BR>
        {  <BR>
        case 'r':  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; This modal isn't commpleted! \n&quot; &lt;&lt; endl;  <BR>
            break;  <BR>
  <BR>
        case 'i': // 初始化的 INVITE 请求  <BR>
            i = eXosip_call_build_initial_invite (&amp;invite,   <BR>
                                                  strDestCall.c_str(),   <BR>
                                                  strSrcCall.c_str(),   <BR>
                                                  NULL,   <BR>
                                                  &quot;This is a call for a conversation&quot;);  <BR>
            if (i != 0)  <BR>
            {  <BR>
                cout &lt;&lt; &quot;\n --&gt; Intial INVITE failed! &lt;-- \n&quot;;  <BR>
                break;  <BR>
            }  <BR>
  <BR>
            // 符合 SDP 格式, 其中属性 a 是自定义格式,也就是说可以存放自己的信息,   <BR>
            // 但是只能是两列,比如帐户信息  <BR>
            // 但是经测试,格式: v o t必不可少,原因未知,估计是协议栈在传输时需要检查的  <BR>
  <BR>
            strMsg = string(&quot;v=0\r\n&quot;)  <BR>
                   + &quot;o=anonymous 0 0 IN IP4 0.0.0.0\r\n&quot;  <BR>
                   + &quot;t=1 10\r\n&quot;  <BR>
                   + &quot;a=username:bluesea\r\n&quot;  <BR>
                   + &quot;a=password:123456\r\n&quot;;  <BR>
  <BR>
            osip_message_set_body (invite, strMsg.c_str(), strMsg.length());  <BR>
            osip_message_set_content_type (invite, &quot;application/sdp&quot;);  <BR>
        <BR>
            // 这里使用了锁机制以保证同步  <BR>
            eXosip_lock ();  <BR>
            i = eXosip_call_send_initial_invite (invite);  <BR>
            eXosip_unlock ();  <BR>
            flag1 = 1;  <BR>
            while (flag1)  <BR>
            {  <BR>
                je = eXosip_event_wait (0, 200);  <BR>
                if (je == NULL)  <BR>
                {  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; No response or the time is over! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
                }  <BR>
            <BR>
                switch (je-&gt;type)  <BR>
                {  <BR>
                case EXOSIP_CALL_INVITE:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; a new invite reveived! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                // announce processing by a remote app  <BR>
                case EXOSIP_CALL_PROCEEDING:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; proceeding! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                // announce ringback  <BR>
                case EXOSIP_CALL_RINGING:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; ringing! &lt;--\n&quot;   <BR>
                         &lt;&lt; &quot;\n\tcall_id is &quot; &lt;&lt; je-&gt;cid   <BR>
                         &lt;&lt; &quot;, dialog_id is &quot; &lt;&lt; je-&gt;did &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                // 收到请求，表示连接成功，下面发送回复确认  <BR>
                case EXOSIP_CALL_ANSWERED:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; ok! connected! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    call_id = je-&gt;cid;  <BR>
                    dialog_id = je-&gt;did;  <BR>
                    cout &lt;&lt; &quot;\n\tcall_id is &quot; &lt;&lt; je-&gt;cid   <BR>
                         &lt;&lt; &quot;, dialog_id is &quot; &lt;&lt; je-&gt;did &lt;&lt; endl;  <BR>
                    eXosip_call_build_ack (je-&gt;did, &amp;ack);  <BR>
                    eXosip_call_send_ack (je-&gt;did, ack);  <BR>
                    flag1 = 0;  <BR>
                    break;  <BR>
  <BR>
                case EXOSIP_CALL_CLOSED:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; the other sid closed! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                case EXOSIP_CALL_ACK:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; ACK received! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                default:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; other response!\n&quot; &lt;&lt;endl;  <BR>
                    break;  <BR>
                }  <BR>
            <BR>
                eXosip_event_free (je);  <BR>
            }  <BR>
  <BR>
            break;  <BR>
  <BR>
        case 'h':  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; Holded ! \n&quot; &lt;&lt; endl;  <BR>
        <BR>
            eXosip_lock ();  <BR>
            eXosip_call_terminate (call_id, dialog_id);  <BR>
            eXosip_unlock ();  <BR>
            break;  <BR>
  <BR>
        case 'c':  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; This modal isn't commpleted! \n&quot; &lt;&lt; endl;  <BR>
            break;  <BR>
  <BR>
        case 's':  <BR>
            // 传输 INFO 方法  <BR>
            eXosip_call_build_info (dialog_id, &amp;info);  <BR>
              <BR>
            snprintf (tmp , 4096, &quot;hello,bluesea&quot;);  <BR>
            osip_message_set_body (info, tmp, strlen(tmp));  <BR>
  <BR>
            // 格式可以任意设定, text/plain 代表文本信息  <BR>
            osip_message_set_content_type (info, &quot;text/plain&quot;);  <BR>
            eXosip_call_send_request (dialog_id, info);  <BR>
            break;  <BR>
  <BR>
        case 'm':  <BR>
            // 传输 MESSAGE方法,也就是即时消息，  <BR>
            // 和 INFO 方法相比，主要区别，是 MESSAGE 不用建立连接，直接传输信息，  <BR>
            // 而 INFO 必须在建立 INVITE 的基础上传输。  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; the mothed :MESSAGE \n&quot; &lt;&lt; endl;  <BR>
            eXosip_message_build_request (&amp;message,   <BR>
                                          &quot;MESSAGE&quot;,   <BR>
                                          strDestCall.c_str(),   <BR>
                                          strSrcCall.c_str(),   <BR>
                                          NULL);  <BR>
            strMsg = &quot;message: hello bluesea!&quot;;  <BR>
            osip_message_set_body (message, strMsg.c_str(), strMsg.length());  <BR>
        <BR>
            // 假设格式是xml  <BR>
            osip_message_set_content_type (message, &quot;text/xml&quot;);  <BR>
            eXosip_message_send_request (message);  <BR>
            break;  <BR>
  <BR>
        case 'q':  <BR>
            eXosip_quit ();  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; Exit the setup! \n&quot; &lt;&lt; endl;;  <BR>
            flag = 0;  <BR>
            break;  <BR>
  <BR>
        case 'e':  <BR>
            cout &lt;&lt; strHelp &lt;&lt; endl;  <BR>
            break;  <BR>
  <BR>
        default:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; 不支持的命令 &lt;--\n&quot; &lt;&lt; endl;  <BR>
            break;  <BR>
        }  <BR>
    }  <BR>
  <BR>
    return 0;  <BR>
}  <BR>
    ----------- UAS 代理服务器端的代码整理 ---------------  <BR>
  <BR>
/** <BR>
 * 一个使用了 osip 和 eXosip 库的 UAS 代理服务端的演示程序 <BR>
 *  <BR>
 * - 只是简单的演示了使用了 osip 和 eXosip2 库的 UAS 代理服务端的如下几个功能： <BR>
 *  <BR>
 * 编 译：g++ -I/usr/local/include -L/usr/local/lib ua_server.cpp -o ua_server -leXosip2 -losip2 -losipparser2 -lpthread <BR>
 *  <BR>
 */  <BR>
  <BR>
#include &lt;eXosip2/eXosip.h&gt;  <BR>
  <BR>
#include &lt;netinet/in.h&gt;  <BR>
#include &lt;sys/socket.h&gt;  <BR>
#include &lt;sys/types.h&gt;  <BR>
  <BR>
#include &lt;iostream&gt;  <BR>
#include &lt;fstream&gt;  <BR>
#include &lt;string&gt;  <BR>
  <BR>
using namespace std;  <BR>
  <BR>
int main()  <BR>
{  <BR>
    eXosip_event_t *je = NULL;  <BR>
    osip_message_t *ack = NULL;  <BR>
    osip_message_t *invite = NULL;  <BR>
    osip_message_t *answer = NULL;  <BR>
    sdp_message_t *remote_sdp = NULL;  <BR>
    int call_id, dialog_id;  <BR>
    int i,j;  <BR>
    int id;  <BR>
  <BR>
    char *sour_call = &quot;sip:136@133.37.55.136&quot;;  <BR>
    char *dest_call = &quot;sip:136@133.37.55.136:5061&quot;; //client ip/port  <BR>
  <BR>
    char command;  <BR>
    char tmp[4096];  <BR>
    char localip[128];  <BR>
    int pos = 0;  <BR>
  <BR>
    // 初始化 sip  <BR>
    i = eXosip_init ();  <BR>
    if (i != 0)  <BR>
    {  <BR>
        cerr &lt;&lt; &quot;\n\t--&gt; Can't initialize eXosip!\n&quot;;  <BR>
        return -1;  <BR>
    }  <BR>
    else  <BR>
    {  <BR>
        cout &lt;&lt; &quot;\n\t--&gt; eXosip_init successfully!\n&quot;;  <BR>
    }  <BR>
      <BR>
    i = eXosip_listen_addr (IPPROTO_UDP, NULL, 5060, AF_INET, 0);  <BR>
    if (i != 0)  <BR>
    {  <BR>
        eXosip_quit ();  <BR>
        cerr &lt;&lt; &quot;\n\t--&gt; eXosip_listen_addr error! Couldn't initialize transport layer!\n&quot;;  <BR>
    }  <BR>
  <BR>
    for(;;)  <BR>
    {  <BR>
        // 侦听是否有消息到来  <BR>
        je = eXosip_event_wait (0, 50);   <BR>
  <BR>
        // 协议栈带有此语句,具体作用未知  <BR>
        eXosip_lock ();  <BR>
        eXosip_default_action (je);  <BR>
        eXosip_automatic_refresh ();  <BR>
        eXosip_unlock ();  <BR>
  <BR>
        if (je == NULL) // 没有接收到消息，继续  <BR>
        {  <BR>
            continue;  <BR>
        }  <BR>
  <BR>
        switch (je-&gt;type)  <BR>
        {  <BR>
        case EXOSIP_MESSAGE_NEW: // 新的消息到来  <BR>
            cout &lt;&lt; &quot;\n\t*** EXOSIP_MESSAGE_NEW!\n&quot; &lt;&lt; endl;  <BR>
  <BR>
            if (MSG_IS_MESSAGE (je-&gt;request)) // 如果接收到的消息类型是 MESSAGE  <BR>
            {  <BR>
                {  <BR>
                    osip_body_t *body;  <BR>
                    osip_message_get_body (je-&gt;request, 0, &amp;body);   <BR>
                    cout &lt;&lt; &quot;I get the msg is: &quot; &lt;&lt; body-&gt;body &lt;&lt; endl;  <BR>
                }  <BR>
  <BR>
                // 按照规则，需要回复 OK 信息  <BR>
                eXosip_message_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
                eXosip_message_send_answer (je-&gt;tid, 200, answer);  <BR>
            }  <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_INVITE: // INVITE 请求消息  <BR>
            // 得到接收到消息的具体信息  <BR>
            cout &lt;&lt; &quot;\n\tReceived a INVITE msg from &quot; &lt;&lt; je-&gt;request-&gt;req_uri-&gt;host   <BR>
                 &lt;&lt; &quot; : &quot; &lt;&lt; je-&gt;request-&gt;req_uri-&gt;port   <BR>
                 &lt;&lt; &quot;, username is &quot; &lt;&lt; je-&gt;request-&gt;req_uri-&gt;username &lt;&lt; endl;  <BR>
  <BR>
            // 得到消息体,认为该消息就是 SDP 格式.  <BR>
            remote_sdp = eXosip_get_remote_sdp (je-&gt;did);  <BR>
            call_id = je-&gt;cid;  <BR>
            dialog_id = je-&gt;did;  <BR>
          <BR>
            eXosip_lock ();  <BR>
  <BR>
            eXosip_call_send_answer (je-&gt;tid, 180, NULL);  <BR>
            i = eXosip_call_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
            if (i != 0)  <BR>
            {  <BR>
                cout &lt;&lt; &quot;\n\t--&gt; This request msg is invalid! Cann't response!\n&quot; &lt;&lt; endl;  <BR>
                eXosip_call_send_answer (je-&gt;tid, 400, NULL);  <BR>
            }  <BR>
            else  <BR>
            {  <BR>
                snprintf (tmp, 4096,  <BR>
                    &quot;v=0\r\n&quot;  <BR>
                    &quot;o=anonymous 0 0 IN IP4 0.0.0.0\r\n&quot;  <BR>
                    &quot;t=1 10\r\n&quot;  <BR>
                    &quot;a=username:rainfish\r\n&quot;  <BR>
                    &quot;a=password:123\r\n&quot;);  <BR>
              <BR>
                // 设置回复的SDP消息体,下一步计划分析消息体  <BR>
                // 没有分析消息体，直接回复原来的消息，这一块做的不好。  <BR>
                osip_message_set_body (answer, tmp, strlen(tmp));  <BR>
                osip_message_set_content_type (answer, &quot;application/sdp&quot;);  <BR>
              <BR>
                eXosip_call_send_answer (je-&gt;tid, 200, answer);  <BR>
                cout &lt;&lt; &quot;\n\t--&gt; send 200 over!&quot; &lt;&lt; endl;  <BR>
            }  <BR>
  <BR>
            eXosip_unlock ();  <BR>
          <BR>
            // 显示出在 sdp 消息体中的 attribute 的内容,里面计划存放我们的信息  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; The INFO is :\n&quot; ;  <BR>
            while (!osip_list_eol ( &amp;(remote_sdp-&gt;a_attributes), pos))  <BR>
            {  <BR>
                sdp_attribute_t *at;  <BR>
              <BR>
                //这里解释了为什么在SDP消息体中属性a里面存放必须是两列  <BR>
                at = (sdp_attribute_t *) osip_list_get ( &amp;remote_sdp-&gt;a_attributes, pos);  <BR>
                cout &lt;&lt; &quot;\n\t&quot; &lt;&lt; at-&gt;a_att_field   <BR>
                     &lt;&lt; &quot; : &quot; &lt;&lt; at-&gt;a_att_value &lt;&lt; endl;  <BR>
              <BR>
                pos ++;  <BR>
            }  <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_ACK:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; ACK recieved!\n&quot; &lt;&lt; endl;  <BR>
            // printf (&quot;the cid is %s, did is %s\n&quot;, je-&gt;did, je-&gt;cid);   <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_CLOSED:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; the remote hold the session!\n&quot; &lt;&lt; endl;  <BR>
            // eXosip_call_build_ack(dialog_id, &amp;ack);  <BR>
            // eXosip_call_send_ack(dialog_id, ack);   <BR>
            i = eXosip_call_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
            if (i != 0)  <BR>
            {  <BR>
                printf (&quot;This request msg is invalid!Cann't response!\n&quot;);  <BR>
                eXosip_call_send_answer (je-&gt;tid, 400, NULL);  <BR>
            }  <BR>
            else  <BR>
            {  <BR>
                eXosip_call_send_answer (je-&gt;tid, 200, answer);  <BR>
                cout &lt;&lt; &quot;\n\t--&gt; bye send 200 over!\n&quot;;  <BR>
            }   <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_MESSAGE_NEW:  <BR>
  <BR>
            cout &lt;&lt; &quot;\n\t*** EXOSIP_CALL_MESSAGE_NEW\n&quot; &lt;&lt; endl;  <BR>
            if (MSG_IS_INFO(je-&gt;request) ) // 如果传输的是 INFO 方法  <BR>
            {  <BR>
                eXosip_lock ();  <BR>
                i = eXosip_call_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
                if (i == 0)  <BR>
                {  <BR>
                    eXosip_call_send_answer (je-&gt;tid, 200, answer);  <BR>
                }  <BR>
  <BR>
                eXosip_unlock ();  <BR>
  <BR>
                {  <BR>
                    osip_body_t *body;  <BR>
                    osip_message_get_body (je-&gt;request, 0, &amp;body);  <BR>
                    cout &lt;&lt; &quot;the body is &quot; &lt;&lt; body-&gt;body &lt;&lt; endl;  <BR>
                }  <BR>
            }  <BR>
            break;   <BR>
  <BR>
        default:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; Could not parse the msg!\n&quot; &lt;&lt; endl;  <BR>
        }  <BR>
    }   <BR>
  <BR>
    return 0;  <BR>
}  
</DD>
<DT>exosip2文档</DT>
<!--property:date_created=1515731524-->
<!--property:date_modified=1515738900-->
<DD>
libeXosip2文档<BR>
<BR>
1.想要用eXosip服务，你的首要任务是要先初始化eXosip内容和libosip库（解析状态机），这必须要在所有操作之前做的事<BR>
<BR>
同样你必须在交换层，选择一种协议（UDP, TCP，TLS或者是DTLS）<BR>
<BR>
下面便是基本的一些操作<BR>
1.1     初始化跟踪信息<BR>
#include &lt;eXosip2/eXosip.h&gt;<BR>
<BR>
eXosip *ctx;<BR>
int i  = 0;<BR>
int port = 5060;<BR>
TRACE_INITIALIZE(6, NULL);<BR>
<BR>
1.2    初始化eXosip(和osip)栈<BR>
ctx = eXosip_malloc();<BR>
if(ctx == NULL)<BR>
return -1;<BR>
<BR>
i = eXosip_init(ctx);<BR>
if(i != 0)<BR>
return -1;<BR>
<BR>
1.3  打开一个UDP socket接收信号<BR>
i = eXosip_listen_addr (ctx, IPPROTO_UDP, NULL, port, AF_INET, 0);<BR>
if (i!=0)<BR>
  {<BR>
    eXosip_quit(ctx);<BR>
    fprintf (stderr, &quot;could not initialize transport layer\n&quot;);<BR>
    return -1;<BR>
  }<BR>
<BR>
/*<BR>
还可以选择其他协议<BR>
UDP:<BR>
i = eXosip_listen_addr (ctx, IPPROTO_UDP, NULL, 5060, AF_INET, 0);<BR>
TCP:<BR>
i = eXosip_listen_addr (ctx, IPPROTO_TCP, NULL, 5060, AF_INET, 0);<BR>
TLS:<BR>
i = eXosip_listen_addr (ctx, IPPROTO_TCP, NULL, 5061, AF_INET, 1);<BR>
DTLS:<BR>
i = eXosip_listen_addr (ctx, IPPROTO_UDP, NULL, 5061, AF_INET, 1);<BR>
*/<BR>
<BR>
选择TLS协议可能需要特殊的设置，TLS实际上引入了两个有趣的特性:<BR>
<BR>
使用certiticates和钥匙，它有助于信任/验证远程服务器<BR>
它还加密数据，以便中间没有人能够读取SIP流量。<BR>
<BR>
如果你不需要服务器验证，TLS很容易安装。您不需要配置任何证书、密钥或根证书…<BR>
下面对的代码就是用来取消服务器证书验证的<BR>
<BR>
int val = 0；<BR>
i = eXosip_set_option(ctx, EX_OSIP_OTP_SET_TLS_VERIFY_CERTIFICATE, (void*) &amp;val);<BR>
<BR>
如果需要验证，还需要做一些工作。您需要的取决于您的平台/操作系统。<BR>
<BR>
在windows上注册：<BR>
在Windows中，使用“Windows证书存储具有内置的支持”。因此，你只需要添加你的证书和密钥在官方的Windows证书存储”。<BR>
<BR>
在mac上注册：<BR>
在MacOSX，exosip为证书存储的内置支持<BR>
<BR>
在其他平台注册：<BR>
eXosip_tls_ctx_t = tls_info;<BR>
memset(&amp;tls_info, 0, sizeof(eXosip_tls_ctx_t));<BR>
snprintf(tls_info.client.cert, sizeof(tls_info.client.cert), &quot;user-cert.crt&quot;);<BR>
snprintf(tls_info.client.priv_key, sizeof(tls_info.client.priv_key), &quot;user-privkey.crt&quot;);<BR>
snprintf(tls_info.client.priv_key_pw, sizeof(tls_info.client.priv_key_pw), &quot;password&quot;);<BR>
snprintf(tls_info.root_ca_cert, sizeof(tls_info.root_ca_cert), &quot;cacert.crt&quot;);<BR>
<BR>
i = eXosip_set_option (ctx, EXOSIP_OPT_SET_TLS_CERTIFICATES_INFO, (void*)&amp;tls_info);<BR>
<BR>
1.4 额外需要初始化的一些设置<BR>
一些选项可以被修改，但是大部分最好还是用默认设置，如果您的SIP服务配置正确，则不需要超出缺省值的设置。<BR>
下面是一些宏<BR>
EXOSIP_OPT_UDP_KEEP_ALIVE 1<BR>
EXOSIP_OPT_UDP_LEARN_PORT 2<BR>
EXOSIP_OPT_USE_RPORT 7<BR>
EXOSIP_OPT_SET_IPV4_FOR_GATEWAY 8<BR>
EXOSIP_OPT_ADD_DNS_CACHE 9<BR>
EXOSIP_OPT_DELETE_DNS_CACHE 10<BR>
EXOSIP_OPT_SET_IPV6_FOR_GATEWAY 12<BR>
EXOSIP_OPT_ADD_ACCOUNT_INFO 13<BR>
EXOSIP_OPT_DNS_CAPABILITIES 14<BR>
EXOSIP_OPT_SET_DSCP 15<BR>
EXOSIP_OPT_REGISTER_WITH_DATE 16<BR>
EXOSIP_OPT_SET_HEADER_USER_AGENT 17<BR>
EXOSIP_OPT_SET_TLS_VERIFY_CERTIFICATE 500<BR>
EXOSIP_OPT_SET_TLS_CERTIFICATES_INFO 501<BR>
EXOSIP_OPT_SET_TLS_CLIENT_CERTIFICATE_NAME 502<BR>
EXOSIP_OPT_SET_TLS_SERVER_CERTIFICATE_NAME 503<BR>
<BR>
下面是一个基本配置，可能适合于常规配置：<BR>
int val;<BR>
eXosip_set_user_agent (ctx, &quot;exosipdemo/0.0.0&quot;);<BR>
val=17000;<BR>
eXosip_set_option (ctx, EXOSIP_OPT_UDP_KEEP_ALIVE, (void*)&amp;val);<BR>
val=2;<BR>
eXosip_set_option (ctx, EXOSIP_OPT_DNS_CAPABILITIES, (void*)&amp;val);<BR>
val=1;<BR>
eXosip_set_option (ctx, EXOSIP_OPT_USE_RPORT, (void*)&amp;val);<BR>
val=26;<BR>
eXosip_set_option (ctx, EXOSIP_OPT_SET_DSCP, (void*)&amp;dscp_value);<BR>
eXosip_set_option (ctx, EXOSIP_OPT_SET_IPV4_FOR_GATEWAY, &quot;sip.antisip.com&quot;);<BR>
<BR>
NAT和联系人报头<BR>
这里需要特殊强调，大部分的exosip2栈本身无关…<BR>
<BR>
使用SIP最重要的特性是能够接收SIP请求。如果你的手机保持沉默，你不会高兴的。然而，在理论上无法猜测哪些内容应该包含我们正在创建的联络头。<BR>
<BR>
大多数代理将修理断了联系，不管为什么exosip2或SIP的应用提供了一个错误的价值。SIP规范对各种客户机和服务器行为的联系验证不很清楚。<BR>
<BR>
然而：<BR>
        1.没关系，什么exosip2代理将修复，最正确。<BR>
	2.不管你认为什么是正确的，有些人认为另一种方式是正确的。<BR>
	3。无论SIP、代理和人员：网络规则总是首先应用！；<BR>
	<BR>
<BR>
无论如何，去避免以下问题<BR>
       1.你应该尽自己所能去提供正确的消息在联系上	，你应该尽最大努力把正确的信息联系起来。<BR>
	2.大多数情况下，你不能，但无论如何都应该有效。<BR>
	<BR>
结论：<BR>
	1.没有任何配置（NAT，眩晕等），您的代理应该能够找到如何到达您（在现有的连接）<BR>
	2.如果它不能（不管什么原因），你可以尝试的解决方法和选择。<BR>
	<BR>
解决方法：<BR>
此选项有助于exosip2检测是当你有几个因素：（例如VPN和eth0）。这将有助于检测是通过接触。通常的参数是代理。（谨慎：由于DNS操作，方法可能会阻塞）<BR>
<BR>
eXosip_set_option(ctx, EXOSIP_OPT_SET_IPV4_FOR_GATEWAY, &quot;sip.antisio.com&quot;);<BR>
<BR>
伪装：当发送你的第一个SIP请求（登记？选择？）上面的答案，通过将包含“接受”和“报告”参数：那些IP /端口是你接触代理头所需的精确的。眩晕将检测类似的IP /端口，但另一个目的地（眩晕服务器）。因此，眩晕不是正确的方法。<BR>
,这样，发送个请求给你的代理，验证方式是（发送还是请求）参数，使用伪装<BR>
eXosip_masquerade_contact(ctx, &quot;91.121.81.212&quot;, 10456);<BR>
<BR>
exosip_opt_udp_learn_port选项：如果你想再通过“接收”和“报告”自动与UDP。使用下面的代码，第二个寄存器（在身份验证之后）？或第二输出请求将包含伪装接触头。如果你用STUN协议值伪装，它也应该被使用。<BR>
<BR>
eXosip_masquerade_contact (ctx, &quot;192.168.2.1&quot;, 5080); <BR>
val=1;<BR>
eXosip_set_option (ctx, EXOSIP_OPT_UDP_LEARN_PORT, &amp;val);<BR>
<BR>
EXOSIP_OPT_USE_RPORT选项：仅用破碎的NAT。在传出要求“报告”参数删除此选项。这应该永远不用。<BR>
<BR>
val=0;<BR>
eXosip_set_option (ctx, EXOSIP_OPT_USE_RPORT, &amp;val);<BR>
<BR>
<BR>
2	HANDLE eXosip2 events	(exosip2事件处理, eXosip_event_t)<BR>
<BR>
2.1 eXosip_event包含你所有需要的信息<BR>
	rid: identifier for registrations.  （注册标识符）<BR>
	tid: identifier for transactions.    （事物标识符）<BR>
	cid, did identifiers for calls.         （调用标示符）<BR>
	sid, did: identifier for outgoing subscriptions.  （传出订阅标识符）<BR>
	nid, did: identifier for incoming subscriptions.  （传入订阅标识符）<BR>
	request: outgoing or incoming request for the event  （事件出入栈请求）<BR>
	answer: outgoing or incoming answer for the event   （事件出入应答）<BR>
	ack: outgoing or incoming ACK for the event      (事件传入传出ACK)<BR>
	<BR>
	这些标示符，被重新用于相关exosip2 API，使他变得更简单更易于控制，回答和ACK是完全复制你可以访问，不需要对exosip2加锁<BR>
	现在你必须要去处理exosip事件，这里是一些从eXosip2栈获取exosip事件的方法代码<BR>
	eXosip_event_t *evt;<BR>
	for(;;)<BR>
	{<BR>
		evt = eXosip_event_wait(ctx, 0, 50);<BR>
		eXosip_lock(ctx);<BR>
		eXosip_automatic_action(ctx);<BR>
		eXosip_unlock(ctx);<BR>
<BR>
		if(evt == NULL)			<BR>
			continue;<BR>
		if(evt-&gt;type == EXOSIP_CALL_NEW)<BR>
		{<BR>
			...			<BR>
		}<BR>
		else if(evt-&gt;type == EXOSIP_CALL_ACK)<BR>
		{<BR>
			...		<BR>
		}<BR>
		else if(evt-&gt;type == EXOSIP_CALL_ANSWERED)<BR>
		{<BR>
			...		<BR>
		}<BR>
		else<BR>
			....<BR>
			<BR>
		eXosip_event_free(evt);<BR>
	}<BR>
<BR>
你没发送一个sip消息就会接受到一个事件，每个事件包含受影响事务的原始请求和可用时触发事件的最后响应。<BR>
<BR>
您可以访问这些消息的所有标头，并将它们存储在自己的上下文中，用于其他操作或图形显示。<BR>
<BR>
例如：<BR>
	当你接受到一个REFER请求，请求呼叫转移，你通常会检索的”指的是“头：<BR>
	<BR>
	osip_header_t* referto_head = NULL;<BR>
	i = osip_message_header_get_byname(evt-&gt;sip, &quot;refer-to&quot;, 0, &amp;referto_head);<BR>
	if(referto_head == NULL || refferto_head-&gt;hvalue == NULL)<BR>
	<BR>
	接听180来电<BR>
	if(evt-&gt;type == EXOSIP_CALL_NEW)<BR>
	{<BR>
		eXosip_lock(ctx);<BR>
		eXosip_call_send_answer(ctx, evt-&gt;tid, 180, NULL);<BR>
		eXosip_unlock(ctx);	<BR>
	}<BR>
<BR>
	答案200确定来电：（同时检查在EVT的附件&gt;的要求！<BR>
	<BR>
	Answer 200 ok to an incoming MESSAGE:(also check the attachment in evt-&gt;request!)<BR>
<BR>
	if(evt-&gt;type == EXOSIP_MESSAGE_NEW &amp;&amp; osip_strcasecmp(minfo.method, &quot;MESSAGE&quot;) == 0)<BR>
	{<BR>
		osip_message_t *answer=NULL;<BR>
		  int i;<BR>
		  eXosip_lock (ctx);<BR>
		  i = eXosip_message_build_answer (ctx, evt-&gt;tid, 200, &amp;answer);<BR>
		  i = eXosip_message_send_answer (ctx, evt-&gt;tid, 200, answer);<BR>
		  eXosip_unlock (ctx);<BR>
	}<BR>
<BR>
	处理对话框里的入栈呼叫，（呼叫转移）<BR>
	if (evt-&gt;type == EXOSIP_CALL_MESSAGE_NEW &amp;&amp; osip_strcasecmp (minfo.method, &quot;REFER&quot;) == 0)<BR>
	 {<BR>
		  osip_header_t *refer_to = NULL;<BR>
		  eXosip_lock (ctx);<BR>
		  i = eXosip_call_build_answer (ctx, evt-&gt;tid, 202, &amp;answer);<BR>
		  i = eXosip_call_send_answer (ctx, evt-&gt;tid, 202, answer);<BR>
		  i = osip_message_header_get_byname (evt-&gt;request, &quot;refer-to&quot;, 0, &amp;refer_to);<BR>
		  if (i &gt;= 0) {<BR>
		    printf (&quot;you must start call to: %s\n&quot;, refer_to-&gt;hvalue);<BR>
		    ...<BR>
		  }<BR>
		  else {<BR>
		  }<BR>
		  eXosip_call_terminate (ctx, evt-&gt;cid, evt-&gt;did, 486);<BR>
		  eXosip_unlock (ctx);<BR>
	}<BR>
<BR>
<BR>
<BR>

</DD>
<DT>sip协议开发</DT>
<!--property:date_created=1516346817-->
<!--property:date_modified=1516346835-->
<DD>
rtp必须关闭
</DD>
</DL>

</DD>
<DT>USX协议</DT>
<!--property:date_created=1516355397-->
<!--property:date_modified=1516355406-->
<DD>
关见字:<BR>
<BR>
UDP UDX RTP,RUDP<BR>
<BR>
UDP可靠传输,UDP文件传输,P2P<BR>
<BR>
UDP文件传输<BR>
<BR>
 <BR>
<BR>
一种基于UDP的可靠传输协议-UDX<BR>
<BR>
 <BR>
<BR>
UDX作为一个新的协议,从研发到成功经力了相当长一段时间.<BR>
<BR>
http://topic.csdn.net/u/20091130/12/0ea2c403-b7bd-4b27-bc17-6e5b5cd4cd55.html<BR>
<BR>
http://bbs.gameres.com/showthread.asp?page=end&amp;threadid=154641<BR>
<BR>
 <BR>
<BR>
目前算法基本已经定型,以其稳定高效,接口封富得到了广大网友开发者好评!<BR>
<BR>
 <BR>
<BR>
UDX开发说明文档.<BR>
<BR>
UDX是完全基于标准c++开发的一套UDP传输库,类似TCP,是一种可靠传输算法.主要是兼顾TCP的可靠性和UDP的实时性.另外一个最重要的优势是算法的可控性.<BR>
<BR>
    UDX的目的是为了让开发人员更好更快的去开发开效率的UDP网络应用软件,UDX主要是以oo的概念来设计开发的,接口SDK形式提供,提供方法和事件模式,也提供API WIN32 DLL.activex,提供静态库,动态库版本.<BR>
    UDX内置文件传输接口,支持UDP中转,P2P接口,流式,包式封装,大简化程序员的工作量,提供20多个实用的例子代码.根据其特点,可以用于文件传输,IM(www.commnetsoft.com),视频聊天,聊天室,视频监控等,当然还可以用在竟技类,rpg等游戏 中,根据实际情况决定<BR>
  目前有windows版本和linux版本.<BR>
 <BR>
<BR>
 <BR>
<BR>
经过本人及各位好友的测试,在传输效率上和QQ直传效率相当,在很多情况都是略胜QQ的文件传输.在效率和重传率方面优于开源的UDT,raknet,jrtp等库.<BR>
<BR>
 <BR>
<BR>
是UDP开发者的首选.<BR>
<BR>
 <BR>
<BR>
UDX的作者是野蛮人(QQ 24508609 MSN WPLLG@HOTMAIL.COM)<BR>
<BR>
<BR>
http://blog.csdn.net/wwwllg/article/details/5883545<BR>
<BR>

</DD>
<DT>rtp数据传输</DT>
<!--property:date_created=1516249401-->
<!--property:date_modified=1516249421-->
<DD>
可以通过生成SDP文件给播放器在指定端口接收数据播放,如果你不用动态调整编码器什么的就不用考虑另外发送RTCP.<BR>
而且RTCP必须自己实现RTSP服务结合起来用,没有实现RTSP服务,就谈不上实现RTCP.<BR>
<BR>
具体H264字节流拆包和RTP封包方法如下:<BR>
<BR>
UINT MediaStreamH264::TransportData(PBYTE pData, UINT dataSize, int pts)<BR>
{<BR>
PBYTE p_buffer = pData;<BR>
int	i_buffer = dataSize;<BR>
<BR>
UINT writeSize = 0;<BR>
<BR>
while( i_buffer &gt; 4 &amp;&amp; ( p_buffer[0] != 0 || p_buffer[1] != 0 || p_buffer[2] != 1 ) )<BR>
{<BR>
i_buffer--;<BR>
p_buffer++;<BR>
}<BR>
<BR>
/* Split nal units */<BR>
while( i_buffer &gt; 4 )<BR>
{<BR>
int i_offset;<BR>
int i_size = i_buffer;<BR>
int i_skip = i_buffer;<BR>
<BR>
/* search nal end */<BR>
for( i_offset = 4; i_offset+2 &lt; i_buffer ; i_offset++)<BR>
{<BR>
if( p_buffer[i_offset] == 0 &amp;&amp; p_buffer[i_offset+1] == 0 &amp;&amp; p_buffer[i_offset+2] == 1 )<BR>
{<BR>
/* we found another startcode */<BR>
i_size = i_offset - ( p_buffer[i_offset-1] == 0 ? 1 : 0);<BR>
i_skip = i_offset;<BR>
break;<BR>
} <BR>
}<BR>
/* TODO add STAP-A to remove a lot of overhead with small slice/sei/... */<BR>
UINT iWrite = TransportH264Nal(p_buffer, i_size, pts, (i_size &gt;= i_buffer) );<BR>
if (iWrite &gt; 0 )<BR>
writeSize += iWrite;<BR>
<BR>
i_buffer -= i_skip;<BR>
p_buffer += i_skip;<BR>
}<BR>
return writeSize;<BR>
}<BR>
<BR>
UINT MediaStreamH264::TransportH264Nal(const PBYTE pNal, UINT nalSize, INT32 pts, BOOL isLast)<BR>
{<BR>
ATLock atlock(&amp;m_tlockRun);<BR>
<BR>
if (m_bRun == FALSE)<BR>
return 0;<BR>
<BR>
if( nalSize &lt; 5 )<BR>
return 0;<BR>
<BR>
UINT	mtu = m_nMTU;<BR>
<BR>
const int i_max = mtu - RTP_HEADER_SIZE; /* payload max in one packet */<BR>
int i_nal_hdr;<BR>
int i_nal_type;<BR>
<BR>
i_nal_hdr = pNal[3];<BR>
i_nal_type = i_nal_hdr&amp;0x1f;<BR>
<BR>
string sps;<BR>
string pps;<BR>
<BR>
if( i_nal_type == 7 || i_nal_type == 8 )<BR>
{<BR>
/* XXX Why do you want to remove them ? It will break streaming with <BR>
* SPS/PPS change (broadcast) ? */<BR>
return 0;<BR>
}<BR>
<BR>
/* Skip start code */<BR>
PBYTE p_data = pNal;<BR>
int	i_data = nalSize;<BR>
<BR>
p_data += 3;<BR>
i_data -= 3;<BR>
<BR>
int writeSize = 0;<BR>
<BR>
if( i_data &lt;= i_max )<BR>
{<BR>
/* Single NAL unit packet */<BR>
//writeSize = m_pRtpTransport-&gt;SetRtpData(p_data, i_data, pts, isLast);<BR>
writeSize = m_pRtpTransport-&gt;Write(p_data, i_data, m_nRtpPayloadType, pts, 0, isLast);<BR>
if (writeSize &lt;= 0)<BR>
return 0;<BR>
return writeSize;<BR>
}<BR>
else<BR>
{<BR>
/* FU-A Fragmentation Unit without interleaving */<BR>
const int i_count = ( i_data-1 + i_max-2 - 1 ) / (i_max-2);<BR>
int i;<BR>
<BR>
p_data++;<BR>
i_data--;<BR>
<BR>
for( i = 0; i &lt; i_count; i++ )<BR>
{<BR>
const int i_payload =  (i_data &lt; (i_max-2)) ? i_data : (i_max-2);<BR>
const int nalSize = 2 + i_payload;<BR>
<BR>
m_Packet.ExtendBuffer(nalSize);<BR>
<BR>
/* FU indicator */<BR>
m_Packet.m_pData[0] = 0x00 | (i_nal_hdr &amp; 0x60) | 28;<BR>
/* FU header */<BR>
m_Packet.m_pData[1] = ( i == 0 ? 0x80 : 0x00 ) | ( (i == i_count-1) ? 0x40 : 0x00 )  | i_nal_type;<BR>
<BR>
/* FU payload */<BR>
memcpy( &amp;m_Packet.m_pData[2], p_data, i_payload );<BR>
<BR>
m_Packet.m_DataSize = nalSize;<BR>
<BR>
//int iWrite = m_pRtpTransport-&gt;SetRtpData(m_Packet.m_pData, m_Packet.m_DataSize, pts, isLast &amp;&amp; (i == i_count-1));<BR>
int iWrite = m_pRtpTransport-&gt;Write(m_Packet.m_pData, m_Packet.m_DataSize, m_nRtpPayloadType, pts, 0, isLast &amp;&amp; (i == i_count-1));<BR>
if (iWrite &gt; 0)<BR>
writeSize += iWrite;<BR>
<BR>
i_data -= i_payload;<BR>
p_data += i_payload;<BR>
}<BR>
}<BR>
return writeSize;<BR>
}<BR>
<DL>
<DT>H264解析RGB</DT>
<!--property:date_created=1516595541-->
<!--property:date_modified=1516598575-->
<DD>
全局变量建在头文件里报重定义，一定要cpp里边，然后extern进去头文件<BR>
<BR>
void  PtzCamera::OnStreamReadyProc(void *pUserData, void* buff, long size, int frametype)<BR>
{	<BR>
	int got_picture = 0;<BR>
	int decode_len = 0;<BR>
<BR>
	//写文件<BR>
	//static FILE *file1 = fopen(&quot;10.avi&quot;, &quot;wb+&quot;);<BR>
	//fwrite(buff, size, 1, file1);<BR>
<BR>
	//return;<BR>
	PtzCamera* pvs = (PtzCamera*)pUserData;<BR>
<BR>
	pvs-&gt;m_tmtLastRecvVideo = time(NULL);<BR>
<BR>
	if (pvs-&gt;m_nDecode &lt; 0)<BR>
	{<BR>
		return;<BR>
	}<BR>
	if(pvs-&gt;m_nDecode == 1) /*由内部解码，内部解码出RGB图像通过OnRealRGBReady传出*/<BR>
	{<BR>
		if(pvs-&gt;m_pfnOnStreamReady != NULL)<BR>
			pvs-&gt;m_pfnOnStreamReady(pvs-&gt;m_pUserData,buff,size,frametype);<BR>
		return;<BR>
	}<BR>
<BR>
	if (pvs-&gt;m_nCodec == VE_CODEC_ID_NONE)<BR>
	{<BR>
		return;<BR>
	}<BR>
<BR>
	if(pvs-&gt;m_nFFmpegInitialed == 0)<BR>
	{<BR>
		//avcodec_init();<BR>
		avcodec_register_all();<BR>
		av_register_all();<BR>
		pvs-&gt;m_nFFmpegInitialed = 1;<BR>
	}<BR>
<BR>
	if(pvs-&gt;m_nCodecInitialed == 0 <BR>
		&amp;&amp; pvs-&gt;m_nFFmpegInitialed == 1)<BR>
	{<BR>
		AVCodecID avCodec;<BR>
		switch(pvs-&gt;m_nCodec)<BR>
		{<BR>
		case VE_CODEC_ID_H264:<BR>
			avCodec = AV_CODEC_ID_H264;<BR>
			break;<BR>
		case VE_CODEC_ID_MPEG4:<BR>
			avCodec = AV_CODEC_ID_MPEG4;<BR>
			break;<BR>
		case VE_CODEC_ID_MJPEG:<BR>
			avCodec = AV_CODEC_ID_MJPEG;<BR>
			break;<BR>
		default:<BR>
			avCodec = (AVCodecID)pvs-&gt;m_nCodec;<BR>
			break;<BR>
		}<BR>
		pvs-&gt;codec = avcodec_find_decoder(avCodec);<BR>
		pvs-&gt;context = avcodec_alloc_context3(pvs-&gt;codec);<BR>
		pvs-&gt;frame = av_frame_alloc();<BR>
		av_init_packet(&amp;pvs-&gt;m_avPkt);<BR>
		pvs-&gt;m_nCodecInitialed = 1;<BR>
		avcodec_open2(pvs-&gt;context, pvs-&gt;codec,NULL);<BR>
	}<BR>
<BR>
	if(pvs-&gt;m_nCodecInitialed == 0)<BR>
		return;<BR>
<BR>
	if(pvs-&gt;buffer_pos+size &gt; pvs-&gt;buffer_size)<BR>
	{<BR>
		uint8_t *temp = pvs-&gt;buffer_stream;<BR>
		pvs-&gt;buffer_size = pvs-&gt;buffer_pos+size*2;			<BR>
		pvs-&gt;buffer_stream = new uint8_t[pvs-&gt;buffer_size];<BR>
		memcpy(pvs-&gt;buffer_stream,temp+pvs-&gt;total_decode_len,pvs-&gt;buffer_pos);<BR>
		delete [] temp;<BR>
	}<BR>
<BR>
	memcpy(pvs-&gt;buffer_stream+pvs-&gt;buffer_pos,buff,size);<BR>
	pvs-&gt;buffer_pos+=size;<BR>
	<BR>
	pvs-&gt;m_avPkt.data = (unsigned char*)pvs-&gt;buffer_stream + pvs-&gt;total_decode_len;<BR>
	pvs-&gt;m_avPkt.size = pvs-&gt;buffer_pos;<BR>
<BR>
		//static FILE *file2 = fopen(&quot;12.avi&quot;, &quot;wb+&quot; );<BR>
		//fwrite(avPkt.data, avPkt.size, 1, file2);<BR>
<BR>
	do<BR>
	{<BR>
		decode_len = avcodec_decode_video2(pvs-&gt;context, pvs-&gt;frame, &amp;got_picture, &amp;pvs-&gt;m_avPkt);<BR>
<BR>
		if(decode_len &lt; 0 &amp;&amp; (pvs-&gt;first_frame))<BR>
		{<BR>
			pvs-&gt;buffer_pos = 0;<BR>
			pvs-&gt;first_frame = false;<BR>
		}<BR>
		else if(decode_len &gt; 0)<BR>
		{<BR>
			if(pvs-&gt;m_pfnOnStreamReady != NULL)<BR>
				pvs-&gt;m_pfnOnStreamReady(pvs-&gt;m_pUserData,pvs-&gt;buffer_stream+pvs-&gt;total_decode_len,decode_len,pvs-&gt;frame-&gt;key_frame==1?1:3);<BR>
			//fwrite(pvs-&gt;buffer_stream+pvs-&gt;total_decode_len,decode_len,1,fp);<BR>
<BR>
			pvs-&gt;buffer_pos -= decode_len;<BR>
			pvs-&gt;total_decode_len += decode_len;<BR>
			pvs-&gt;m_avPkt.data = (unsigned char*)pvs-&gt;buffer_stream + pvs-&gt;total_decode_len + decode_len;<BR>
			pvs-&gt;m_avPkt.size -= decode_len;<BR>
		}<BR>
<BR>
		if(got_picture)<BR>
		{<BR>
			if(pvs-&gt;frame_rgb == NULL)<BR>
			{<BR>
				pvs-&gt;frame_rgb = av_frame_alloc();<BR>
				int bytes = avpicture_get_size(AV_PIX_FMT_RGB24, pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;height);<BR>
				pvs-&gt;buffer_rgb=(uint8_t *)av_malloc(bytes);<BR>
				avpicture_fill((AVPicture *)pvs-&gt;frame_rgb, pvs-&gt;buffer_rgb, AV_PIX_FMT_RGB24,pvs-&gt;context-&gt;width, pvs-&gt;context-&gt;height);<BR>
			}<BR>
<BR>
			SwsContext *img_convert_ctx = sws_getContext(pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;height,<BR>
				pvs-&gt;context-&gt;pix_fmt,<BR>
				pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;height,<BR>
				AV_PIX_FMT_BGR24,<BR>
				SWS_FAST_BILINEAR, NULL, NULL, NULL);<BR>
<BR>
			sws_scale(img_convert_ctx, pvs-&gt;frame-&gt;data, <BR>
				pvs-&gt;frame-&gt;linesize, 0, pvs-&gt;context-&gt;height, <BR>
				pvs-&gt;frame_rgb-&gt;data, pvs-&gt;frame_rgb-&gt;linesize);<BR>
<BR>
			sws_freeContext(img_convert_ctx);<BR>
<BR>
			if(pvs-&gt;m_pfnOnRealRGBReady != NULL)<BR>
				pvs-&gt;m_pfnOnRealRGBReady(pvs-&gt;m_pUserData,pvs-&gt;buffer_rgb,pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;width*3,pvs-&gt;context-&gt;height);<BR>
		}<BR>
	}<BR>
	while(decode_len&gt;0);<BR>
<BR>
	if(pvs-&gt;total_decode_len &gt;= pvs-&gt;buffer_pos)<BR>
	{<BR>
		if(pvs-&gt;buffer_pos != 0)<BR>
			memcpy(pvs-&gt;buffer_stream,pvs-&gt;buffer_stream+pvs-&gt;total_decode_len,pvs-&gt;buffer_pos);<BR>
		pvs-&gt;total_decode_len = 0;<BR>
	}<BR>
}<BR>
<BR>
<BR>
void  CYTControlDlg::CalcDisplayRect(LPRECT lpWndRect,int width, int height,CRect&amp; displayRect)<BR>
{<BR>
	CRect rectWnd(lpWndRect);<BR>
<BR>
	float a = (float)width/(float)height;<BR>
	float b = (float)rectWnd.Width()/(float)rectWnd.Height();<BR>
<BR>
	if (a &gt; b)<BR>
	{<BR>
		if (width &gt; rectWnd.Width())<BR>
		{<BR>
			displayRect.left = rectWnd.left;<BR>
			displayRect.right = rectWnd.right;<BR>
			int c = (height*displayRect.Width())/width;<BR>
			displayRect.top = rectWnd.top + (rectWnd.Height()-c)/2;<BR>
			displayRect.bottom = displayRect.top+c;<BR>
		}<BR>
		else<BR>
		{<BR>
			displayRect.left =rectWnd.left + (rectWnd.Width()-width)/2;<BR>
			displayRect.right = displayRect.left + width;<BR>
			displayRect.top = rectWnd.top + (rectWnd.Height()-height)/2;<BR>
			displayRect.bottom = displayRect.top + height;<BR>
		}<BR>
	}<BR>
	else<BR>
	{<BR>
		if (height &gt; rectWnd.Height())<BR>
		{<BR>
			displayRect.top = rectWnd.top;<BR>
			displayRect.bottom = displayRect.top+rectWnd.Height();<BR>
			int c = (width*rectWnd.Height())/height;<BR>
			displayRect.left = rectWnd.left + (rectWnd.Width()-c)/2;<BR>
			displayRect.right = displayRect.left+c;<BR>
		}<BR>
		else<BR>
		{<BR>
			displayRect.top = rectWnd.top+(rectWnd.Height()-height)/2;<BR>
			displayRect.bottom = displayRect.top + height;<BR>
			displayRect.left = rectWnd.left + (rectWnd.Width()-width)/2;<BR>
			displayRect.right = displayRect.left + width;<BR>
		}<BR>
	}<BR>
}<BR>
<BR>
<BR>
void  CYTControlDlg::DisplayRGB24(void* buff, int width,int storewidth, int height)<BR>
{<BR>
	if(m_rcDisplay.Width() == 0)<BR>
	{<BR>
		RECT  rcWnd;<BR>
		rcWnd.left = 0;<BR>
		rcWnd.top = 0;<BR>
		rcWnd.right = m_rcDisplayWnd.Width();<BR>
		rcWnd.bottom = m_rcDisplayWnd.Height();		<BR>
<BR>
		CalcDisplayRect(&amp;rcWnd,width,height,m_rcDisplay);<BR>
	}<BR>
<BR>
	m_nImgWidth = width;<BR>
	m_nImgHeight = height;<BR>
<BR>
<BR>
	IplImage *pDigitVideoImage;<BR>
	pDigitVideoImage = cvCreateImage(cvSize(width,height),8,3);<BR>
	memcpy(pDigitVideoImage-&gt;imageData,buff,width*height*3);<BR>
	ShowImage(pDigitVideoImage,IDC_VIDEO_WND);<BR>
	<BR>
	//测试录像功能结束<BR>
	cvReleaseImage(&amp;pDigitVideoImage);<BR>
	m_nFrameRateCount++;<BR>
}
</DD>
</DL>

</DD>
<DT>Gradle</DT>
<!--property:date_created=1516684902-->
<!--property:date_modified=1516684914-->
<DD>
http://services.gradle.org/distributions/<BR>
<BR>
网上下载
</DD>
<DT>windows多线程笔记</DT>
<!--property:date_created=1516775582-->
<!--property:date_modified=1516777557-->
<DD>
1。防止多个线程同时修改同一块内存，导致的值得不可预见性<BR>
1.增减操作<BR>
LONG__cdeclInterlockedIncrement(LONG volatile* Addend);<BR>
LONG__cdeclInterlockedDecrement(LONG volatile* Addend);<BR>
<BR>
返回变量执行增减操作之后的值。<BR>
LONG__cdec InterlockedExchangeAdd(LONG volatile* Addend, LONGValue);<BR>
返回运算后的值，注意！加个负数就是减。<BR>
 <BR>
2.赋值操作<BR>
LONG__cdeclInterlockedExchange(LONG volatile* Target, LONGValue);<BR>
<BR>
DWORD WINAPI ThreadFun(void *pPM)  <BR>
{  <BR>
    Sleep(100);//some work should to do  <BR>
    //g_nLoginCount++;  <BR>
    InterlockedIncrement((LPLONG)&amp;g_nLoginCount);  <BR>
    Sleep(50);  <BR>
    return 0;  <BR>
}  <BR>
<BR>
<BR>
2.多线程同步-临界区的使用<BR>
<BR>
CRITICAL_SECTION lock<BR>
<BR>
函数功能：初始化<BR>
函数原型：<BR>
void InitializeCriticalSection(LPCRITICAL_SECTIONlpCriticalSection);<BR>
函数说明：定义关键段变量后必须先初始化。<BR>
 <BR>
函数功能：销毁<BR>
函数原型：<BR>
void DeleteCriticalSection(LPCRITICAL_SECTIONlpCriticalSection);<BR>
函数说明：用完之后记得销毁。<BR>
 <BR>
函数功能：进入关键区域<BR>
函数原型：<BR>
void EnterCriticalSection(LPCRITICAL_SECTIONlpCriticalSection);<BR>
函数说明：系统保证各线程互斥的进入关键区域。<BR>
 <BR>
函数功能：离开关关键区域<BR>
函数原型：<BR>
void LeaveCriticalSection(LPCRITICAL_SECTIONlpCriticalSection);<BR>
<BR>
<BR>
3.事件处理<BR>
第一个 CreateEvent<BR>
函数功能：创建事件<BR>
函数原型：<BR>
HANDLECreateEvent(<BR>
 LPSECURITY_ATTRIBUTESlpEventAttributes,<BR>
 BOOLbManualReset,<BR>
 BOOLbInitialState,<BR>
 LPCTSTRlpName<BR>
);<BR>
函数说明：<BR>
第一个参数表示安全控制，一般直接传入NULL。<BR>
第二个参数确定事件是手动置位还是自动置位，传入TRUE表示手动置位，传入FALSE表示自动置位。如果为自动置位，则对该事件调用WaitForSingleObject()后会自动调用ResetEvent()使事件变成未触发状态。打个小小比方，手动置位事件相当于教室门，教室门一旦打开（被触发），所以有人都可以进入直到老师去关上教室门（事件变成未触发）。自动置位事件就相当于医院里拍X光的房间门，门打开后只能进入一个人，这个人进去后会将门关上，其它人不能进入除非门重新被打开（事件重新被触发）。<BR>
第三个参数表示事件的初始状态，传入TRUR表示已触发。<BR>
第四个参数表示事件的名称，传入NULL表示匿名事件。<BR>
<BR>
 第二个 OpenEvent<BR>
函数功能：根据名称获得一个事件句柄。<BR>
函数原型：<BR>
HANDLEOpenEvent(<BR>
 DWORDdwDesiredAccess,<BR>
 BOOLbInheritHandle,<BR>
 LPCTSTRlpName     //名称<BR>
);<BR>
函数说明：<BR>
第一个参数表示访问权限，对事件一般传入EVENT_ALL_ACCESS。详细解释可以查看MSDN文档。<BR>
第二个参数表示事件句柄继承性，一般传入TRUE即可。<BR>
第三个参数表示名称，不同进程中的各线程可以通过名称来确保它们访问同一个事件。<BR>
<BR>
<BR>
第三个SetEvent<BR>
函数功能：触发事件<BR>
函数原型：BOOLSetEvent(HANDLEhEvent);<BR>
函数说明：每次触发后，必有一个或多个处于等待状态下的线程变成可调度状态。<BR>
 <BR>
第四个ResetEvent<BR>
函数功能：将事件设为末触发<BR>
函数原型：BOOLResetEvent(HANDLEhEvent);<BR>
 <BR>
最后一个事件的清理与销毁<BR>
由于事件是内核对象，因此使用CloseHandle()就可以完成清理与销毁了。
</DD>
<DT>OpenH264</DT>
<!--property:date_created=1516785001-->
<!--property:date_modified=1516785076-->
<DD>
openH264解码流程<BR>
<BR>
之前项目中用过openH264进行解码，本文介绍一下解码流程，算是对之前项目的一个总结。<BR>
<BR>
同openH264编码一样，openH264的解码流程也主要分为3步： <BR>
1：创建解码器。<BR>
int result = WelsCreateDecoder(&amp;decoder);<BR>
<BR>
同样可以通过判断返回值来判断解码器是否创建成功。 <BR>
2：初始化解码器。<BR>
memset (&amp;pParam, 0, sizeof (SDecodingParam));<BR>
pParam.uiTargetDqLayer = UCHAR_MAX;<BR>
pParam.eEcActiveIdc = ERROR_CON_FRAME_COPY_CROSS_IDR;<BR>
pParam.sVideoProperty.eVideoBsType = VIDEO_BITSTREAM_DEFAULT;<BR>
result = decoder-&gt;Initialize(&amp;pParam);<BR>
<BR>
3：调用解码器开始解码。<BR>
<BR>
int stride[2] = {videoWidth, videoWidth/2};<BR>
uint8_t* dst[3];<BR>
memset (dst, 0, sizeof (dst));<BR>
int result = decoder-&gt;DecodeFrame((const unsigned char*)src, length, dst, stride, videoWidth, videoHeight);<BR>
<BR>
解码后的数据存储在dst中，格式为YUV420P，如果需要其他格式的话，要进行格式转换。<BR>
<BR>
<BR>
YUV420P转RGB32<BR>
从网络摄像机中获取的帧数据是YUV420P格式的，而我们处理图像需要RGB格式，在网上找了一段将YUV420P格式的帧转换为RGB的代码。<BR>
<BR>
&lt;方法一&gt; 直接计算，效率低<BR>
[cpp] view plaincopy<BR>
// 转换 YV12 到 RGB24  <BR>
// pYUV 的大小 (3 * iWidth * iHeight / 2)  <BR>
// pRGB 的大小 (3 * iWidth * iHeight)  <BR>
// 如果成功返回 true, 否则 false  <BR>
bool YV12_to_RGB24(unsigned char* pYV12, unsigned char* pRGB24, int iWidth, int iHeight)  <BR>
{  <BR>
if(!pYV12 || !pRGB24)  <BR>
return false;  <BR>
  <BR>
const long nYLen = long(iHeight * iWidth);  <BR>
const int nHfWidth = (iWidth&gt;&gt;1);  <BR>
  <BR>
if(nYLen&lt;1 || nHfWidth&lt;1)   <BR>
return false;  <BR>
  <BR>
// yv12数据格式，其中Y分量长度为width * height, U和V分量长度都为width * height / 4  <BR>
// |WIDTH |  <BR>
// y......y--------  <BR>
// y......y HEIGHT  <BR>
// y......y  <BR>
// y......y--------  <BR>
// v..v  <BR>
// v..v  <BR>
// u..u  <BR>
// u..u  <BR>
unsigned char* yData = pYV12;  <BR>
unsigned char* vData = &amp;yData[nYLen];  <BR>
unsigned char* uData = &amp;vData[nYLen&gt;&gt;2];  <BR>
  <BR>
if(!uData || !vData)  <BR>
return false;  <BR>
  <BR>
// Convert YV12 to RGB24  <BR>
//   <BR>
// formula  <BR>
// [1 1 1 ]  <BR>
// [r g b] = [y u-128 v-128] [0 0.34375 0 ]  <BR>
// [1.375 0.703125 1.734375]  <BR>
// another formula  <BR>
// [1 1 1 ]  <BR>
// [r g b] = [y u-128 v-128] [0 0.698001 0 ]  <BR>
// [1.370705 0.703125 1.732446]  <BR>
int rgb[3];  <BR>
int i, j, m, n, x, y;  <BR>
m = -iWidth;  <BR>
n = -nHfWidth;  <BR>
for(y=0; y &lt; iHeight; y++)  <BR>
{  <BR>
m += iWidth;  <BR>
if(!(y % 2))  <BR>
n += nHfWidth;  <BR>
for(x=0; x &lt; iWidth; x++)  <BR>
{  <BR>
i = m + x;  <BR>
j = n + (x&gt;&gt;1);  <BR>
rgb[2] = int(yData[i] + 1.370705 * (vData[j] - 128)); // r分量值  <BR>
rgb[1] = int(yData[i] - 0.698001 * (uData[j] - 128) - 0.703125 * (vData[j] - 128)); // g分量值  <BR>
rgb[0] = int(yData[i] + 1.732446 * (uData[j] - 128)); // b分量值  <BR>
  <BR>
j = nYLen - iWidth - m + x;  <BR>
i = (j&lt;&lt;1) + j;  <BR>
for(j=0; j&lt;3; j++)  <BR>
{  <BR>
if(rgb[j]&gt;=0 &amp;&amp; rgb[j]&lt;=255)  <BR>
pRGB24[i + j] = rgb[j];  <BR>
else  <BR>
pRGB24[i + j] = (rgb[j] &lt; 0) ? 0 : 255;  <BR>
}  <BR>
}  <BR>
}  <BR>
return true;  <BR>
}  <BR>
<BR>
在利用OpenCV进行处理时，如果直接将转换好的数据赋给IplImage-&gt;imageData，会出现红蓝通道对调的情况，因为OpenCV中默认使用的是BGR的排列方式。<BR>
将代码中的给rgb复制的一段稍微改一下就行，改为：<BR>
[cpp] view plaincopy<BR>
rgb[0] = int(yData[i] + 1.370705 * (vData[j] - 128)); // r分量值  <BR>
rgb[1] = int(yData[i] - 0.698001 * (uData[j] - 128) - 0.703125 * (vData[j] - 128)); // g分量值  <BR>
rgb[2] = int(yData[i] + 1.732446 * (uData[j] - 128)); // b分量值  <BR>
<BR>
<BR>
&lt;方法二&gt;查表，效率高<BR>
[cpp] view plaincopy<BR>
#include   &lt;string&gt;   <BR>
#include   &lt;string.h&gt;   <BR>
using   namespace   std;   <BR>
  <BR>
static   long   int   crv_tab[256];   <BR>
static   long   int   cbu_tab[256];   <BR>
static   long   int   cgu_tab[256];   <BR>
static   long   int   cgv_tab[256];   <BR>
static   long   int   tab_76309[256];   <BR>
static   unsigned   char   clp[1024]; //for   clip   in   CCIR601   <BR>
  <BR>
  <BR>
void   InitConvtTbl();   <BR>
void   YUV2RGB420(unsigned   char   *src,   unsigned   char   *dst_ori,   <BR>
    int   width,int   height);   <BR>
  <BR>
/****************************************************/   <BR>
/* Sum   the   input */   <BR>
/* Input:   input,   len */   <BR>
/* Output:   input */   <BR>
/* Algorithm:   add */   <BR>
/****************************************************/   <BR>
void   InitConvtTbl()   <BR>
{   <BR>
    long   int   crv,cbu,cgu,cgv;   <BR>
    int   i,ind;         <BR>
  <BR>
    crv   =   104597;   cbu   =   132201;     /*   fra   matrise   i   global.h   */   <BR>
    cgu   =   25675;     cgv   =   53279;   <BR>
  <BR>
    for   (i   =   0;   i   &lt;   256;   i++)   {   <BR>
        crv_tab[i]   =   (i-128)   *   crv;   <BR>
        cbu_tab[i]   =   (i-128)   *   cbu;   <BR>
        cgu_tab[i]   =   (i-128)   *   cgu;   <BR>
        cgv_tab[i]   =   (i-128)   *   cgv;   <BR>
        tab_76309[i]   =   76309*(i-16);   <BR>
    }   <BR>
  <BR>
    for   (i=0;   i &lt;384;   i++)   <BR>
        clp[i]   =0;   <BR>
    ind=384;   <BR>
    for   (i=0;i &lt;256;   i++)   <BR>
        clp[ind++]=i;   <BR>
    ind=640;   <BR>
    for   (i=0;i &lt;384;i++)   <BR>
        clp[ind++]=255;   <BR>
}  <BR>
  <BR>
void   YUV2RGB420(unsigned   char   *src,   unsigned   char   *dst_ori,   <BR>
    int   width,int   height)   <BR>
{   <BR>
    unsigned   char   *src0;   <BR>
    unsigned   char   *src1;   <BR>
    unsigned   char   *src2;   <BR>
    int   y1,y2,u,v;     <BR>
    unsigned   char   *py1,*py2;   <BR>
    int   i,j,   c1,   c2,   c3,   c4;   <BR>
    unsigned   char   *d1,   *d2,   *d3;   <BR>
  <BR>
    //Initialization   <BR>
    src0=src;   <BR>
    src1=src+width*height;   <BR>
    src2=src+width*height+width*height/4;   <BR>
  <BR>
    py1=src0;   <BR>
    py2=py1+width;   <BR>
    d1=dst_ori + 3 * width * (height -1);   <BR>
    d2=d1-3*width;   <BR>
    for   (j   =   0;   j   &lt;   height;   j   +=   2)   {     <BR>
        for   (i   =   0;   i   &lt;   width;   i   +=   2)   {   <BR>
  <BR>
            u   =   *src1++;   <BR>
            v   =   *src2++;   <BR>
  <BR>
            c1   =   crv_tab[v];   <BR>
            c2   =   cgu_tab[u];   <BR>
            c3   =   cgv_tab[v];   <BR>
            c4   =   cbu_tab[u];   <BR>
  <BR>
            //up-left   <BR>
            y1   =   tab_76309[*py1++];   <BR>
            *d1++   =   clp[384+((y1   +   c4)&gt;&gt; 16)];       <BR>
            *d1++   =   clp[384+((y1   -   c2   -   c3)&gt;&gt; 16)];   <BR>
            *d1++   =   clp[384+((y1   +   c1)&gt;&gt; 16)];   <BR>
  <BR>
            //down-left   <BR>
            y2   =   tab_76309[*py2++];   <BR>
            *d2++   =   clp[384+((y2   +   c4)&gt;&gt; 16)];       <BR>
            *d2++   =   clp[384+((y2   -   c2   -   c3)&gt;&gt; 16)];   <BR>
            *d2++   =   clp[384+((y2   +   c1)&gt;&gt; 16)];   <BR>
  <BR>
            //up-right   <BR>
            y1   =   tab_76309[*py1++];   <BR>
            *d1++   =   clp[384+((y1   +   c4)&gt;&gt; 16)];       <BR>
            *d1++   =   clp[384+((y1   -   c2   -   c3)&gt;&gt; 16)];   <BR>
            *d1++   =   clp[384+((y1   +   c1)&gt;&gt; 16)];   <BR>
  <BR>
            //down-right   <BR>
            y2   =   tab_76309[*py2++];   <BR>
            *d2++   =   clp[384+((y2   +   c4)&gt;&gt; 16)];       <BR>
            *d2++   =   clp[384+((y2   -   c2   -   c3)&gt;&gt; 16)];   <BR>
            *d2++   =   clp[384+((y2   +   c1)&gt;&gt; 16)];   <BR>
        }   <BR>
        d1   -=   3*width * 3;   <BR>
        d2   -=   3*width * 3;   <BR>
        py1+=       width;   <BR>
        py2+=       width;   <BR>
    }                 <BR>
  <BR>
  <BR>
}   <BR>
<BR>
<BR>
<DL>
<DT>编译openh264</DT>
<!--property:date_created=1516931551-->
<!--property:date_modified=1516937295-->
<DD>
下载nasm<BR>
<BR>
设置环境变量<BR>
export PATH = &quot;$PATH:/D:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin:/D:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\IDE&quot;<BR>
export INCLUDE=&quot;D:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\include;C:\Program Files (x86)\Windows Kits\8.0\Include\um;C:\Program Files (x86)\Windows Kits\8.0\Include\shared&quot;<BR>
export LIB=&quot;C:\Program Files (x86)\Windows Kits\8.0\Lib\Win8\um\x64;D:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\lib\amd64&quot;<BR>
<BR>
Windows 下用 VS2015+MSYS 一键编译 OpenH264<BR>
前提条件:<BR>
1、你已经安装好了VS2015；<BR>
2、你已经安装好了MSYS；<BR>
3、你已经从 从github上下载了OpenH264 源码；https://github.com/cisco/openh264.git<BR>
在源代码目录下建立BAT文件，build.bat，内容如下：<BR>
call &quot;D:\Language\VS2015\VC\bin\vcvars32.bat&quot; set MSYS=D:\Language\MinGW32\msys\1.0\bin PATH=%MSYS%;%path% set INCLUDE=%INCLUDE% set LIB=%lib%  bash -c &quot;make OS=msvc&quot; pause<BR>
<BR>
<BR>
    common.lib<BR>
    console_common.lib<BR>
    decoder.lib<BR>
    encoder.lib<BR>
    openh264.lib<BR>
    openh264_dll.lib<BR>
    processing.lib<BR>
   Openh264.dll<BR>
    h264dec.exe<BR>
    h264enc.exe<BR>

</DD>
</DL>

</DD>
<DT>H264解码比较</DT>
<!--property:date_created=1516930365-->
<!--property:date_modified=1516930426-->
<DD>
JM86 decoder: vc71 release<BR>
T264 decoder: vc71 release<BR>
x264 decodeer: vc71 release<BR>
ffmpeg libavcodec: MinGW<BR>
Intel IPP simple player: vc71 release + directX 9.0c sdk<BR>
<BR>
<BR>
http://blog.csdn.net/xy365/article/details/8424600<BR>
排名分先后。<BR>
一、ffmpeg<BR>
    ffmpeg属于GPL或者LGPL，确切属于哪一种，要根据编译选项，因为它里面的库有些属于GPL的有些属于LGPL的，你编译的时候打开或者关闭这些库的选项，就决定了它属于哪一种。<BR>
http://www.ffmpeg.org/legal.html<BR>
ffmpeg项目由以下几部分组成:<BR>
ffmpeg 视频文件转换命令行工具,也支持经过实时电视卡抓取和编码成视频文件.<BR>
ffserver 基于HTTP(RTSP正在开发中)用于实时广播的多媒体服务器.也支持时间平移<BR>
ffplay 用 SDL和FFmpeg库开发的一个简单的媒体播放器<BR>
libavcodec 一个包含了所有FFmpeg音视频编解码器的库.为了保证最优性能和高可复用性,大多数编解码器从头开发的.<BR>
libavformat 一个包含了所有的普通音视格式的解析器和产生器的库.<BR>
 <BR>
二、Xvid<BR>
     Xvid（旧称为XviD）是一个开放源代码的MPEG-4视频编解码器，它是基于OpenDivX而编写的。官方网站：www.xvid.org<BR>
 <BR>
三、X264<BR>
    X264是一种免费的、具有更优秀算法的符合H.264/MPEG-4 AVC视频压缩编码标准格式的编码库。x264压缩出的视频文件在相同质量下要比xvid压缩出的文件要小，或者也可以说，在相同体积下比xvid压缩出的文件质量要好。它符合GPL（General Public License，是一份GNU通用公共授权）许可证。X264属于videolan开源工程的一部分。http://www.videolan.org/developers/x264.html<BR>
　　采用CAVLC/CABAC多种算法编码<BR>
　　内置所有macroblock格式（16x16, 8x8, and 4x4 ）<BR>
　　Inter P：所有的分割块（从16x16到4x4 ）<BR>
　　Inter B：分割块从16x16到8x8<BR>
　　码率控制：恒定的分层编制，单次或多次的ABR压制，可选的VBV压制<BR>
　　场景剪切侦测<BR>
　　支持B-frame<BR>
　　能够任意编制B-frame命令行<BR>
　　无损模式<BR>
　　8x8和4x4的格式能够进行翻转或旋转<BR>
　　自定义精确的矩阵模板<BR>
　　可在多个CPU平行编码<BR>
　　隔行扫描<BR>
 <BR>
    X264只提供编码，不提供解码。 解码部分需要FFMPEG完成；XVID有编解码部分，其中解码亦可以利用FFMPEG中的MPEG4完成解码。<BR>
 <BR>
四、ffdshow<BR>
    ffdshow是对一些codec（ffmpeg, xvid， and other）的封装，封装成了DirectShow和VFW的标准组件。该库（软件）只能在windows平台运行，是属于GPL<BR>
比如对于xvid来讲，ffdshow是可以选择具体使用那个codec的，ffmpeg(libavcodec) or xvid。那么封装有没有额外的成本哪？有，但对大部分应用来讲，可以忽略不计。就如c++和c。<BR>
vfw和dshow里的CODEC分别是通过fourcc码和guid机制寻找的,可以在系统注册codec后调用,比自带编解码库形式更加统一,便于使用。此外，vfw和dshow是代表了两个微软不同时期的音视频处理封装库，里面包含了音视频驱动，音视频处理的一整套方案。<BR>
    DirectShow是微软公司在ActiveMovie和Video for Windows的基础上推出的新一代基于COM的流媒体处理的开发包，与DirectX开发包一起发布。目前，DirectX最新版本为9.0。 DirectShow为多媒体流的捕捉和回放提供了强有力的支持。运用DirectShow，我们可以很方便地从支持WDM驱动模型的采集卡上捕获数据， 并且进行相应的后期处理乃至存储到文件中。这样使在多媒体数据库管理系统（MDBMS）中多媒体数据的存取变得更加方便。DirectShow是微软公司 提供的一套在Windows平台上进行流媒体处理的开发包，与DirectX开发包一起发布。运用DirectShow，我们可以很方便地从支持WDM驱动模型的采集卡上捕获数据，并且进行相应的后期处理乃至存储到文件中。它广泛地支持各种媒体格 式，包括Asf、Mpeg、Avi、Dv、Mp3、Wave等等，使得多媒体数据的回放变得轻而易举。另外，DirectShow还集成了DirectX 其它部分（比如DirectDraw、DirectSound）的技术，直接支持DVD的播放，视频的非线性编辑，以及与数字摄像机的数据交换。<BR>
    vfw（Video For Windows）<BR>
 <BR>
五、CoreAVC<BR>
     CoreCodec的CoreAVC高清H.264视频解码器是基于已经被用于AVCHD、蓝光光盘和HD-DVD中的MPEG-4 Part 10标准构建的。H.264是下一代的视频编码标准，而CoreAVC?是目前公认世界上最快的H.264软解码器。
</DD>
<DT>解码视频流</DT>
<!--property:date_created=1516960692-->
<!--property:date_modified=1516960712-->
<DD>
	<BR>
	初始化<BR>
	{<BR>
	avcodec_register_all();<BR>
		av_register_all();<BR>
	AVCodecID avCodec;<BR>
		switch(pvs-&gt;m_nCodec)<BR>
		{<BR>
		case VE_CODEC_ID_H264:<BR>
			avCodec = AV_CODEC_ID_H264;<BR>
			break;<BR>
		case VE_CODEC_ID_MPEG4:<BR>
			avCodec = AV_CODEC_ID_MPEG4;<BR>
			break;<BR>
		case VE_CODEC_ID_MJPEG:<BR>
			avCodec = AV_CODEC_ID_MJPEG;<BR>
			break;<BR>
		default:<BR>
			avCodec = (AVCodecID)pvs-&gt;m_nCodec;<BR>
			break;<BR>
		}<BR>
		pvs-&gt;codec = avcodec_find_decoder(avCodec);<BR>
		pvs-&gt;context = avcodec_alloc_context3(pvs-&gt;codec);<BR>
		pvs-&gt;frame = av_frame_alloc();<BR>
		av_init_packet(&amp;pvs-&gt;m_avPkt);<BR>
		pvs-&gt;m_nCodecInitialed = 1;<BR>
		avcodec_open2(pvs-&gt;context, pvs-&gt;codec,NULL);<BR>
	}<BR>
	memcpy(pvs-&gt;buffer_stream+pvs-&gt;buffer_pos,buff,size);<BR>
	pvs-&gt;buffer_pos+=size;<BR>
	<BR>
	pvs-&gt;m_avPkt.data = (unsigned char*)pvs-&gt;buffer_stream + pvs-&gt;total_decode_len;<BR>
	pvs-&gt;m_avPkt.size = pvs-&gt;buffer_pos;<BR>
	<BR>
	decode_len = avcodec_decode_video2(pvs-&gt;context, pvs-&gt;frame, &amp;got_picture, &amp;pvs-&gt;m_avPkt);<BR>
	<BR>
	if(decode_len &lt; 0 &amp;&amp; (pvs-&gt;first_frame))<BR>
		{<BR>
			pvs-&gt;buffer_pos = 0;<BR>
			pvs-&gt;first_frame = false;<BR>
		}<BR>
		else if(decode_len &gt; 0)<BR>
		{<BR>
			if(pvs-&gt;m_pfnOnStreamReady != NULL)<BR>
				pvs-&gt;m_pfnOnStreamReady(pvs-&gt;m_pUserData,pvs-&gt;buffer_stream+pvs-&gt;total_decode_len,decode_len,pvs-&gt;frame-&gt;key_frame==1?1:3);<BR>
			//fwrite(pvs-&gt;buffer_stream+pvs-&gt;total_decode_len,decode_len,1,fp);<BR>
<BR>
			pvs-&gt;buffer_pos -= decode_len;<BR>
			pvs-&gt;total_decode_len += decode_len;<BR>
			pvs-&gt;m_avPkt.data = (unsigned char*)pvs-&gt;buffer_stream + pvs-&gt;total_decode_len + decode_len;<BR>
			pvs-&gt;m_avPkt.size -= decode_len;<BR>
		}<BR>
<BR>
		if(got_picture)<BR>
		{<BR>
			if(pvs-&gt;frame_rgb == NULL)<BR>
			{<BR>
				pvs-&gt;frame_rgb = av_frame_alloc();<BR>
				int bytes = avpicture_get_size(AV_PIX_FMT_RGB24, pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;height);<BR>
				pvs-&gt;buffer_rgb=(uint8_t *)av_malloc(bytes);<BR>
				avpicture_fill((AVPicture *)pvs-&gt;frame_rgb, pvs-&gt;buffer_rgb, AV_PIX_FMT_RGB24,pvs-&gt;context-&gt;width, pvs-&gt;context-&gt;height);<BR>
			}<BR>
<BR>
			SwsContext *img_convert_ctx = sws_getContext(pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;height,<BR>
				pvs-&gt;context-&gt;pix_fmt,<BR>
				pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;height,<BR>
				AV_PIX_FMT_BGR24,<BR>
				SWS_FAST_BILINEAR, NULL, NULL, NULL);<BR>
<BR>
			sws_scale(img_convert_ctx, pvs-&gt;frame-&gt;data, <BR>
				pvs-&gt;frame-&gt;linesize, 0, pvs-&gt;context-&gt;height, <BR>
				pvs-&gt;frame_rgb-&gt;data, pvs-&gt;frame_rgb-&gt;linesize);<BR>
<BR>
			sws_freeContext(img_convert_ctx);<BR>
<BR>
			if(pvs-&gt;m_pfnOnRealRGBReady != NULL)<BR>
				pvs-&gt;m_pfnOnRealRGBReady(pvs-&gt;m_pUserData,pvs-&gt;buffer_rgb,pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;width*3,pvs-&gt;context-&gt;height);<BR>
		}<DL>
<DT>解码H264TORGBYUV</DT>
<!--property:date_created=1517277457-->
<!--property:date_modified=1517286152-->
<DD>
FMpeg对视频文件进行解码的大致流程<BR>
<BR>
1. 注册所有容器格式: av_register_all()<BR>
2. 打开文件: av_open_input_file()<BR>
3. 从文件中提取流信息: av_find_stream_info()<BR>
4. 穷举所有的流，查找其中种类为CODEC_TYPE_VIDEO<BR>
5. 查找对应的解码器: avcodec_find_decoder()<BR>
6. 打开编解码器: avcodec_open()<BR>
7. 为解码帧分配内存: avcodec_alloc_frame()<BR>
8. 不停地从码流中提取出帧数据: av_read_frame()<BR>
9. 判断帧的类型，对于视频帧调用: avcodec_decode_video()<BR>
10. 解码完后，释放解码器: avcodec_close()<BR>
11. 关闭输入文件:av_close_input_file()<BR>
<BR>
//添加的库:avcodec.lib avdevice.lib avfilter.lib avformat.lib avutil.lib swscale.lib   SDL.lib <BR>
extern &quot;C&quot;<BR>
{<BR>
	#include &lt;libavcodec/avcodec.h&gt;<BR>
	#include &lt;libavformat/avformat.h&gt;<BR>
	#include &lt;libswscale/swscale.h&gt;<BR>
<BR>
<BR>
	#include &lt;libsdl/SDL.h&gt;<BR>
	#include &lt;libsdl/SDL_thread.h&gt;<BR>
};<BR>
<BR>
<BR>
void SaveFrame(AVFrame *pFrame, int width, int height, int iFrame) <BR>
{<BR>
	FILE *pFile;<BR>
	char szFilename[32];<BR>
	int  y;<BR>
	<BR>
	// Open file<BR>
	sprintf(szFilename, &quot;frame%d.ppm&quot;, iFrame);<BR>
	pFile=fopen(szFilename, &quot;wb&quot;);<BR>
	if(pFile==NULL)<BR>
		return;<BR>
	<BR>
	// Write header<BR>
	fprintf(pFile, &quot;P6\n%d %d\n255\n&quot;, width, height);<BR>
	<BR>
	// Write pixel data<BR>
	for(y=0; y&lt;height; y++)<BR>
		fwrite(pFrame-&gt;data[0]+y*pFrame-&gt;linesize[0], 1, width*3, pFile);<BR>
	<BR>
	// Close file<BR>
	fclose(pFile);<BR>
}<BR>
<BR>
<BR>
<b><span style="background-color:#e04848">//H264转RGB32<BR>
void CTest0Dlg::OnButton1() </span></b><BR>
{<BR>
	// TODO: Add your control notification handler code here<BR>
	  AVFormatContext *pFormatCtx;<BR>
  int             i, videoStream;<BR>
  AVCodecContext  *pCodecCtx;<BR>
  AVCodec         *pCodec;<BR>
  AVFrame         *pFrame; <BR>
  AVFrame         *pFrameRGB;<BR>
  AVPacket        packet;<BR>
  int             frameFinished;<BR>
  int             numBytes;<BR>
  uint8_t         *buffer;<BR>
  static int sws_flags = SWS_BICUBIC;<BR>
  struct SwsContext *img_convert_ctx;<BR>
   AVPicture pict;  <BR>
//  argc = 2;<BR>
  char argv[100] = &quot;d:\\temp\\VIDEO720576.264&quot;;<BR>
 // argv[1] = &quot;d:\\temp\\ff.mpg&quot;;<BR>
 <BR>
  // /*注册所有可用的格式和编解码器*/<BR>
  av_register_all();<BR>
  <BR>
  // Open video file /*以输入方式打开一个媒体文件,也即源文件,codecs并没有打开,只读取了文件的头信息*/<BR>
  if(av_open_input_file(&amp;pFormatCtx, argv, NULL, 0, NULL)!=0)<BR>
    return ; // Couldn't open file<BR>
  <BR>
  // Retrieve stream information<BR>
/*通过读取媒体文件的中的包来获取媒体文件中的流信息,对于没有头信息的文件如(mpeg)是非常有用的,<BR>
// 该函数通常重算类似mpeg-2帧模式的真实帧率,该函数并未改变逻辑文件的position.<BR>
*/<BR>
  if(av_find_stream_info(pFormatCtx)&lt;0)<BR>
    return ; // Couldn't find stream information<BR>
  <BR>
  // Dump information about file onto standard error<BR>
//该函数的作用就是检查下初始化过程中设置的参数是否符合规范<BR>
  dump_format(pFormatCtx, 0, argv, 0);<BR>
  <BR>
  // Find the first video stream<BR>
  videoStream=-1;<BR>
  printf(&quot;%d\n&quot;,pFormatCtx-&gt;nb_streams);<BR>
  getchar();<BR>
  for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++)<BR>
    if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==CODEC_TYPE_VIDEO&amp;&amp;videoStream &lt; 0)<BR>
 {<BR>
      videoStream=i;<BR>
      break;<BR>
    }<BR>
  if(videoStream==-1)<BR>
    return ; // Didn't find a video stream<BR>
  <BR>
  // Get a pointer to the codec context for the video stream<BR>
  pCodecCtx=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<BR>
  <BR>
  // Find the decoder for the video stream<BR>
  pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id);<BR>
/*通过code ID查找一个已经注册的音视频编码器,查找编码器之前,必须先调用av_register_all注册所有支持的编码器<BR>
音视频编码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较编码器的ID来查找<BR>
*/<BR>
  if(pCodec==NULL) {<BR>
    fprintf(stderr, &quot;Unsupported codec!\n&quot;);<BR>
    return ; // Codec not found<BR>
  }<BR>
  // Open codec<BR>
//使用给定的AVCodec初始化AVCodecContext<BR>
<BR>
<BR>
  if(avcodec_open(pCodecCtx, pCodec)&lt;0)<BR>
    return ; // Could not open codec<BR>
<BR>
<BR>
  //printf(&quot;name %s\n&quot;,pCodec-&gt;name);<BR>
  //getchar();<BR>
<BR>
<BR>
  // Allocate video frame<BR>
  pFrame=avcodec_alloc_frame();<BR>
  <BR>
  // Allocate an AVFrame structure<BR>
  pFrameRGB=avcodec_alloc_frame();<BR>
  if(pFrameRGB==NULL)<BR>
    return ;<BR>
  <BR>
  // Determine required buffer size and allocate buffer<BR>
  numBytes=avpicture_get_size(PIX_FMT_RGB32, pCodecCtx-&gt;width,<BR>
         pCodecCtx-&gt;height);<BR>
  buffer=(uint8_t *)av_malloc(numBytes*sizeof(uint8_t));<BR>
  <BR>
  // Assign appropriate parts of buffer to image planes in pFrameRGB<BR>
  // Note that pFrameRGB is an AVFrame, but AVFrame is a superset<BR>
  // of AVPicture<BR>
  avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB32,<BR>
   pCodecCtx-&gt;width, pCodecCtx-&gt;height);<BR>
  <BR>
  // Read frames and save first five frames to disk<BR>
  i=0;<BR>
  ////////////////////////////////////////////////////////////////<BR>
  if (SDL_Init(SDL_INIT_VIDEO) &lt; 0)<BR>
  {<BR>
	  fprintf(stderr, &quot;can not initialize SDL:%s\n&quot;, SDL_GetError());<BR>
	  exit(1);<BR>
   }<BR>
  atexit(SDL_Quit);<BR>
  SDL_Surface *screen;<BR>
  screen = SDL_SetVideoMode(720, 576, 32, SDL_SWSURFACE|SDL_ANYFORMAT);<BR>
  if ( screen == NULL ) <BR>
  {<BR>
	  exit(2);<BR>
  }<BR>
  	SDL_Surface *image;<BR>
<BR>
<BR>
    Uint32 rmask, gmask, bmask, amask;<BR>
<BR>
<BR>
    /* SDL interprets each pixel as a 32-bit number, so our masks must depend<BR>
       on the endianness (byte order) of the machine */<BR>
#if 0//SDL_BYTEORDER == SDL_BIG_ENDIAN<BR>
    rmask = 0xff000000;<BR>
    gmask = 0x00ff0000;<BR>
    bmask = 0x0000ff00;<BR>
    amask = 0x000000ff;<BR>
#else<BR>
    rmask = 0x000000ff;<BR>
    gmask = 0x0000ff00;<BR>
    bmask = 0x00ff0000;<BR>
    amask = 0xff000000;<BR>
#endif<BR>
<BR>
<BR>
	image = SDL_CreateRGBSurface(SDL_SWSURFACE, 720, 576, 0,<BR>
		rmask, gmask, bmask, NULL);<BR>
    if(image == NULL) <BR>
	{<BR>
        //fprintf(stderr, &quot;CreateRGBSurface failed: %s\n&quot;, SDL_GetError());<BR>
        exit(1);<BR>
    }<BR>
  //////////////////////////////////////////////////////////////////<BR>
  while(av_read_frame(pFormatCtx, &amp;packet)&gt;=0) <BR>
  {<BR>
    // Is this a packet from the video stream?<BR>
    if(packet.stream_index==videoStream) <BR>
 {<BR>
    // Decode video frame<BR>
    avcodec_decode_video(pCodecCtx, pFrame, &amp;frameFinished, <BR>
       packet.data, packet.size);<BR>
      <BR>
    // Did we get a video frame?<BR>
    if(frameFinished) <BR>
    {<BR>
  // Convert the image from its native format to RGB<BR>
<BR>
<BR>
<BR>
<BR>
        img_convert_ctx = sws_getContext( pCodecCtx-&gt;width, <BR>
               pCodecCtx-&gt;height,<BR>
               pCodecCtx-&gt;pix_fmt,<BR>
               pCodecCtx-&gt;width, <BR>
               pCodecCtx-&gt;height,<BR>
               PIX_FMT_RGB32,<BR>
               sws_flags, NULL, NULL, NULL);<BR>
        		sws_scale(img_convert_ctx,pFrame-&gt;data,pFrame-&gt;linesize,0,pCodecCtx-&gt;height,pFrameRGB-&gt;data,pFrameRGB-&gt;linesize);  <BR>
        sws_freeContext(img_convert_ctx);<BR>
     ////////////////////////////////////////////////////////////////<BR>
		memcpy(screen-&gt;pixels,buffer,720*576*4);<BR>
		<BR>
		SDL_UpdateRect(screen, 0, 0, image-&gt;w, image-&gt;h);<BR>
		<BR>
		/* Free the allocated BMP surface */<BR>
    SDL_FreeSurface(image);<BR>
		/////////////////////////////////////////////////////////////////<BR>
     // Save the frame to disk<BR>
     if((++i&lt;=5))<BR>
       SaveFrame(pFrameRGB, pCodecCtx-&gt;width, pCodecCtx-&gt;height, i);<BR>
    }<BR>
}<BR>
    <BR>
    // Free the packet that was allocated by av_read_frame<BR>
    av_free_packet(&amp;packet);<BR>
  }<BR>
  <BR>
  // Free the RGB image<BR>
  av_free(buffer);<BR>
  av_free(pFrameRGB);<BR>
  <BR>
  // Free the YUV frame<BR>
  av_free(pFrame);<BR>
  <BR>
  // Close the codec<BR>
  avcodec_close(pCodecCtx);<BR>
  <BR>
  // Close the video file<BR>
  av_close_input_file(pFormatCtx);<BR>
  MessageBox(&quot;over&quot;);<BR>
}<BR>
<BR>
<b><span style="background-color:#e42b2b">//解码RGB24<BR>
void CTest0Dlg::OnButton2() <BR>
{</span></b><BR>
	// TODO: Add your control notification handler code here<BR>
		  AVFormatContext *pFormatCtx;<BR>
  int             i, videoStream;<BR>
  AVCodecContext  *pCodecCtx;<BR>
  AVCodec         *pCodec;<BR>
  AVFrame         *pFrame; <BR>
  AVFrame         *pFrameRGB;<BR>
  AVPacket        packet;<BR>
  int             frameFinished;<BR>
  int             numBytes;<BR>
  uint8_t         *buffer;<BR>
  static int sws_flags = SWS_BICUBIC;<BR>
  struct SwsContext *img_convert_ctx;<BR>
   AVPicture pict;  <BR>
//  argc = 2;<BR>
  char argv[100] = &quot;d:\\temp\\VIDEO720576.264&quot;;<BR>
 // argv[1] = &quot;d:\\temp\\ff.mpg&quot;;<BR>
 <BR>
  // /*注册所有可用的格式和编解码器*/<BR>
  av_register_all();<BR>
  <BR>
  // Open video file /*以输入方式打开一个媒体文件,也即源文件,codecs并没有打开,只读取了文件的头信息*/<BR>
  if(av_open_input_file(&amp;pFormatCtx, argv, NULL, 0, NULL)!=0)<BR>
    return ; // Couldn't open file<BR>
  <BR>
  // Retrieve stream information<BR>
/*通过读取媒体文件的中的包来获取媒体文件中的流信息,对于没有头信息的文件如(mpeg)是非常有用的,<BR>
// 该函数通常重算类似mpeg-2帧模式的真实帧率,该函数并未改变逻辑文件的position.<BR>
*/<BR>
  if(av_find_stream_info(pFormatCtx)&lt;0)<BR>
    return ; // Couldn't find stream information<BR>
  <BR>
  // Dump information about file onto standard error<BR>
//该函数的作用就是检查下初始化过程中设置的参数是否符合规范<BR>
  dump_format(pFormatCtx, 0, argv, 0);<BR>
  <BR>
  // Find the first video stream<BR>
  videoStream=-1;<BR>
  printf(&quot;%d\n&quot;,pFormatCtx-&gt;nb_streams);<BR>
  getchar();<BR>
  for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++)<BR>
    if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==CODEC_TYPE_VIDEO&amp;&amp;videoStream &lt; 0)<BR>
 {<BR>
      videoStream=i;<BR>
      break;<BR>
    }<BR>
  if(videoStream==-1)<BR>
    return ; // Didn't find a video stream<BR>
  <BR>
  // Get a pointer to the codec context for the video stream<BR>
  pCodecCtx=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<BR>
  <BR>
  // Find the decoder for the video stream<BR>
  pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id);<BR>
/*通过code ID查找一个已经注册的音视频编码器,查找编码器之前,必须先调用av_register_all注册所有支持的编码器<BR>
音视频编码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较编码器的ID来查找<BR>
*/<BR>
  if(pCodec==NULL) {<BR>
    fprintf(stderr, &quot;Unsupported codec!\n&quot;);<BR>
    return ; // Codec not found<BR>
  }<BR>
  // Open codec<BR>
//使用给定的AVCodec初始化AVCodecContext<BR>
<BR>
<BR>
  if(avcodec_open(pCodecCtx, pCodec)&lt;0)<BR>
    return ; // Could not open codec<BR>
<BR>
<BR>
  //printf(&quot;name %s\n&quot;,pCodec-&gt;name);<BR>
  //getchar();<BR>
<BR>
<BR>
  // Allocate video frame<BR>
  pFrame=avcodec_alloc_frame();<BR>
  <BR>
  // Allocate an AVFrame structure<BR>
  pFrameRGB=avcodec_alloc_frame();<BR>
  if(pFrameRGB==NULL)<BR>
    return ;<BR>
  <BR>
  // Determine required buffer size and allocate buffer<BR>
  numBytes=avpicture_get_size(PIX_FMT_RGB24, pCodecCtx-&gt;width,<BR>
         pCodecCtx-&gt;height);<BR>
  buffer=(uint8_t *)av_malloc(numBytes*sizeof(uint8_t));<BR>
  <BR>
  // Assign appropriate parts of buffer to image planes in pFrameRGB<BR>
  // Note that pFrameRGB is an AVFrame, but AVFrame is a superset<BR>
  // of AVPicture<BR>
  avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,<BR>
   pCodecCtx-&gt;width, pCodecCtx-&gt;height);<BR>
  <BR>
  // Read frames and save first five frames to disk<BR>
  i=0;<BR>
  ////////////////////////////////////////////////////////////////<BR>
  if (SDL_Init(SDL_INIT_VIDEO) &lt; 0)<BR>
  {<BR>
	  fprintf(stderr, &quot;can not initialize SDL:%s\n&quot;, SDL_GetError());<BR>
	  exit(1);<BR>
   }<BR>
  atexit(SDL_Quit);<BR>
  SDL_Surface *screen;<BR>
  screen = SDL_SetVideoMode(720, 576, 24, SDL_SWSURFACE|SDL_ANYFORMAT);<BR>
  if ( screen == NULL ) <BR>
  {<BR>
	  exit(2);<BR>
  }<BR>
  	SDL_Surface *image;<BR>
<BR>
<BR>
    Uint32 rmask, gmask, bmask, amask;<BR>
<BR>
<BR>
    /* SDL interprets each pixel as a 32-bit number, so our masks must depend<BR>
       on the endianness (byte order) of the machine */<BR>
#if 0//SDL_BYTEORDER == SDL_BIG_ENDIAN<BR>
    rmask = 0xff000000;<BR>
    gmask = 0x00ff0000;<BR>
    bmask = 0x0000ff00;<BR>
    amask = 0x000000ff;<BR>
#else<BR>
    rmask = 0x000000ff;<BR>
    gmask = 0x0000ff00;<BR>
    bmask = 0x00ff0000;<BR>
    amask = 0xff000000;<BR>
#endif<BR>
<BR>
<BR>
	image = SDL_CreateRGBSurface(SDL_SWSURFACE, 720, 576, 0,<BR>
		rmask, gmask, bmask, NULL);<BR>
    if(image == NULL) <BR>
	{<BR>
        //fprintf(stderr, &quot;CreateRGBSurface failed: %s\n&quot;, SDL_GetError());<BR>
        exit(1);<BR>
    }<BR>
  //////////////////////////////////////////////////////////////////<BR>
  while(av_read_frame(pFormatCtx, &amp;packet)&gt;=0) <BR>
  {<BR>
    // Is this a packet from the video stream?<BR>
    if(packet.stream_index==videoStream) <BR>
 {<BR>
    // Decode video frame<BR>
    avcodec_decode_video(pCodecCtx, pFrame, &amp;frameFinished, <BR>
       packet.data, packet.size);<BR>
      <BR>
    // Did we get a video frame?<BR>
    if(frameFinished) <BR>
    {<BR>
  // Convert the image from its native format to RGB<BR>
<BR>
<BR>
<BR>
<BR>
        img_convert_ctx = sws_getContext( pCodecCtx-&gt;width, <BR>
               pCodecCtx-&gt;height,<BR>
               pCodecCtx-&gt;pix_fmt,<BR>
               pCodecCtx-&gt;width, <BR>
               pCodecCtx-&gt;height,<BR>
               PIX_FMT_BGR24,<BR>
               sws_flags, NULL, NULL, NULL);<BR>
        		sws_scale(img_convert_ctx,pFrame-&gt;data,pFrame-&gt;linesize,0,pCodecCtx-&gt;height,pFrameRGB-&gt;data,pFrameRGB-&gt;linesize);  <BR>
        sws_freeContext(img_convert_ctx);<BR>
     ////////////////////////////////////////////////////////////////<BR>
		memcpy(screen-&gt;pixels,buffer,720*576*3);<BR>
		<BR>
		SDL_UpdateRect(screen, 0, 0, image-&gt;w, image-&gt;h);<BR>
		<BR>
		/* Free the allocated BMP surface */<BR>
    SDL_FreeSurface(image);<BR>
		/////////////////////////////////////////////////////////////////<BR>
     // Save the frame to disk<BR>
     if((++i&lt;=5))<BR>
       SaveFrame(pFrameRGB, pCodecCtx-&gt;width, pCodecCtx-&gt;height, i);<BR>
    }<BR>
}<BR>
    <BR>
    // Free the packet that was allocated by av_read_frame<BR>
    av_free_packet(&amp;packet);<BR>
  }<BR>
  <BR>
  // Free the RGB image<BR>
  av_free(buffer);<BR>
  av_free(pFrameRGB);<BR>
  <BR>
  // Free the YUV frame<BR>
  av_free(pFrame);<BR>
  <BR>
  // Close the codec<BR>
  avcodec_close(pCodecCtx);<BR>
  <BR>
  // Close the video file<BR>
  av_close_input_file(pFormatCtx);<BR>
  MessageBox(&quot;over&quot;);<BR>
}<BR>
<BR>
//解码YUV420P<BR>
<span style="background-color:#e42b2b">void CTest0Dlg::OnButton3() </span><BR>
{<BR>
	// TODO: Add your control notification handler code here<BR>
		// TODO: Add your control notification handler code here<BR>
		  AVFormatContext *pFormatCtx;<BR>
  int             i, videoStream;<BR>
  AVCodecContext  *pCodecCtx;<BR>
  AVCodec         *pCodec;<BR>
  AVFrame         *pFrame; <BR>
  AVFrame         *pFrameYUV;<BR>
  AVPacket        packet;<BR>
  int             frameFinished;<BR>
  int             numBytes;<BR>
  uint8_t         *buffer;<BR>
   SDL_Rect        rect;<BR>
  static int sws_flags = SWS_BICUBIC;<BR>
  struct SwsContext *img_convert_ctx;<BR>
   AVPicture pict;  <BR>
//  argc = 2;<BR>
  char argv[100] = &quot;d:\\temp\\VIDEO720576.264&quot;;<BR>
 // argv[1] = &quot;d:\\temp\\ff.mpg&quot;;<BR>
 <BR>
  // /*注册所有可用的格式和编解码器*/<BR>
  av_register_all();<BR>
  <BR>
  // Open video file /*以输入方式打开一个媒体文件,也即源文件,codecs并没有打开,只读取了文件的头信息*/<BR>
  if(av_open_input_file(&amp;pFormatCtx, argv, NULL, 0, NULL)!=0)<BR>
    return ; // Couldn't open file<BR>
  <BR>
  // Retrieve stream information<BR>
/*通过读取媒体文件的中的包来获取媒体文件中的流信息,对于没有头信息的文件如(mpeg)是非常有用的,<BR>
// 该函数通常重算类似mpeg-2帧模式的真实帧率,该函数并未改变逻辑文件的position.<BR>
*/<BR>
  if(av_find_stream_info(pFormatCtx)&lt;0)<BR>
    return ; // Couldn't find stream information<BR>
  <BR>
  // Dump information about file onto standard error<BR>
//该函数的作用就是检查下初始化过程中设置的参数是否符合规范<BR>
  dump_format(pFormatCtx, 0, argv, 0);<BR>
  <BR>
  // Find the first video stream<BR>
  videoStream=-1;<BR>
  printf(&quot;%d\n&quot;,pFormatCtx-&gt;nb_streams);<BR>
  getchar();<BR>
  for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++)<BR>
    if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==CODEC_TYPE_VIDEO&amp;&amp;videoStream &lt; 0)<BR>
 {<BR>
      videoStream=i;<BR>
      break;<BR>
    }<BR>
  if(videoStream==-1)<BR>
    return ; // Didn't find a video stream<BR>
  <BR>
  // Get a pointer to the codec context for the video stream<BR>
  pCodecCtx=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<BR>
  <BR>
  // Find the decoder for the video stream<BR>
  pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id);<BR>
/*通过code ID查找一个已经注册的音视频编码器,查找编码器之前,必须先调用av_register_all注册所有支持的编码器<BR>
音视频编码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较编码器的ID来查找<BR>
*/<BR>
  if(pCodec==NULL) {<BR>
    fprintf(stderr, &quot;Unsupported codec!\n&quot;);<BR>
    return ; // Codec not found<BR>
  }<BR>
  // Open codec<BR>
//使用给定的AVCodec初始化AVCodecContext<BR>
<BR>
<BR>
  if(avcodec_open(pCodecCtx, pCodec)&lt;0)<BR>
    return ; // Could not open codec<BR>
<BR>
<BR>
  //printf(&quot;name %s\n&quot;,pCodec-&gt;name);<BR>
  //getchar();<BR>
<BR>
<BR>
  // Allocate video frame<BR>
  pFrame=avcodec_alloc_frame();<BR>
  <BR>
  // Allocate an AVFrame structure<BR>
  pFrameYUV=avcodec_alloc_frame();<BR>
  if(pFrameYUV==NULL)<BR>
    return ;<BR>
  <BR>
  // Determine required buffer size and allocate buffer<BR>
  numBytes=avpicture_get_size(PIX_FMT_YUV420P, pCodecCtx-&gt;width,<BR>
         pCodecCtx-&gt;height);<BR>
  buffer=(uint8_t *)av_malloc(numBytes*sizeof(uint8_t));<BR>
  <BR>
  // Assign appropriate parts of buffer to image planes in pFrameRGB<BR>
  // Note that pFrameRGB is an AVFrame, but AVFrame is a superset<BR>
  // of AVPicture<BR>
  avpicture_fill((AVPicture *)pFrameYUV, buffer, PIX_FMT_YUV420P,<BR>
   pCodecCtx-&gt;width, pCodecCtx-&gt;height);<BR>
  <BR>
  // Read frames and save first five frames to disk<BR>
  i=0;<BR>
  ////////////////////////////////////////////////////////////////<BR>
  if (SDL_Init(SDL_INIT_VIDEO) &lt; 0)<BR>
  {<BR>
	  fprintf(stderr, &quot;can not initialize SDL:%s\n&quot;, SDL_GetError());<BR>
	  exit(1);<BR>
   }<BR>
  atexit(SDL_Quit);<BR>
  SDL_Surface *screen;<BR>
  screen = SDL_SetVideoMode(720, 576, 24, SDL_SWSURFACE|SDL_ANYFORMAT);<BR>
  if ( screen == NULL ) <BR>
  {<BR>
	  exit(2);<BR>
  }<BR>
  	SDL_Overlay *image;<BR>
<BR>
<BR>
	image = SDL_CreateYUVOverlay(pCodecCtx-&gt;width,<BR>
		pCodecCtx-&gt;height,<BR>
		SDL_YV12_OVERLAY,<BR>
				 screen);<BR>
<BR>
<BR>
    if(image == NULL) <BR>
	{<BR>
        //fprintf(stderr, &quot;CreateRGBSurface failed: %s\n&quot;, SDL_GetError());<BR>
        exit(1);<BR>
    }<BR>
  //////////////////////////////////////////////////////////////////<BR>
  while(av_read_frame(pFormatCtx, &amp;packet)&gt;=0) <BR>
  {<BR>
    // Is this a packet from the video stream?<BR>
    if(packet.stream_index==videoStream) <BR>
 {<BR>
    // Decode video frame<BR>
    avcodec_decode_video(pCodecCtx, pFrame, &amp;frameFinished, <BR>
       packet.data, packet.size);<BR>
      <BR>
    // Did we get a video frame?<BR>
    if(frameFinished) <BR>
    {<BR>
  // Convert the image from its native format to RGB<BR>
         	SDL_LockYUVOverlay(image);<BR>
<BR>
<BR>
// 			pFrameYUV-&gt;data[0] = image-&gt;pixels[0];//预先改变指针数据区，不用copy<BR>
// 			pFrameYUV-&gt;data[1] = image-&gt;pixels[2];<BR>
// 			pFrameYUV-&gt;data[2] = image-&gt;pixels[1];<BR>
// 			<BR>
// 			pFrameYUV-&gt;linesize[0] = image-&gt;pitches[0];<BR>
// 			pFrameYUV-&gt;linesize[1] = image-&gt;pitches[2];<BR>
// 			pFrameYUV-&gt;linesize[2] = image-&gt;pitches[1];<BR>
<BR>
<BR>
        img_convert_ctx = sws_getContext( pCodecCtx-&gt;width, <BR>
               pCodecCtx-&gt;height,<BR>
               pCodecCtx-&gt;pix_fmt,<BR>
               pCodecCtx-&gt;width, <BR>
               pCodecCtx-&gt;height,<BR>
               PIX_FMT_YUV420P,<BR>
               sws_flags, NULL, NULL, NULL);<BR>
        		sws_scale(img_convert_ctx,pFrame-&gt;data,pFrame-&gt;linesize,0,pCodecCtx-&gt;height,pFrameYUV-&gt;data,pFrameYUV-&gt;linesize);  <BR>
        sws_freeContext(img_convert_ctx);<BR>
<BR>
<BR>
       memcpy(image-&gt;pixels[0],	pFrameYUV-&gt;data[0],720*576);//拷贝数据yuv420，也可预先改变指针<BR>
	   memcpy(image-&gt;pixels[2],	pFrameYUV-&gt;data[1],720*576/4);<BR>
	   memcpy(image-&gt;pixels[1],	pFrameYUV-&gt;data[2],720*576/4);<BR>
<BR>
<BR>
	 SDL_UnlockYUVOverlay(image);<BR>
	 <BR>
	 rect.x = 0;<BR>
	 rect.y = 0;<BR>
	 rect.w = pCodecCtx-&gt;width;<BR>
	 rect.h = pCodecCtx-&gt;height;<BR>
	SDL_DisplayYUVOverlay(image, &amp;rect);<BR>
    }<BR>
}<BR>
    <BR>
    // Free the packet that was allocated by av_read_frame<BR>
    av_free_packet(&amp;packet);<BR>
  }<BR>
  <BR>
  // Free the RGB image<BR>
  av_free(buffer);<BR>
  av_free(pFrameYUV);<BR>
  <BR>
  // Free the YUV frame<BR>
  av_free(pFrame);<BR>
  <BR>
  // Close the codec<BR>
  avcodec_close(pCodecCtx);<BR>
  <BR>
  // Close the video file<BR>
  av_close_input_file(pFormatCtx);<BR>
  MessageBox(&quot;over&quot;);<BR>
}<BR>
<BR>
<BR>
<b><span style="background-color:#ff6363">void CTest0Dlg::OnButton4() </b></span><BR>
{<BR>
	// TODO: Add your control notification handler code here<BR>
			// TODO: Add your control notification handler code here<BR>
		  AVFormatContext *pFormatCtx;<BR>
  int             i, videoStream;<BR>
  AVCodecContext  *pCodecCtx;<BR>
  AVCodec         *pCodec;<BR>
  AVFrame         *pFrame; <BR>
  AVFrame         *pFrameYUV;<BR>
  AVPacket        packet;<BR>
  int             frameFinished;<BR>
  int             numBytes;<BR>
  uint8_t         *buffer;<BR>
   SDL_Rect        rect;<BR>
  static int sws_flags = SWS_BICUBIC;<BR>
  struct SwsContext *img_convert_ctx;<BR>
   AVPicture pict;  <BR>
//  argc = 2;<BR>
  char argv[100] = &quot;d:\\temp\\VIDEO720576.264&quot;;<BR>
 // argv[1] = &quot;d:\\temp\\ff.mpg&quot;;<BR>
 <BR>
  // /*注册所有可用的格式和编解码器*/<BR>
  av_register_all();<BR>
  <BR>
  // Open video file /*以输入方式打开一个媒体文件,也即源文件,codecs并没有打开,只读取了文件的头信息*/<BR>
  if(av_open_input_file(&amp;pFormatCtx, argv, NULL, 0, NULL)!=0)<BR>
    return ; // Couldn't open file<BR>
  <BR>
  // Retrieve stream information<BR>
/*通过读取媒体文件的中的包来获取媒体文件中的流信息,对于没有头信息的文件如(mpeg)是非常有用的,<BR>
// 该函数通常重算类似mpeg-2帧模式的真实帧率,该函数并未改变逻辑文件的position.<BR>
*/<BR>
  if(av_find_stream_info(pFormatCtx)&lt;0)<BR>
    return ; // Couldn't find stream information<BR>
  <BR>
  // Dump information about file onto standard error<BR>
//该函数的作用就是检查下初始化过程中设置的参数是否符合规范<BR>
  dump_format(pFormatCtx, 0, argv, 0);<BR>
  <BR>
  // Find the first video stream<BR>
  videoStream=-1;<BR>
  printf(&quot;%d\n&quot;,pFormatCtx-&gt;nb_streams);<BR>
  getchar();<BR>
  for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++)<BR>
    if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==CODEC_TYPE_VIDEO&amp;&amp;videoStream &lt; 0)<BR>
 {<BR>
      videoStream=i;<BR>
      break;<BR>
    }<BR>
  if(videoStream==-1)<BR>
    return ; // Didn't find a video stream<BR>
  <BR>
  // Get a pointer to the codec context for the video stream<BR>
  pCodecCtx=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<BR>
  <BR>
  // Find the decoder for the video stream<BR>
  pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id);<BR>
/*通过code ID查找一个已经注册的音视频编码器,查找编码器之前,必须先调用av_register_all注册所有支持的编码器<BR>
音视频编码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较编码器的ID来查找<BR>
*/<BR>
  if(pCodec==NULL) {<BR>
    fprintf(stderr, &quot;Unsupported codec!\n&quot;);<BR>
    return ; // Codec not found<BR>
  }<BR>
  // Open codec<BR>
//使用给定的AVCodec初始化AVCodecContext<BR>
<BR>
<BR>
  if(avcodec_open(pCodecCtx, pCodec)&lt;0)<BR>
    return ; // Could not open codec<BR>
<BR>
<BR>
  //printf(&quot;name %s\n&quot;,pCodec-&gt;name);<BR>
  //getchar();<BR>
<BR>
<BR>
  // Allocate video frame<BR>
  pFrame=avcodec_alloc_frame();<BR>
  <BR>
  // Allocate an AVFrame structure<BR>
  pFrameYUV=avcodec_alloc_frame();<BR>
  if(pFrameYUV==NULL)<BR>
    return ;<BR>
  <BR>
  // Determine required buffer size and allocate buffer<BR>
  numBytes=avpicture_get_size(PIX_FMT_YUV422, pCodecCtx-&gt;width,<BR>
         pCodecCtx-&gt;height);<BR>
  buffer=(uint8_t *)av_malloc(numBytes*sizeof(uint8_t));<BR>
  <BR>
  // Assign appropriate parts of buffer to image planes in pFrameRGB<BR>
  // Note that pFrameRGB is an AVFrame, but AVFrame is a superset<BR>
  // of AVPicture<BR>
  avpicture_fill((AVPicture *)pFrameYUV, buffer, PIX_FMT_YUV422,<BR>
   pCodecCtx-&gt;width, pCodecCtx-&gt;height);<BR>
  <BR>
  // Read frames and save first five frames to disk<BR>
  i=0;<BR>
  ////////////////////////////////////////////////////////////////<BR>
  if (SDL_Init(SDL_INIT_VIDEO) &lt; 0)<BR>
  {<BR>
	  fprintf(stderr, &quot;can not initialize SDL:%s\n&quot;, SDL_GetError());<BR>
	  exit(1);<BR>
   }<BR>
  atexit(SDL_Quit);<BR>
  SDL_Surface *screen;<BR>
  screen = SDL_SetVideoMode(720, 576, 24, SDL_SWSURFACE|SDL_ANYFORMAT);<BR>
  if ( screen == NULL ) <BR>
  {<BR>
	  exit(2);<BR>
  }<BR>
  	SDL_Overlay *image;<BR>
<BR>
<BR>
	image = SDL_CreateYUVOverlay(pCodecCtx-&gt;width,<BR>
		pCodecCtx-&gt;height,<BR>
		SDL_YUY2_OVERLAY,<BR>
				 screen);<BR>
<BR>
<BR>
    if(image == NULL) <BR>
	{<BR>
        //fprintf(stderr, &quot;CreateRGBSurface failed: %s\n&quot;, SDL_GetError());<BR>
        exit(1);<BR>
    }<BR>
  //////////////////////////////////////////////////////////////////<BR>
  while(av_read_frame(pFormatCtx, &amp;packet)&gt;=0) <BR>
  {<BR>
    // Is this a packet from the video stream?<BR>
    if(packet.stream_index==videoStream) <BR>
 {<BR>
    // Decode video frame<BR>
    avcodec_decode_video(pCodecCtx, pFrame, &amp;frameFinished, <BR>
       packet.data, packet.size);<BR>
      <BR>
    // Did we get a video frame?<BR>
    if(frameFinished) <BR>
    {<BR>
  // Convert the image from its native format to RGB<BR>
         	SDL_LockYUVOverlay(image);<BR>
<BR>
<BR>
// 			pFrameYUV-&gt;data[0] = image-&gt;pixels[0];<BR>
// 			pFrameYUV-&gt;data[1] = image-&gt;pixels[2];<BR>
// 			pFrameYUV-&gt;data[2] = image-&gt;pixels[1];<BR>
// 			<BR>
// 			pFrameYUV-&gt;linesize[0] = image-&gt;pitches[0];<BR>
// 			pFrameYUV-&gt;linesize[1] = image-&gt;pitches[2];<BR>
// 			pFrameYUV-&gt;linesize[2] = image-&gt;pitches[1];<BR>
<BR>
<BR>
        img_convert_ctx = sws_getContext( pCodecCtx-&gt;width, <BR>
               pCodecCtx-&gt;height,<BR>
               pCodecCtx-&gt;pix_fmt,<BR>
               pCodecCtx-&gt;width, <BR>
               pCodecCtx-&gt;height,<BR>
               PIX_FMT_YUV422,<BR>
               sws_flags, NULL, NULL, NULL);<BR>
        		sws_scale(img_convert_ctx,pFrame-&gt;data,pFrame-&gt;linesize,0,pCodecCtx-&gt;height,pFrameYUV-&gt;data,pFrameYUV-&gt;linesize);  <BR>
        sws_freeContext(img_convert_ctx);<BR>
<BR>
<BR>
       memcpy(image-&gt;pixels[0],	pFrameYUV-&gt;data[0],720*576*2);//拷贝数据yuv422<BR>
<BR>
<BR>
<BR>
<BR>
	 SDL_UnlockYUVOverlay(image);<BR>
	 <BR>
	 rect.x = 0;<BR>
	 rect.y = 0;<BR>
	 rect.w = pCodecCtx-&gt;width;<BR>
	 rect.h = pCodecCtx-&gt;height;<BR>
	SDL_DisplayYUVOverlay(image, &amp;rect);<BR>
    }<BR>
}<BR>
    <BR>
    // Free the packet that was allocated by av_read_frame<BR>
    av_free_packet(&amp;packet);<BR>
  }<BR>
  <BR>
  // Free the RGB image<BR>
  av_free(buffer);<BR>
  av_free(pFrameYUV);<BR>
  <BR>
  // Free the YUV frame<BR>
  av_free(pFrame);<BR>
  <BR>
  // Close the codec<BR>
  avcodec_close(pCodecCtx);<BR>
  <BR>
  // Close the video file<BR>
  av_close_input_file(pFormatCtx);<BR>
  MessageBox(&quot;over&quot;);<BR>
}<BR>
http://download.csdn.net/detail/mao0514/8202691
</DD>
</DL>

</DD>
<DT>系统方案</DT>
<!--property:date_created=1516961851-->
<!--property:date_modified=1516961851-->
<DD>
<DL>
<DT>环境变量不重启</DT>
<!--property:date_created=1516961865-->
<!--property:date_modified=1516961875-->
<DD>
在“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中增加或修改环境变量后，需重启系统才能使之生效。有没有什么方法可让它即时生效呢？下面介绍一种方法：<BR>
<BR>
　　以修改环境变量“PATH”为例，修改完成后，进入DOS命令提示符，输入：set PATH=C: ，关闭DOS窗口。再次打开DOS窗口，输入：echo %PATH% ，可以发现“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中设置的 PATH 值已经生效。<BR>
<BR>
　　不用担心DOS窗口中的修改会影响环境变量的值，DOS窗口中的环境变量只是Windows环境变量的一个副本而已。但是对副本的修改却会引发Windows环境变量的刷新，这正是我们想要的!<BR>
<BR>
 <BR>
<BR>
诡异啊，使用win+R-&gt;cmd 启动的cmd.exe 会发现在电脑属性中设置的环境变量立马生效了，在其他模式下启动的cmd却没有发生效果，怪哉！！查看了一下资料，在电脑属性中设置环境变量以后，以后启动的程序和线程会生效，而对以前驻留内存的程序不起作用，也有人说kill explorer.exe 再启动explorer.exe 可以激发设置其作用。<BR>
<BR>
 <BR>
<BR>
这里要理解的是，一个程序启动时，环境变量被复制到该程序所在的环境中，在该程序执行过程中不会被除该程序以外的其他程序所改变。也就是说，假设我们启动了一个cmd程序，然后通过控制面板修改了环境变量设置，但是已经启动了的cmd所拥有的环境变量并不会被改变。如果我们在修改环境变量之后启动cmd程序，则该程序将拥有新的环境变量。<BR>
那么结论就很明显了：修改环境变量之后，如果受影响的是应用程序，那么只要简单地重新启动此应用程序，环境变量的修改就会反映到该程序中，而不必重新启动计算机；但是，如果受影响的是系统服务，就必须重新启动才能将环境变量的修改反映到系统服务中（因为没有办法在不重启计算机的情况下重新启动系统服务管理器）。<BR>
<BR>
 <BR>
<BR>
方案一：修改注册表，并向系统广播消息<BR>
<BR>
修改Windows环境变量后不重新启动使之立即生效的方法<BR>
<BR>
 <BR>
<BR>
不少程序需要添加各自的环境变量，方便定制性使用。用得最多的是用户指定目录如JAVA_HOME等变量，程序中可以根据获取变量%JAVA_HOME%，来获取对应设置的字符串。<BR>
<BR>
<BR>
 <BR>
<BR>
一般做法是安装的时候就指定，或者程序中设定。<BR>
<BR>
用批处理临时设置环境变量就不提了，这里讲让环境变量始终生效。<BR>
<BR>
一般做法是修改环境变量注册表。<BR>
<BR>
整个Windows都有效的环境变量在<BR>
HKEY_LOCAL_MACHINESYSTEMControlSet001ControlSession ManagerEnvironment<BR>
中设置<BR>
<BR>
对当前用户有效的环境变量在<BR>
HKEY_CURRENT_USEREnvironment<BR>
中设置<BR>
<BR>
其实只是简单的元数据<BR>
<BR>
但往往修改玩后无法即时生效，往往需要重启系统。<BR>
<BR>
要解决即时生效的问题，可以再在我的电脑属性中设置环境变量中确定一下即可。<BR>
<BR>
依此看来，这个过程肯定是读取了注册表，再调用一个系统函数来更新整个系统的变量。一定可以编程解决的。<BR>
<BR>
可惜网海茫茫，收不到。<BR>
<BR>
一不做二不休，直接下载打开innosetup的代码，搜索Environment，果真找到了。<BR>
<BR>
很简单：<BR>
<BR>
SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0,LPARAM(&quot;Environment&quot;), SMTO_ABORTIFHUNG, 5000, &amp;MsgResult);<BR>
<BR>
发一个全局的广播，等待各自相应后，立即生效。<BR>
<BR>
  { Note: We originally used SendNotifyMessage to broadcast the message but it<BR>
    turned out that while it worked fine on NT 4 and 2000 it didn't work on XP<BR>
    -- the string &quot;Environment&quot; in lParam would be garbled on the receiving<BR>
    end (why I'm not exactly sure). We now use SendMessageTimeout as directed<BR>
    in the KB article 104011. It isn't as elegant since it could cause us to<BR>
    be delayed if another app is hung, but it'll have to do. }<BR>
<BR>
 <BR>
<BR>
 <BR>
<BR>
方案二：在高级属性中设置完毕后，在任意cmd下设置一次path的值，达到全局广播的目的<BR>
<BR>
让环境变量生效不需重启Windows<BR>
<BR>
很多安装程序在安装完成后并不要求重启Windows，而新的环境变量已经生效了，可见在不重启Windows的情况下让环境变量生效是完全可行的。 <BR>
<BR>
可我搜索如何不需重启Windows让环境变量生效的方法，只找到三类方案： <BR>
<BR>
下载一个专门的软件 <BR>
编个小程序 <BR>
修改注册表 <BR>
我既然是个懒得重启Windows的人，难道我会不厌其烦按上述三种方法去做吗？没办法，我只有自己摸索。最后找到一个非常简单的在Windows下直接让环境变量生效的办法： <BR>
<BR>
先到我的电脑&gt;属性&gt;高级&gt;环境变量，添加新环境变量或修改已有的环境变量，然后运行“DOS命令提示符”或run cmd，假设要修改PATH变量，不管PATH的原值是什么，在DOS窗口直接把PATH修改为任意值，如：输入：set PATH=C:，关闭DOS窗口。再次打开DOS窗口，输入：echo %PATH% ，这时可以发现，我的电脑&gt;属 性&gt;高级&gt;环境变量里PATH已经在Windows全局生效了。 <BR>
<BR>
不用担心在DOS窗口的修改会影响我的电脑&gt;属性&gt;高级&gt;环境变量里的修改，DOS窗口的环境变量只是Windows环境变量的一个副本，副本的改动不会影响正本，但会触发正本的刷新，这正是我想要的&#8212;&#8212;让环境变量生效。<BR>
<BR>
 <BR>
<BR>
 <BR>
<BR>
方案三：<BR>
<BR>
修改Windows环境变量并使之立即生效<BR>
<BR>
想在Windows下通过编程修改环境变量的值，并且希望修改完后立即生效。<BR>
一、环境变量的修改<BR>
（1）修改当前进程的某个环境变量：SetEnvironmentVariable。<BR>
（2）修改系统环境变量：在注册表HKEY_LOCAL_MACHINESystemCurrentControlSetControlSession ManagerEnvironment中修改。<BR>
（3）修改用户环境变量：在注册表中HKEY_CURRENT_USEREnvironment修改。<BR>
二、环境变量的生效<BR>
在网上搜了一下，有两种说法：<BR>
（1）SendMessage(HWND_BROADCAST,WM_SETTINGCHANGE,0,(LPARAM)TEXT(&quot;Environment&quot;));<BR>
（2）SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0,LPARAM(&quot;Environment&quot;), SMTO_ABORTIFHUNG, 5000, &amp;MsgResult);<BR>
没有尝试，先记在这儿。<BR>
<BR>
 <BR>
<BR>
==========================================================================================<BR>
<BR>
下面是网阅的Windows官方资料，文档中阐述了环境变量更改后如何即时生效的原理。
</DD>
</DL>

</DD>
<DT>高性能编程</DT>
<!--property:date_created=1517388605-->
<!--property:date_modified=1517388605-->
<DD>
<DL>
<DT>C语言高性能编程知识</DT>
<!--property:date_created=1517388612-->
<!--property:date_modified=1517388669-->
<DD>
1、选择合适的算法和数据结构<BR>
选择一种合适的数据结构很重要，如果在一堆随机存放的数中使用了大量的插入和删除指令，那使用链表要快得多。数组与指针语句具有十分密切的关系，一般来说，指针比较灵活简洁，而数组则比较直观，容易理解。对于大部分的编译器，使用指针比使用数组生成的代码更短，执行效率更高。<BR>
在许多种情况下，可以用指针运算代替数组索引，这样做常常能产生又快又短的代码。与数组索引相比，指针一般能使代码速度更快，占用空间更少。使用多维数组时差异更明显。下面的代码作用是相同的，但是效率不一样。<BR>
    数组索引                指针运算<BR>
    For(;;){                p=array<BR>
    A=array[t++];          for(;;){<BR>
                                a=*(p++);<BR>
    。。。。。。。。。                  。。。。。。<BR>
    }                      }<BR>
指针方法的优点是，array的地址每次装入地址p后，在每次循环中只需对p增量操作。在数组索引方法中，每次循环中都必须根据t值求数组下标的复杂运算。<BR>
2、使用尽量小的数据类型<BR>
能够使用字符型(char)定义的变量，就不要使用整型(int)变量来定义；能够使用整型变量定义的变量就不要用长整型(long int)，能不使用浮点型(float)变量就不要使用浮点型变量。当然，在定义变量后不要超过变量的作用范围，如果超过变量的范围赋值，C编译器并不报错，但程序运行结果却错了，而且这样的错误很难发现。<BR>
在ICCAVR中，可以在Options中设定使用printf参数，尽量使用基本型参数(%c、%d、%x、%X、%u和%s格式说明符)，少用长整型参数(%ld、%lu、%lx和%lX格式说明符)，至于浮点型的参数(%f)则尽量不要使用，其它C编译器也一样。在其它条件不变的情况下，使用%f参数，会使生成的代码的数量增加很多，执行速度降低。<BR>
3、减少运算的强度<BR>
（1）、查表(游戏程序员必修课)<BR>
一个聪明的游戏大虾，基本上不会在自己的主循环里搞什么运算工作，绝对是先计算好了，再到循环里查表。看下面的例子：<BR>
旧代码：<BR>
    long factorial(int i)<BR>
    {<BR>
        if (i == 0)<BR>
            return 1;<BR>
        else<BR>
            return i * factorial(i - 1);<BR>
    }<BR>
新代码：<BR>
    static long factorial_table[] =<BR>
        {1， 1， 2， 6， 24， 120， 720  /* etc */ };<BR>
    long factorial(int i)<BR>
    {<BR>
        return factorial_table[i];<BR>
    }<BR>
如果表很大，不好写，就写一个init函数，在循环外临时生成表格。<BR>
（2）、求余运算<BR>
    a=a%8;<BR>
可以改为：<BR>
    a=a&amp;7;<BR>
说明：位操作只需一个指令周期即可完成，而大部分的C编译器的“%”运算均是调用子程序来完成，代码长、执行速度慢。通常，只要求是求2n方的余数，均可使用位操作的方法来代替。<BR>
（3）、平方运算<BR>
    a=pow(a, 2.0);<BR>
可以改为：<BR>
    a=a*a;<BR>
说明：在有内置硬件乘法器的单片机中(如51系列)，乘法运算比求平方运算快得多，因为浮点数的求平方是通过调用子程序来实现的，在自带硬件乘法器的AVR单片机中，如ATMega163中，乘法运算只需2个时钟周期就可以完成。既使是在没有内置硬件乘法器的AVR单片机中，乘法运算的子程序比平方运算的子程序代码短，执行速度快。<BR>
如果是求3次方，如：<BR>
    a=pow(a，3。0);<BR>
更改为：<BR>
    a=a*a*a；<BR>
则效率的改善更明显。<BR>
（4）、用移位实现乘除法运算<BR>
    a=a*4;<BR>
    b=b/4;<BR>
可以改为：<BR>
    a=a&lt;&lt;2;<BR>
    b=b&gt;&gt;2;<BR>
通常如果需要乘以或除以2n，都可以用移位的方法代替。在ICCAVR中，如果乘以2n，都可以生成左移的代码，而乘以其它的整数或除以任何数，均调用乘除法子程序。用移位的方法得到代码比调用乘除法子程序生成的代码效率高。实际上，只要是乘以或除以一个整数，均可以用移位的方法得到结果，如：<BR>
    a=a*9<BR>
可以改为：<BR>
a=(a&lt;&lt;3)+a<BR>
采用运算量更小的表达式替换原来的表达式，下面是一个经典例子:<BR>
旧代码:<BR>
    x = w % 8;<BR>
    y = pow(x， 2.0);<BR>
    z = y * 33;<BR>
    for (i = 0;i &lt; MAX;i++)<BR>
    {<BR>
        h = 14 * i;<BR>
        printf(&quot;%d&quot;， h);<BR>
    }<BR>
新代码:<BR>
    x = w &amp; 7;              /* 位操作比求余运算快 */<BR>
    y = x * x;               /* 乘法比平方运算快 */<BR>
    z = (y &lt;&lt; 5) + y;          /* 位移乘法比乘法快 */<BR>
    for (i = h = 0; i &lt; MAX; i++)<BR>
    {<BR>
        h += 14;                /* 加法比乘法快 */<BR>
        printf(&quot;%d&quot;， h);<BR>
}<BR>
（5）、避免不必要的整数除法<BR>
　　整数除法是整数运算中最慢的，所以应该尽可能避免。一种可能减少整数除法的地方是连除，这里除法可以由乘法代替。这个替换的副作用是有可能在算乘积时会溢出，所以只能在一定范围的除法中使用。<BR>
　　         不好的代码：<BR>
int i， j， k， m；<BR>
m = i / j / k；<BR>
             推荐的代码：<BR>
int i， j， k， m；<BR>
m = i / (j * k)；<BR>
（6）、使用增量和减量操作符<BR>
    在使用到加一和减一操作时尽量使用增量和减量操作符，因为增量符语句比赋值语句更快，原因在于对大多数CPU来说，对内存字的增、减量操作不必明显地使用取内存和写内存的指令，比如下面这条语句：<BR>
x=x+1;<BR>
模仿大多数微机汇编语言为例，产生的代码类似于：<BR>
    move A，x      ;把x从内存取出存入累加器A<BR>
    add A，1        ;累加器A加1<BR>
store x          ;把新值存回x<BR>
如果使用增量操作符，生成的代码如下：<BR>
    incr x           ;x加1<BR>
显然，不用取指令和存指令，增、减量操作执行的速度加快，同时长度也缩短了。<BR>
（7）、使用复合赋值表达式<BR>
复合赋值表达式(如a-=1及a+=1等)都能够生成高质量的程序代码。<BR>
（8）、提取公共的子表达式<BR>
在某些情况下，C++编译器不能从浮点表达式中提出公共的子表达式，因为这意味着相当于对表达式重新排序。需要特别指出的是，编译器在提取公共子表达式前不能按照代数的等价关系重新安排表达式。这时，程序员要手动地提出公共的子表达式（在VC.NET里有一项“全局优化”选项可以完成此工作，但效果就不得而知了）。<BR>
不好的代码：<BR>
float a， b， c， d， e， f；<BR>
。。。<BR>
e = b * c / d；<BR>
f = b / d * a；<BR>
推荐的代码：<BR>
float a， b， c， d， e， f；<BR>
。。。<BR>
const float t(b / d)；<BR>
e = c * t；<BR>
f = a * t；<BR>
 <BR>
不好的代码：<BR>
float a， b， c， e， f；<BR>
。。。<BR>
e = a / c；<BR>
f = b / c；<BR>
推荐的代码：<BR>
float a， b， c， e， f；<BR>
。。。<BR>
const float t(1.0f / c)；<BR>
e = a * t；<BR>
f = b * t；<BR>
4、结构体成员的布局<BR>
　　很多编译器有“使结构体字，双字或四字对齐”的选项。但是，还是需要改善结构体成员的对齐，有些编译器可能分配给结构体成员空间的顺序与他们声明的不同。但是，有些编译器并不提供这些功能，或者效果不好。所以，要在付出最少代价的情况下实现最好的结构体和结构体成员对齐，建议采取下列方法：<BR>
（1）按数据类型的长度排序<BR>
把结构体的成员按照它们的类型长度排序，声明成员时把长的类型放在短的前面。编译器要求把长型数据类型存放在偶数地址边界。在申明一个复杂的数据类型 (既有多字节数据又有单字节数据) 时，应该首先存放多字节数据，然后再存放单字节数据，这样可以避免内存的空洞。编译器自动地把结构的实例对齐在内存的偶数边界。<BR>
（2）把结构体填充成最长类型长度的整倍数<BR>
把结构体填充成最长类型长度的整倍数。照这样，如果结构体的第一个成员对齐了，所有整个结构体自然也就对齐了。下面的例子演示了如何对结构体成员进行重新排序：<BR>
不好的代码，普通顺序：<BR>
struct<BR>
{<BR>
　　                           char a[5]；<BR>
　　       long k；<BR>
　 double x；<BR>
} baz；<BR>
 <BR>
推荐的代码，新的顺序并手动填充了几个字节：<BR>
struct<BR>
{<BR>
　　                           double x；<BR>
　　                           long k；<BR>
　　                           char a[5]；<BR>
char pad[7]；<BR>
} baz；<BR>
这个规则同样适用于类的成员的布局。<BR>
（3）按数据类型的长度排序本地变量<BR>
当编译器分配给本地变量空间时，它们的顺序和它们在源代码中声明的顺序一样，和上一条规则一样，应该把长的变量放在短的变量前面。如果第一个变量对齐了，其它变量就会连续的存放，而且不用填充字节自然就会对齐。有些编译器在分配变量时不会自动改变变量顺序，有些编译器不能产生4字节对齐的栈，所以4字节可能不对齐。下面这个例子演示了本地变量声明的重新排序：<BR>
　　             不好的代码，普通顺序<BR>
short ga， gu， gi；<BR>
long foo， bar；<BR>
double x， y， z[3]；<BR>
char a， b；<BR>
float baz；<BR>
推荐的代码，改进的顺序<BR>
double z[3]；<BR>
double x， y；<BR>
long foo， bar；<BR>
float baz；<BR>
short ga， gu， gi； <BR>
（4）把频繁使用的指针型参数拷贝到本地变量<BR>
避免在函数中频繁使用指针型参数指向的值。因为编译器不知道指针之间是否存在冲突，所以指针型参数往往不能被编译器优化。这样数据不能被存放在寄存器中，而且明显地占用了内存带宽。注意，很多编译器有“假设不冲突”优化开关（在VC里必须手动添加编译器命令行/Oa或/Ow），这允许编译器假设两个不同的指针总是有不同的内容，这样就不用把指针型参数保存到本地变量。否则，请在函数一开始把指针指向的数据保存到本地变量。如果需要的话，在函数结束前拷贝回去。<BR>
不好的代码：<BR>
// 假设 q != r<BR>
void isqrt(unsigned long a， unsigned long* q， unsigned long* r)<BR>
{<BR>
　　*q = a；<BR>
　　if (a &gt; 0)<BR>
　　{<BR>
　　　　while (*q &gt; (*r = a / *q))<BR>
　　　　{<BR>
　　　　　　*q = (*q + *r) &gt;&gt; 1；<BR>
　　　　}<BR>
　　}<BR>
　　*r = a - *q * *q；<BR>
}<BR>
 <BR>
推荐的代码：<BR>
// 假设 q != r<BR>
void isqrt(unsigned long a， unsigned long* q， unsigned long* r)<BR>
{<BR>
　　unsigned long qq， rr；<BR>
　　qq = a；<BR>
　　if (a &gt; 0)<BR>
　　{<BR>
　　　　while (qq &gt; (rr = a / qq))<BR>
　　　　{<BR>
　　　　　　qq = (qq + rr) &gt;&gt; 1；<BR>
　　　　}<BR>
　　}<BR>
　　rr = a - qq * qq；<BR>
　　*q = qq；<BR>
　　*r = rr；<BR>
}<BR>
5、循环优化<BR>
（1）、充分分解小的循环<BR>
　　要充分利用CPU的指令缓存，就要充分分解小的循环。特别是当循环体本身很小的时候，分解循环可以提高性能。注意:很多编译器并不能自动分解循环。 不好的代码：<BR>
// 3D转化：把矢量 V 和 4x4 矩阵 M 相乘<BR>
for (i = 0； i &lt; 4； i ++)<BR>
{<BR>
　　r[i] = 0；<BR>
　　for (j = 0； j &lt; 4； j ++)<BR>
　　{<BR>
　　　　r[i] += M[j][i]*V[j]；<BR>
　　}<BR>
}<BR>
推荐的代码：<BR>
r[0] = M[0][0]*V[0] + M[1][0]*V[1] + M[2][0]*V[2] + M[3][0]*V[3]；<BR>
r[1] = M[0][1]*V[0] + M[1][1]*V[1] + M[2][1]*V[2] + M[3][1]*V[3]；<BR>
r[2] = M[0][2]*V[0] + M[1][2]*V[1] + M[2][2]*V[2] + M[3][2]*V[3]；<BR>
r[3] = M[0][3]*V[0] + M[1][3]*V[1] + M[2][3]*V[2] + M[3][3]*v[3]；<BR>
（2）、提取公共部分<BR>
对于一些不需要循环变量参加运算的任务可以把它们放到循环外面，这里的任务包括表达式、函数的调用、指针运算、数组访问等，应该将没有必要执行多次的操作全部集合在一起，放到一个init的初始化程序中进行。<BR>
（3）、延时函数<BR>
通常使用的延时函数均采用自加的形式：<BR>
    void delay (void)<BR>
    {<BR>
unsigned int i;<BR>
    for (i=0;i&lt;1000;i++) ;<BR>
    }<BR>
将其改为自减延时函数：<BR>
    void delay (void)<BR>
    {<BR>
unsigned int i;<BR>
        for (i=1000;i&gt;0;i--) ;<BR>
    }<BR>
两个函数的延时效果相似，但几乎所有的C编译对后一种函数生成的代码均比前一种代码少1~3个字节，因为几乎所有的MCU均有为0转移的指令，采用后一种方式能够生成这类指令。在使用while循环时也一样，使用自减指令控制循环会比使用自加指令控制循环生成的代码更少1~3个字母。但是在循环中有通过循环变量“i”读写数组的指令时，使用预减循环有可能使数组超界，要引起注意。<BR>
（4）、while循环和do…while循环<BR>
用while循环时有以下两种循环形式：<BR>
unsigned int i;<BR>
    i=0;<BR>
    while (i&lt;1000)<BR>
    {<BR>
        i++;<BR>
           //用户程序<BR>
    }<BR>
或：<BR>
unsigned int i;<BR>
    i=1000;<BR>
do<BR>
{<BR>
          i--;<BR>
          //用户程序<BR>
}<BR>
while (i&gt;0);<BR>
在这两种循环中，使用do…while循环编译后生成的代码的长度短于while循环。<BR>
（6）、循环展开<BR>
这是经典的速度优化，但许多编译程序(如gcc -funroll-loops)能自动完成这个事，所以现在你自己来优化这个显得效果不明显。<BR>
旧代码:<BR>
for (i = 0; i &lt; 100; i++)<BR>
{<BR>
do_stuff(i);<BR>
}<BR>
新代码:<BR>
for (i = 0; i &lt; 100; )<BR>
{<BR>
do_stuff(i); i++;<BR>
do_stuff(i); i++;<BR>
do_stuff(i); i++;<BR>
do_stuff(i); i++;<BR>
do_stuff(i); i++;<BR>
do_stuff(i); i++;<BR>
do_stuff(i); i++;<BR>
do_stuff(i); i++;<BR>
do_stuff(i); i++;<BR>
do_stuff(i); i++;<BR>
}<BR>
可以看出，新代码里比较指令由100次降低为10次，循环时间节约了90%。不过注意:对于中间变量或结果被更改的循环，编译程序往往拒绝展开，(怕担责任呗)，这时候就需要你自己来做展开工作了。<BR>
还有一点请注意，在有内部指令cache的CPU上(如MMX芯片)，因为循环展开的代码很大，往往cache溢出，这时展开的代码会频繁地在CPU 的cache和内存之间调来调去，又因为cache速度很高，所以此时循环展开反而会变慢。还有就是循环展开会影响矢量运算优化。<BR>
（6）、循环嵌套<BR>
把相关循环放到一个循环里，也会加快速度。<BR>
旧代码:<BR>
for (i = 0; i &lt; MAX; i++)          /* initialize 2d array to 0's */<BR>
    for (j = 0; j &lt; MAX; j++)<BR>
        a[i][j] = 0.0;<BR>
    for (i = 0; i &lt; MAX; i++)        /* put 1's along the diagonal */<BR>
        a[i][i] = 1.0;<BR>
 <BR>
新代码:<BR>
for (i = 0; i &lt; MAX; i++)          /* initialize 2d array to 0's */<BR>
{<BR>
    for (j = 0; j &lt; MAX; j++)<BR>
        a[i][j] = 0.0;<BR>
    a[i][i] = 1.0;                            /* put 1's along the diagonal */<BR>
}<BR>
（7）、Switch语句中根据发生频率来进行case排序<BR>
Switch 可能转化成多种不同算法的代码。其中最常见的是跳转表和比较链/树。当switch用比较链的方式转化时，编译器会产生if-else-if的嵌套代码，并按照顺序进行比较，匹配时就跳转到满足条件的语句执行。所以可以对case的值依照发生的可能性进行排序，把最有可能的放在第一位，这样可以提高性能。此外，在case中推荐使用小的连续的整数，因为在这种情况下，所有的编译器都可以把switch 转化成跳转表。<BR>
不好的代码：<BR>
int days_in_month， short_months， normal_months， long_months；<BR>
。。。。。。<BR>
switch (days_in_month)<BR>
{<BR>
　　case 28:<BR>
　　case 29:<BR>
　　　　short_months ++；<BR>
　　　　break；<BR>
　　case 30:<BR>
　　　　normal_months ++；<BR>
　　　　break；<BR>
　　case 31:<BR>
　　　　long_months ++；<BR>
　　　　break；<BR>
　　default:<BR>
　　　　cout &lt;&lt; &quot;month has fewer than 28 or more than 31 days&quot; &lt;&lt; endl；<BR>
　　　　break；<BR>
}<BR>
 <BR>
推荐的代码：<BR>
int days_in_month， short_months， normal_months， long_months；<BR>
。。。。。。<BR>
switch (days_in_month)<BR>
{<BR>
　　case 31:<BR>
　　　　long_months ++；<BR>
　　　　break；<BR>
　　case 30:<BR>
　　　　normal_months ++；<BR>
　　　　break；<BR>
　　case 28:<BR>
　　case 29:<BR>
　　　　short_months ++；<BR>
　　　　break；<BR>
　　default:<BR>
　　　　cout &lt;&lt; &quot;month has fewer than 28 or more than 31 days&quot; &lt;&lt; endl；<BR>
　　　　break；<BR>
}   <BR>
（8）、将大的switch语句转为嵌套switch语句<BR>
当switch语句中的case标号很多时，为了减少比较的次数，明智的做法是把大switch语句转为嵌套switch语句。把发生频率高的case 标号放在一个switch语句中，并且是嵌套switch语句的最外层，发生相对频率相对低的case标号放在另一个switch语句中。比如，下面的程序段把相对发生频率低的情况放在缺省的case标号内。<BR>
pMsg=ReceiveMessage();<BR>
        switch (pMsg-&gt;type)<BR>
        {<BR>
        case FREQUENT_MSG1:<BR>
        handleFrequentMsg();<BR>
        break;<BR>
        case FREQUENT_MSG2:<BR>
        handleFrequentMsg2();<BR>
        break;<BR>
        。。。。。。<BR>
        case FREQUENT_MSGn:<BR>
        handleFrequentMsgn();<BR>
        break;<BR>
        default:                     //嵌套部分用来处理不经常发生的消息<BR>
        switch (pMsg-&gt;type)<BR>
        {<BR>
        case INFREQUENT_MSG1:<BR>
        handleInfrequentMsg1();<BR>
        break;<BR>
        case INFREQUENT_MSG2:<BR>
        handleInfrequentMsg2();<BR>
        break;<BR>
        。。。。。。<BR>
        case INFREQUENT_MSGm:<BR>
        handleInfrequentMsgm();<BR>
        break;<BR>
        }<BR>
        }<BR>
如果switch中每一种情况下都有很多的工作要做，那么把整个switch语句用一个指向函数指针的表来替换会更加有效，比如下面的switch语句，有三种情况：<BR>
    enum MsgType{Msg1， Msg2， Msg3}<BR>
        switch (ReceiveMessage()<BR>
        {<BR>
        case Msg1;<BR>
        。。。。。。<BR>
        case Msg2;<BR>
        。。。。。<BR>
        case Msg3;<BR>
        。。。。。<BR>
        }<BR>
为了提高执行速度，用下面这段代码来替换这个上面的switch语句。<BR>
        /*准备工作*/<BR>
        int handleMsg1(void);<BR>
        int handleMsg2(void);<BR>
        int handleMsg3(void);<BR>
        /*创建一个函数指针数组*/<BR>
        int (*MsgFunction [])()={handleMsg1， handleMsg2， handleMsg3};<BR>
        /*用下面这行更有效的代码来替换switch语句*/<BR>
        status=MsgFunction[ReceiveMessage()]();<BR>
（9）、循环转置<BR>
有些机器对JNZ(为0转移)有特别的指令处理，速度非常快，如果你的循环对方向不敏感，可以由大向小循环。<BR>
旧代码:<BR>
              for (i = 1; i &lt;= MAX; i++)<BR>
               {<BR>
                             。。。<BR>
                          }<BR>
新代码:<BR>
              i = MAX+1;<BR>
           while (--i)<BR>
                         {<BR>
                           。。。<BR>
                         }<BR>
不过千万注意，如果指针操作使用了i值，这种方法可能引起指针越界的严重错误(i = MAX+1;)。当然你可以通过对i做加减运算来纠正，但是这样就起不到加速的作用，除非类似于以下情况：<BR>
旧代码:<BR>
    char a[MAX+5];<BR>
    for (i = 1; i &lt;= MAX; i++)<BR>
    {<BR>
        *(a+i+4)=0;<BR>
    }<BR>
新代码:<BR>
    i = MAX+1;<BR>
    while (--i)<BR>
    {<BR>
        *(a+i+4)=0;<BR>
}<BR>
（10）、公用代码块<BR>
一些公用处理模块，为了满足各种不同的调用需要，往往在内部采用了大量的if-then-else结构，这样很不好，判断语句如果太复杂，会消耗大量的时间的，应该尽量减少公用代码块的使用。(任何情况下，空间优化和时间优化都是对立的--东楼)。当然，如果仅仅是一个(3==x)之类的简单判断，适当使用一下，也还是允许的。记住，优化永远是追求一种平衡，而不是走极端。<BR>
（11）提升循环的性能<BR>
要提升循环的性能，减少多余的常量计算非常有用（比如，不随循环变化的计算）。<BR>
不好的代码(在for()中包含不变的if())：<BR>
for( i 。。。 )<BR>
{<BR>
　　if( CONSTANT0 )<BR>
　　{<BR>
　　　　DoWork0( i )； // 假设这里不改变CONSTANT0的值<BR>
　　}<BR>
　　else<BR>
　　{<BR>
　　　　DoWork1( i )； // 假设这里不改变CONSTANT0的值<BR>
　　}<BR>
}<BR>
推荐的代码：<BR>
if( CONSTANT0 )<BR>
{<BR>
　　for( i 。。。 )<BR>
　　{<BR>
　　　　DoWork0( i )；<BR>
　　}<BR>
}<BR>
else<BR>
{<BR>
　　for( i 。。。 )<BR>
　　{<BR>
　　　　DoWork1( i )；<BR>
　　}<BR>
} <BR>
如果已经知道if()的值，这样可以避免重复计算。虽然不好的代码中的分支可以简单地预测，但是由于推荐的代码在进入循环前分支已经确定，就可以减少对分支预测的依赖。<BR>
（12）、选择好的无限循环<BR>
在编程中，我们常常需要用到无限循环，常用的两种方法是while (1) 和 for (；；)。这两种方法效果完全一样，但那一种更好呢？然我们看看它们编译后的代码：<BR>
编译前：<BR>
while (1)；<BR>
编译后：<BR>
mov eax，1<BR>
test eax，eax<BR>
je foo+23h<BR>
jmp foo+18h <BR>
编译前：<BR>
for (；；)；<BR>
编译后：<BR>
jmp foo+23h<BR>
显然，for (；；)指令少，不占用寄存器，而且没有判断、跳转，比while (1)好。<BR>
6、提高CPU的并行性<BR>
（1）使用并行代码<BR>
尽可能把长的有依赖的代码链分解成几个可以在流水线执行单元中并行执行的没有依赖的代码链。很多高级语言，包括C++，并不对产生的浮点表达式重新排序，因为那是一个相当复杂的过程。需要注意的是，重排序的代码和原来的代码在代码上一致并不等价于计算结果一致，因为浮点操作缺乏精确度。在一些情况下，这些优化可能导致意料之外的结果。幸运的是，在大部分情况下，最后结果可能只有最不重要的位（即最低位）是错误的。<BR>
不好的代码：<BR>
double a[100]， sum；<BR>
int i；<BR>
sum = 0.0f；<BR>
for (i=0； i&lt;100； i++)<BR>
sum += a[i]；<BR>
 <BR>
推荐的代码：<BR>
double a[100]， sum1， sum2， sum3， sum4， sum；<BR>
int i；<BR>
sum1 = sum2 = sum3 = sum4 = 0.0；<BR>
for (i = 0； i &lt; 100； i += 4)<BR>
{<BR>
　　sum1 += a[i]；<BR>
　　sum2 += a[i+1]；<BR>
　　sum3 += a[i+2]；<BR>
　　sum4 += a[i+3]；<BR>
}<BR>
sum = (sum4+sum3)+(sum1+sum2)； <BR>
　　要注意的是：使用4 路分解是因为这样使用了4段流水线浮点加法，浮点加法的每一个段占用一个时钟周期，保证了最大的资源利用率。<BR>
（2）避免没有必要的读写依赖<BR>
当数据保存到内存时存在读写依赖，即数据必须在正确写入后才能再次读取。虽然AMD Athlon等CPU有加速读写依赖延迟的硬件，允许在要保存的数据被写入内存前读取出来，但是，如果避免了读写依赖并把数据保存在内部寄存器中，速度会更快。在一段很长的又互相依赖的代码链中，避免读写依赖显得尤其重要。如果读写依赖发生在操作数组时，许多编译器不能自动优化代码以避免读写依赖。所以推荐程序员手动去消除读写依赖，举例来说，引进一个可以保存在寄存器中的临时变量。这样可以有很大的性能提升。下面一段代码是一个例子：<BR>
不好的代码：<BR>
float x[VECLEN]， y[VECLEN]， z[VECLEN]；<BR>
。。。。。。<BR>
for (unsigned int k = 1； k &lt; VECLEN； k ++)<BR>
{<BR>
　　x[k] = x[k-1] + y[k]；<BR>
}<BR>
for (k = 1； k &lt;VECLEN； k++)<BR>
{<BR>
　　x[k] = z[k] * (y[k] - x[k-1])；<BR>
}<BR>
推荐的代码：<BR>
float x[VECLEN]， y[VECLEN]， z[VECLEN]；<BR>
。。。。。。<BR>
float t(x[0])；<BR>
for (unsigned int k = 1； k &lt; VECLEN； k ++)<BR>
{<BR>
　　t = t + y[k]；<BR>
　　x[k] = t；<BR>
}<BR>
t = x[0]；<BR>
for (k = 1； k &lt;； VECLEN； k ++)<BR>
{<BR>
　　t = z[k] * (y[k] - t)；<BR>
　　x[k] = t；<BR>
} <BR>
7、循环不变计算<BR>
对于一些不需要循环变量参加运算的计算任务可以把它们放到循环外面，现在许多编译器还是能自己干这件事，不过对于中间使用了变量的算式它们就不敢动了，所以很多情况下你还得自己干。对于那些在循环中调用的函数，凡是没必要执行多次的操作通通提出来，放到一个init函数里，循环前调用。另外尽量减少喂食次数，没必要的话尽量不给它传参，需要循环变量的话让它自己建立一个静态循环变量自己累加，速度会快一点。<BR>
还有就是结构体访问，东楼的经验，凡是在循环里对一个结构体的两个以上的元素执行了访问，就有必要建立中间变量了(结构这样，那C++的对象呢?想想看)，看下面的例子:<BR>
旧代码:<BR>
    total =<BR>
    a-&gt;b-&gt;c[4]-&gt;aardvark +<BR>
    a-&gt;b-&gt;c[4]-&gt;baboon +<BR>
    a-&gt;b-&gt;c[4]-&gt;cheetah +<BR>
    a-&gt;b-&gt;c[4]-&gt;dog;<BR>
新代码:<BR>
    struct animals * temp = a-&gt;b-&gt;c[4];<BR>
    total =<BR>
    temp-&gt;aardvark +<BR>
    temp-&gt;baboon +<BR>
    temp-&gt;cheetah +<BR>
    temp-&gt;dog;<BR>
一些老的C语言编译器不做聚合优化，而符合ANSI规范的新的编译器可以自动完成这个优化，看例子:<BR>
    float a， b， c， d， f， g;<BR>
    。。。<BR>
    a = b / c * d;<BR>
    f = b * g / c;<BR>
这种写法当然要得，但是没有优化<BR>
    float a， b， c， d， f， g;<BR>
    。。。<BR>
    a = b / c * d;<BR>
    f = b / c * g;<BR>
如果这么写的话，一个符合ANSI规范的新的编译器可以只计算b/c一次，然后将结果代入第二个式子，节约了一次除法运算。<BR>
8、函数优化<BR>
 （1）Inline函数<BR>
在C++中，关键字Inline可以被加入到任何函数的声明中。这个关键字请求编译器用函数内部的代码替换所有对于指出的函数的调用。这样做在两个方面快于函数调用：第一，省去了调用指令需要的执行时间；第二，省去了传递变元和传递过程需要的时间。但是使用这种方法在优化程序速度的同时，程序长度变大了，因此需要更多的ROM。使用这种优化在Inline函数频繁调用并且只包含几行代码的时候是最有效的。<BR>
（2）不定义不使用的返回值<BR>
函数定义并不知道函数返回值是否被使用，假如返回值从来不会被用到，应该使用void来明确声明函数不返回任何值。<BR>
（3）减少函数调用参数<BR>
    使用全局变量比函数传递参数更加有效率。这样做去除了函数调用参数入栈和函数完成后参数出栈所需要的时间。然而决定使用全局变量会影响程序的模块化和重入，故要慎重使用。<BR>
（4）所有函数都应该有原型定义<BR>
一般来说，所有函数都应该有原型定义。原型定义可以传达给编译器更多的可能用于优化的信息。<BR>
（5）尽可能使用常量(const)<BR>
尽可能使用常量(const)。C++ 标准规定，如果一个const声明的对象的地址不被获取，允许编译器不对它分配储存空间。这样可以使代码更有效率，而且可以生成更好的代码。<BR>
（6）把本地函数声明为静态的(static)<BR>
　　如果一个函数只在实现它的文件中被使用，把它声明为静态的(static)以强制使用内部连接。否则，默认的情况下会把函数定义为外部连接。这样可能会影响某些编译器的优化&#8212;&#8212;比如，自动内联。<BR>
9、采用递归<BR>
与LISP之类的语言不同，C语言一开始就病态地喜欢用重复代码循环，许多C程序员都是除非算法要求，坚决不用递归。事实上，C编译器们对优化递归调用一点都不反感，相反，它们还很喜欢干这件事。只有在递归函数需要传递大量参数，可能造成瓶颈的时候，才应该使用循环代码，其他时候，还是用递归好些。<BR>
10、变量<BR>
（1）register变量<BR>
在声明局部变量的时候可以使用register关键字。这就使得编译器把变量放入一个多用途的寄存器中，而不是在堆栈中，合理使用这种方法可以提高执行速度。函数调用越是频繁，越是可能提高代码的速度。<BR>
在最内层循环避免使用全局变量和静态变量，除非你能确定它在循环周期中不会动态变化，大多数编译器优化变量都只有一个办法，就是将他们置成寄存器变量，而对于动态变量，它们干脆放弃对整个表达式的优化。尽量避免把一个变量地址传递给另一个函数，虽然这个还很常用。C语言的编译器们总是先假定每一个函数的变量都是内部变量，这是由它的机制决定的，在这种情况下，它们的优化完成得最好。但是，一旦一个变量有可能被别的函数改变，这帮兄弟就再也不敢把变量放到寄存器里了，严重影响速度。看例子：<BR>
a = b();<BR>
c(&amp;d);<BR>
因为d的地址被c函数使用，有可能被改变，编译器不敢把它长时间的放在寄存器里，一旦运行到c(&amp;d)，编译器就把它放回内存，如果在循环里，会造成N次频繁的在内存和寄存器之间读写d的动作，众所周知，CPU在系统总线上的读写速度慢得很。比如你的赛杨300，CPU主频300，总线速度最多66M，为了一个总线读，CPU可能要等4-5个周期，得。。得。。得。。想起来都打颤。<BR>
（2）、同时声明多个变量优于单独声明变量<BR>
（3）、短变量名优于长变量名，应尽量使变量名短一点<BR>
（4）、在循环开始前声明变量<BR>
11、使用嵌套的if结构<BR>
在if结构中如果要判断的并列条件较多，最好将它们拆分成多个if结构，然后嵌套在一起，这样可以避免无谓的判断。<BR>
<BR>
说明：<BR>
上面的优化方案由王全明收集整理。很多资料来源与网上，出处不祥，在此对所有作者一并致谢！<BR>
该方案主要是考虑到在嵌入式开发中对程序执行速度的要求特别高，所以该方案主要是为了优化程序的执行速度。<BR>
注意：优化是有侧重点的，优化是一门平衡的艺术，它往往要以牺牲程序的可读性或者增加代码长度为代价。
</DD>
<DT>C语言高性能编程2</DT>
<!--property:date_created=1517388764-->
<!--property:date_modified=1517388839-->
<DD>
大概所有学习C语言的初学者，都被前辈说过，C语言是世界上接近最速的编程语言，当然这并不是吹牛，也并不是贬低其他语言，诚然非C语言能写出高速度的代码，但是C语言更容易写出高速的程序(高速不代表高效)，然而再好的工具，在外行人手中也只能是黯淡没落。<BR>
对于现代编译器，现代CPU而言，我们要尽量迎合CPU的设计(比如架构和处理指令的方式等)，虽然编译器是为程序员服务，并且在尽它最大的能力来优化程序员写出的代码，但是毕竟它还没有脱离电子的范畴，如果我们的代码不能让编译器理解，编译器无法帮我们优化代码，那么我们就无法写出一个高速的程序。<BR>
对于此，我们可以暂且忽略CPU的设计，因为我们在层面上只能考虑如何迎合编译器的优化规则，而CPU则是语言以及编译器的事情了。<BR>
提高程序的速度，就C语言而言可以有这几种方法:<BR>
首先还是要设计合理的大纲，正所谓一个程序最大的性能提升就是它第一次运行的时候<BR>
要避免连续的函数调用。<BR>
消除不必要的存储器使用(并非推荐使用register)<BR>
使用循环展开技巧，一般编译器的优化选项能自动帮你修改代码成循环展开<BR>
对于一个操作的核心耗时部分，通过重新组合技术来提高速度<BR>
多采用几种风格的写法，而不是直观的认为，因为计算机的想法和你是不一样的<BR>
注：随着编译器的版本更新，即使不开启优化选项，自带的编译器优化依旧能够为我们编写的代码提供一部分优化，这便是不使用老版本编译器的原因，虽然作为一个程序员不应该太依赖于编译器，但是我认为，时代在进步，信息量正在无限的膨胀，但是人类的大脑以及精力在一个大时代内是有限的，换句话说对于普通人而言我们的记忆是有限的，我们不应该把精力放在前人已经做完的事情上，而是要站在巨人的肩膀上向更远处眺望，如此我们应该充分利用工具来帮助我们实现一些既有的功能，而程序员应该更 专注于发现新的思路，以及想法，在图灵测试尚未有人打破之前，程序员依赖编译器并不是一件错误的事情。<BR>
对于当下的编译器，以GCC(GCC不仅仅是一个编译器，但这里将它当成编译器的代名词)为例，-O2是一个为大众所接受的优化等级，对于其他编译器，一般程序员可以选择使用由Google和Apple联合开发的编译器clang也是一个很好的选择， 在-O2的优化等级下，GCC一般情况下能够自动执行循环展开优化，<BR>
开始.<BR>
?<BR>
/*struct.h*/<BR>
#include &lt;stdio.h&gt;<BR>
typedef struct me{<BR>
  int  value;<BR>
  struct me* next;<BR>
}data_t;<BR>
 <BR>
typedef struct{<BR>
  int index;<BR>
  data_t* storage;<BR>
}block; <BR>
为了测试方便我们首先定义了两个结构体，分别是:<BR>
block代表一个块，每个块都有一个序号(int)，一个数据域data_t<BR>
data_t代表一个数据域，原型是一个链表，每个data_t对象中包含一个数据和一个指针。<BR>
?<BR>
/*main.c*/<BR>
#include &quot;struct.h&quot;<BR>
#define ARR_SIZE 10<BR>
static inline int get_len(const data_t* data)<BR>
{<BR>
 int len = 0;<BR>
 <BR>
 if(!data)<BR>
  fprintf(stderr,&quot;The data in %p is NULL\n&quot;,data);<BR>
 else<BR>
  while(!data-&gt;next)<BR>
  {<BR>
   ++len;<BR>
   data = data-&gt;next;<BR>
  }<BR>
 return len;<BR>
}<BR>
 <BR>
static inline void mix_cal(const block* process, int result[])<BR>
{<BR>
 for(int i = 0;i &lt; get_len(process-&gt;storage);++i)<BR>
 {<BR>
  *result += (process-&gt;storage)[i];<BR>
 }<BR>
}<BR>
此时我们得到了两个测试函数，get_len和mix_cal分别用来得到data_t长度，以及计算数据域的总和。<BR>
?<BR>
<BR>
/*main.c*/<BR>
int main(void)<BR>
{<BR>
 block* block_in_all[ARR_SIZE] = { NULL };<BR>
 int result_in_all[ARR_SIZE] = { 0 };<BR>
 /*<BR>
 * 假设生成了许多的`block`类型对象<BR>
 * 将许多的`block`放置在一个数组中，每个元素类型为`block*`<BR>
 * 每个block对象中都包含非空的data_t类型的数据域<BR>
 */<BR>
 for(int i = 0;i &lt; ARR_SIZE;++i)<BR>
 {<BR>
  mix_cal(block_in_all[i], result_in_all+i);<BR>
 }<BR>
 for(int i = 0;i &lt; ARR_SIZE;++i)<BR>
 {<BR>
  printf(&quot;The %dth block have the total %d data\n&quot;,<BR>
     block_in_all[i]-&gt;index, result_in_all[i]);<BR>
 }<BR>
 <BR>
 return 0;<BR>
}<BR>
耐心读完上述的代码，它是用来求和的，求一个域中的所有元素的和。仔细分析一下，很容易就能看见一些缺点，最大的莫过于在mix_cal函数中对于get_len函数的调用，在此处看来十分明显，但是我们在编写程序的时候是否能够注意到这个问题呢？<BR>
对于一些不必要的函数调用我们要做的便是将他们提取出来，使用临时变量是一个很好的办法，因为在编译器的帮助下临时变量在允许的情况下能够充分的利用CPU的寄存器。之所以是允许的情况下，是因为寄存器的数量并不多，而编译器在寄存器的使用上需要考虑许多的复杂因素，故并不是每次使用临时变量都能加入寄存器。但这并不妨碍我们提升程序的性能。<BR>
在此处，我们应该将for循环中的判断语句里的get_len函数提取出来，在外部使用一个临时变量接收结果，而不是在循环中一直调用该函数。<BR>
?<BR>
1<BR>
int len = get_len(process-&gt;storage);<BR>
.<BR>
依旧是上方的代码，我们来讲述一下，循环展开。<BR>
对于mix_cal函数，我们或者说编译器可以如何提升它的速度呢？我们说过一点的小改变都可能对一个程序的最终代码产生极大的影响，对此最常用的便是尝试，前人之路早已铺好，不需要重复造轮子了。<BR>
循环展开:<BR>
 <BR>
?<BR>
<BR>
int reality = len - 1, i;<BR>
for(i = 0;i &lt; reality;i+=2)<BR>
{<BR>
 *result = *result + (process-&gt;storage)[i] <BR>
     + (process-&gt;storage)[i+1];<BR>
}<BR>
for(;i &lt; len;++i)<BR>
{<BR>
 *result += (process-&gt;storage)[i];<BR>
}<BR>
这就是循环展开中的2次循环展开，同样还有n次循环展开。<BR>
同样，在刚才提到过寄存器的使用以及减少不必要的开销，在此程序中对于(process-&gt;storage)[i]这样的存储器位置解引用太过浪费，我们总是将其优化成本低临时变量的使用<BR>
?<BR>
1<BR>
data* local_data = process-&gt;storage;<BR>
这将为程序带来十分可观的节约，虽然这些工作在编译器的优化中都能包括，但是一旦我们的代码难以被编译器所理解(虽然编译器的升级最大的目的就是提升优化效果)，那么我们很可能得到一个性能不够可观的程序。所以当我们并不是特别紧凑的时候，可以将这些工作当成我们的本分来做，而不是交给编译器来做。<BR>
以及对于外部存储位置 result 我们在此处也是存在着浪费，同样我们应该使用一个临时变量来存储总和，而不是每次得到结果便对它进行解引用操作。<BR>
?<BR>
<BR>
int local_result = 0;<BR>
/*...*/<BR>
local_result = local_result + local_data[i] + local_data[i+1];<BR>
/*...*/<BR>
*result = local_result;<BR>
在上方我们可以看见循环展开被称作2次循环展开，那么自然可以推断有n次循环展开，自然是有的，对于一个n次循环展开的式子我们有一个简便的上界确定公式即:<BR>
?<BR>
1<BR>
reality = len - n + 1;<BR>
至于展开几次最好，依然是视环境而定。 故最终的版本应该为：<BR>
?<BR>
<BR>
static inline void mix_cal(const block* process, int result[])<BR>
{<BR>
 int local_result = 0;<BR>
 int len = get_len(process-&gt;storage);<BR>
 int reality = len - 1, i;<BR>
 data* local_data = process-&gt;storage;<BR>
 <BR>
 for(i = 0;i &lt; reality;i+=2)<BR>
  local_result += local_data[i] + local_data[i+1];<BR>
 for(;i &lt; len;++i)<BR>
  local_result += local_data[i];<BR>
 <BR>
 *result = local_result;<BR>
}<BR>
解释：循环展开将元素相加分为两个部分，第一部分每次加两个元素，由于如此做会剩余元素没有加，故在第二部分将剩下的元素都加起来。<BR>
. 还有一种叫做重新组合的技巧，即为让一个表达式中的运算数自由组合，组合出最快速的一种，但是这种方法未曾试验过。故不提及。<BR>
. 对于条件分支预测错误造成的时间损耗，称之为惩罚，最通俗的说法，就是当你编写的代码中含有条件分支的时候，处理器会选择去预判某一个分支是此次正确的支路，这样可以避免修改任何实际的寄存器和存储器，一直到确定了实际结果，要是不对，那就惨了，这段时间做的事情都白费了。但是也不必过分的关心这种条件分支的预测，这也是我放在最后说的意义所在。<BR>
这里有两种较为客观的方法，一种被称为命令式，一种被称为功能式<BR>
命令式：<BR>
?<BR>
<BR>
for(int i = 0;i &lt; n;++i)<BR>
{<BR>
 if(a[i] &gt; b[i]){<BR>
  int temp = a[i];<BR>
  a[i] = b[i];<BR>
  b[i] = temp;<BR>
 }<BR>
}<BR>
功能式：<BR>
?<BR>
<BR>
int min, max;<BR>
for(int i = 0;i &lt; n;++i)<BR>
{ <BR>
 min = a[i] &lt; b[i] ? a[i] : b[i];<BR>
 max = a[i] &lt; b[i] ? b[i] : a[i];<BR>
 a[i] = min;<BR>
 b[i] = max;<BR>
}<BR>
<BR>
很清晰的一个例子，明显看出来，前者对于不同情况所作的程序步数明显不同，而后者无论什么情况都是相同的程序步。<BR>
两个形式的好处前者对于可预测数据来说，是一个很好的模型，后者则是中庸之道，什么是可预测不可预测，比如一个数是负数还是正数这就是不可预测的，用前面那个代码会有很大的惩罚。<BR>
. 多路并行的技巧也是一个很重要的思路，可能在很多人眼中看来，两条语句依次写出和合并的效果一定是一样。但是多路并行有一个缺点就是对寄存器的数量有所要求，当寄存器不够时(称为溢出)，性能不升反降。同样是对于循环展开，此次使用四次循环展开加二路并行：<BR>
?<BR>
<BR>
for(i = 0;i &lt; reality;i+=4){<BR>
 local_result_1 += local_data[i] + local_data[i+1];<BR>
 local_result_2 += local_data[i+2] + local_data[i+3];<BR>
}//也可以分成四路并行，每一路存一个。这种做法充分利用了CPU流水线的性能<BR>
for(;i &lt; len;++i)<BR>
 local_result_1 += local_data[i];<BR>
 <BR>
*result = local_result_1 + local_result_2;<BR>
Tips:<BR>
上文中写到的函数大都带有static inline关键字，这是何意？首先我们要确定一件事情，对于非工程的单文件而言，static函数并没有什么意义(意义指的是对于可见性而言，并非说它一无是处)，许多人对于static函数感到茫然的原因在于:我明明将一个函数声明定义成static类型了，但是我还是可以在别的文件中访问到啊！<BR>
其实这是因为你根本就没有理解C语言工程这个意思，大部分人是这么测试的:<BR>
首先在一个文件夹里创建两个文件 test_static.c和static.h:<BR>
?<BR>
<BR>
/*static.h*/<BR>
 #ifndef STATIC_H<BR>
 #define STATIC_H<BR>
 static void test(void);<BR>
 <BR>
 static void test(void);<BR>
 {<BR>
  printf(&quot;Hello World!\n&quot;);<BR>
 }<BR>
 #endif<BR>
...<BR>
 <BR>
 /*test_static.c*/<BR>
 #include &lt;stdio.h&gt;<BR>
 #include &quot;static.h&quot;<BR>
 <BR>
 void test(void);<BR>
 int main(void)<BR>
 {<BR>
  test();   //编译通过，可以运行。<BR>
  return 0;<BR>
 }<BR>
然后编译运行，发现可以通过啊！！标准怎么说在其他文件中不可见？而把static.h去掉#include之后发现报错test undefined，瞬间初学者就凌乱了。<BR>
好吧，实际上是前辈们以及教材的错，因为从始至终，所有外界现象都告诉我们C程序是独立的一个一个文件组成的，但是并没有告诉我们要先将他们弄成一个工程！此处如果是使用Visual Studio学习C语言的可能会对工程这个概念理解的稍微好一些，虽然不推荐使用 VS 学习C语言。<BR>
你想要实现static函数仅在本文件可见的效果，请你先补习一下工程这个概念，对于任何可见或者不可见的概念而言都是建立在一个工程内而言，而不是像上方的代码，使用#include来表示，你都#include了，那还有什么可见不可见的当然都可见了。所以一个static函数可见于不可见是基于一个个工程里的所有C语言源文件而言的。所以你将常看见前辈们这么回答你的提问:<BR>
?<BR>
<BR>
/*static.h*/<BR>
 #ifndef STATIC_H<BR>
 #define STATIC_H<BR>
 static void test(void);<BR>
 <BR>
 static void test(void);<BR>
 {<BR>
  printf(&quot;Hello World!\n&quot;);<BR>
 }<BR>
 #endif<BR>
...<BR>
 <BR>
 /*test_static.c*/<BR>
 #include &lt;stdio.h&gt;<BR>
 <BR>
 void test(void);<BR>
 int main(void)<BR>
 {<BR>
  test();   //报错，因为test是static函数。<BR>
  return 0;<BR>
 }<BR>
发现了吗？在上方代码中，少了一行#include &quot;static.h&quot;但是这个代码依旧可行，因为这两个文件是建立在同一个工程里的，而不是在一个文件夹中随意新建两个源文件这么简单，你可以使用各个IDE的工程功能来进行测试。<BR>
回到正题，在这里稍微提一下static对函数的某些作用，它可以让函数放在一个静态的空间中，而不是栈里，这是的它的调用更加快速，经常与inline关键字一起使用，为的就是让函数更加快。但是有利有弊，可以自己权衡一下。<BR>
注：存储器山就是对于不同步长不同大小文件的读取速率的三维坐标图，形似一座山，z轴为速率，x轴为步长，y轴为文件大小（字节），某些主流的测评软件便是这个原理(将存储器山的图像进行一下简单的变换，就能得到哪些软件呈现的效果图像)。<BR>
上文提到过，任何一点小改动，都有可能让程序的性能发生很大的变动，这是为什么？<BR>
当时我们并未深究，由于我们惯性的认为计算机的运作方式和人类的运作方式一致，也在过往的经验中认为计算机一定是在任何方面超越人类的存在，但是实际上，计算机除了在重复计算方面比人类的速度要快速以外，其他方面远远落后于人类的大脑，即便是我们最稀疏平常的视觉识别(看东西识别物体)，在计算机看来都是一门极其高深的领域，所以我们现在的时代的计算机还处于起步状态，在这种时代里，程序员的作用是无可替代的，同样程序员的一举一动关乎计算机的命运。<BR>
可能在很多的方面，都已经接触了一台计算机的主要组成构造，和程序员最息息相关的便是CPU，主存以及硬盘了，可能到现在为止很多程序员仍然认为编程序和这些存储器有什么关系？然而一个程序员，特别是编写C语言程序的程序员，最大的影响因素便来自于此，在计算机的存储器结构中，分为四种层次:<BR>
CPU寄存器、高速缓存器、主存、硬盘。<BR>
但是有没有想过，为什么计算机存储器系统要分成这四层结构呢？我们知道，上述四种存储器的读写速度依次降低，我们为什么不选择一种速度中庸的，价格也中庸的材料，制造所有层次的存储器呢？<BR>
有人给出的解释是，一个编写良好的程序总是倾向于访问层次更高的存储器，而对于现在的技术，价格高昂而无法大量制造的高速存储器来说，我们可以选择按层次分配构造，让我们以最低的成本的存储器达到使用最高的速度存储器的效果。<BR>
就像是在自己的计算机上，当我们打开一个很笨重的应用程序后，会发现，下一次再打开的时候可能会更快，就像以前历史遗留的一个问题 Visual Studio 2008 在 Windows XP 上，第一次打开总是十分卡顿，但是当关闭程序之后第二次打开却是很流畅。在参考书中，提到过两个评价程序速度的关键点：时间局部性和空间局部性 。<BR>
时间局部性：在访问过某块存储器之后的不久的将来，很可能会再次访问它<BR>
空间局部性：在访问过某块存储器之后的不就的将来，很可能访问其邻近的存储器位置。<BR>
良好的局部性改进一般能很好的提升程序的性能。<BR>
所谓局部性就是当我们使用过某些资源后，这些资源总是以一种形式存储在更高级更方便的存储器当中，让最近一次的存取请求能够更加有效率的进行。<BR>
打个不太贴切的比喻，假设计算机是一个家，CPU是一个人，想象一下这个家中的所有物品都是井然有序的，这个人想要工作必然会需要工作物品，所以他需要从某些地方拿来，用完以后再放回去，这些地方就是存储器，但是过了一段时间发现这么做太浪费时间，有时候某些东西太远了，所以，人想把它把它放在离自己更进的地方，这样自己的效率就高很多，如果这个东西一段时间内不再用，则把它放回原处，留出位置给更需要的工作物品，于是形成了越常使用的物品离人越近的现象。这便是计算机存储器的分层结构的意义。<BR>
而对于一个有良好局部性的程序而言，我们总能在离自己最近的地方找到我们所需要的数据，回到计算机：我们知道计算机的存储器是分层结构的，即每一层对应着不同的读写速度等级(CPU寄存器 &gt; 高速缓存 &gt; 主存 &gt; 硬盘)，而我们的程序总是按照从左至右的顺序依次查找，每次找到一个所需要数据，不出意外，总是将其移动到上一层次的存储器中存储，以便下次更高速的访问，我们称这种行为叫做 命中 。越好的程序，越能将当时所需的数据放在越靠近左边的地方。这便是局部性的意义所在。<BR>
当然，存储器如此分层也是出于无奈，在处理器的速度和存储器的速度实在差距的情况下只有如此做才能让处理器更加充分的利用，而不至于等待存储器读写而空闲，也许某一天，当内存的位价和普通硬盘不相上下或者差距不多的时候，也许内存就是硬盘了。而当今也有人使用某些特殊的软件在实现这个功能，凭着自己计算机上大容量的内存，分割出来当作硬盘使用，存取速度让硬盘望尘莫及。<BR>
局部性：<BR>
前方提到了局部性，局部性体现在了，当步长越大，空间局部性越低，大多数情况下会造成性能降低，比如最常见的多维数组循环(我鲜少使用多维数组的原因之一便在于此)，前面说过多维数组实际上只是数个一维数组的包装而已，C语言中并没有真正的多维数组，而是将其解读成内存中的一维的连续内存，但是当我们遍历它的时候，C语言为了不让我们被底层实现所困扰，所以生成了多维数组遍历的假象：<BR>
让我们重温一遍&quot;多维数组&quot;：<BR>
?<BR>
<BR>
#include &lt;stdio.h&gt; <BR>
int main(void)<BR>
{<BR>
 int dim_1_arr[4] = {1, 2, 3, 4};<BR>
 int dim_2_arr[2][2] = { {1, 2}, {3, 4} };<BR>
 int result_1 = 0;<BR>
 int result_2 = 0;<BR>
 <BR>
 for(int i = 0;i &lt; 4;++i)<BR>
  result_1 += dim_1_arr[i];<BR>
 return 0;<BR>
}<BR>
此例中，对一维数组进行步长为 1 遍历求和，假设内存中数组的起始位置是 0<BR>
?<BR>
<BR>
0 =&gt; 4 =&gt; 8 =&gt; 12<BR>
 <BR>
for(int j = 0;j &lt; 3;++j){<BR>
 for(int i = 0;i &lt; 3;++i){<BR>
  result_2 += dim_2_arr[i][j];<BR>
 }<BR>
}<BR>
此例中，我们的步长是多少呢？我们来看一下<BR>
?<BR>
1<BR>
0 =&gt; 8 =&gt; 4 =&gt; 12<BR>
可以很清晰的看出两段不同代码之间的跳跃，为什么？观察到多维数组的遍历中我们和平时的做法有些不同，是先对i进行遍历，再对j进行遍历，这就导致了程序必须在内存块中无规律的跳动，这里的无规律是计算机认为的无规律，虽然在我们看来的确是有迹可寻，优秀的编译器能够对它进行优化处理。就事论事，即这段程序的空间局部性比较差，对于一个在内存中大幅度跳跃，无规律跳跃的程序都将影响程序的性能。这个判定对于一个连续的内存块来说是很重要的，比如C语言中的结构体。<BR>
实际上C语言也是能够面向对象的，但是十分复杂，就像拿着棒子织衣服一样。而C语言的机构体能够让我们在一定程度上初步理解对象这个概念，因为它是一个完整的个体，虽然对外界毫不设防。<BR>
对于结构体：<BR>
?<BR>
<BR>
#define VECTOR 4<BR>
typedef struct{<BR>
  double salary;<BR>
  int index[4];<BR>
}test_data;<BR>
 <BR>
int main(void)<BR>
{<BR>
 int result_1 = 0;<BR>
 int result_2 = 0;<BR>
 test_data dim_1_arr[VECTOR];<BR>
 /* ...填充数据 */<BR>
 <BR>
 for(int i = 0;i &lt; VECTOR;++i)<BR>
 { <BR>
  for(int j = 0;j &lt; 4;++j)<BR>
   result_1 += dim_1_arr[i].index[j];<BR>
 }/* for loop 1 */<BR>
 <BR>
 for(int j = 0;j &lt; 4;++j)<BR>
 {<BR>
  for(int i = 0;i &lt; VECTOR;++i)<BR>
   result_2 += dim_1_arr[i].index[j];<BR>
 }/* for loop 2 */<BR>
 return 0;<BR>
} <BR>
还是和上方一样，假设 dim_1_arr 起始位置为 0<BR>
?<BR>
<BR>
for loop 1：<BR>
 <BR>
8 =&gt; 12 =&gt; 16 =&gt; 20 ==&gt; 32 =&gt; 36 =&gt; 40 =&gt; 44 ==&gt; ...<BR>
 <BR>
for loop 2：<BR>
 <BR>
8 =&gt; 32 =&gt; 56 =&gt; 80 ==&gt; 12 =&gt; 36 =&gt; 60 =&gt; 84 ==&gt; ...<BR>
从上方不完整的比较来看，loop 1 相对于 loop 2 来说有更好的空间局部性，很明显在 loop 2 中，CPU读取是在无规律的内存位置跳跃，而 loop 1 则是以单调递增的趋势向前(这里的向前指的是直观上的向前)读取内存。<BR>
在此处回顾一下C语言的结构体性质与知识：<BR>
对于任意一个完整定义的结构体，每一个对象所占有的内存大小都符合内存对齐的规则。<BR>
对于结构体内的各个成员而言，其相对于对象存储地址起始的距离，称为偏移量。<BR>
解释：<BR>
内存对齐便是对于一个结构体而言，其所占内存大小总是最大成员的整数倍，其中最大成员指的是最基本成员，即：<BR>
?<BR>
<BR>
typedef struct{<BR>
  test_data test_1;<BR>
  int  test_2;<BR>
 }test_data_2;<BR>
 <BR>
 /*...*/<BR>
 printf(&quot;The size of test_data_2 = %d\n&quot;,sizeof(test_data_2));<BR>
 /*...*/<BR>
` 输出： The size of test_data_2 = 32 `<BR>
 <BR>
 typedef struct{<BR>
   int index[4];<BR>
   int store_1;<BR>
   int store_2;<BR>
 }test_data_3;<BR>
 typedef struct{<BR>
   test_data_3 test_3;<BR>
   int   test_4;<BR>
 }test_data_4;<BR>
 <BR>
 /*...*/<BR>
 printf(&quot;The size of test_data_4 = %d\n&quot;,sizeof(test_data_4));<BR>
 /*...*/<BR>
` 输出：<BR>
?<BR>
1<BR>
The size of test_data_2 = 28`<BR>
仔细对比`test_data_3`与`test_data`的差异，可以发现不同处，在前者的内部包含了一个`double`类型的成员，在我的机器上它的长度为 `8` ，后者的内部包含了两个`int`类型的成员，每个长度为 `4`，但是他们的长度在直观上是一样的！但是真正在使用的时候我们才能察觉到其中的差异，这就是我所说的**最基本成员**的意义所在。虽然我们在使用结构体的时候，能够将其当作一个整体，但是实际上他们与内建(build-in)的类型还是有一些差异的。<BR>
偏移量通俗地说，就是该成员起始地址距离起始位置的长度，在结构体中，C语言是怎么为结构体分配设定大小的呢？除了内存对齐外，还需要考虑定义结构体时，其中成员的声明顺序，换句话说，谁首先声明，谁的位置就靠前。而某个成员的偏移量代表着其起始位置减去其所属对象的起始位置，(此处需要注意的是，两个毫不相干的指针相减所得到的结果是无意义的，只有当两个指针同在一个作用域内时，减法才是有意义的，为了避免潜在的错误，我们要谨慎使用指针减法操作)。<BR>
就此回过头去再看看上方的 loop 解释，应该能够理解到，那些数字是通过偏移量来进行计算得到的。<BR>
之所以没有详细的介绍时间局部性是因为，对于时间局部性而言，其最大的影响因素便是操作区域的大小，比如我们操作的数组或者文件的大小，越小时间局部性越好，试想一下对于一个小的文件和大的文件，我们更容易操作到同一块地方多次的，必定是小的文件。而操作文件的大小有时候并不能很好得成为我们的操作因素，故只能多关注空间局部性。<BR>
高速缓存器：<BR>
在前方提到了，一般情况下，局部性好的程序能够让程序比局部性差的程序更有效率，而对于局部变量而言，一个好的编译器总是尽可能的将之优化，使其能充分使用CPU寄存器,那么寄存器的下方,也就是速度最接近寄存器的,便是所谓的高速缓存器了，对于高速缓存器而言，其最大的功效便是缓冲，缓冲有两层意思：<BR>
缓存数据，使下一次需要的数据尽可能的“靠近”CPU，此处的靠近并不是物理意义上的距离靠近。<BR>
缓冲一下CPU于存储器巨大的速度差距，防止CPU空闲浪费。<BR>
对于现在的计算机而言，CPU基本都是三层缓存：一级缓存(L1),二级缓存(L2),三级缓存(L3)，可以通过 CPU-Z(Windows) / Mac OS系统报告 来查看自己的CPU缓存，在软件中我们能够看到，在一级缓存中会分为两个部分 ：一级数据，一级指令，这代表着只读写数据，只读写指令，这样分开的意义在于处理器能够同时处理一个数据和一个指令，上述所说的都是对于一个CPU核而言的，也就是说当CPU是多核的时候，那就有多个这种“功能集合(L1+L2)”。二级缓存则与一级缓存同在一个核中，每个核都拥有自己的二级缓存，最后所有核共享唯一一个(L3)<BR>
总的来说，对于高速缓存器来说，一般分为三层，第一层比较特殊由独立的两个部分组成，第二层第三层则是各自独立一体并未区分功能(既存数据又存指令)，而第一层和第二层则是每个核单独享有不同的缓存器，第三层则是各个核共享一个层，所以我们经常看见在个人计算机上，L3的大小经常是以MB为单位的，而第一层则多以KB甚至是Byte为单位。<BR>
在实际中，喜欢研究计算机的人经常会在一些专业软件中看见自己的CPU配置，在缓存一栏的一级和二级中总能看见2 x 32 KBytes之类的参数，32代表的就是某级的缓存大小，而前方的2则是核数，即有几个核便有乘多少，和之前所说的一致。<BR>
高速缓存器的各个层依然遵守逐步降速的规律，即读取周期 L1 &lt; L2 &lt; L3，而影响较大的便是上文提到的的命中率，我们知道越上层的高速缓存器总是将下层的存储器映射在自己的存储器中，而按照逻辑推断，上层的实际空间比下层的要小，因为上层的空间更加宝贵速度更快，这就导致我们无法将下层的空间一一对应的映射到上层里，那么我们就想到一个办法，并不是将下层存储器的内容完全映射到上层，而是上层有选择性的将下层的部分内容抽取到上层，这便是不命中之后的操作。<BR>
对于CPU从存储器中读取数据这个操作，如果我们使用了高速缓存以及内存这两个概念，那么就会有一个延伸概念，命中。而对于这个概念只有两种情况，命中或者不命中。而对于一个初始化的高速缓存器，它一定是空的，也许在物理意义上它并不是空，但是实际上在程序看来它的确是空的，为了区分这个，高速缓存器专门使用了一个位(bit)来表示此组是否有效(即是否为空)，既然它是空的那么，我们第一次无论如何都无法命中数据，这时候该层的高速缓存器就会向下一层，在该层中寻找所要的数据，每次要向下一层申请寻找的行为一般称为惩罚，而当我们从存储器中将所需的数据加载到高速缓存器中的时候，我们便开始了运算，而一切关于高速缓存器效率的改进都集中在命中率的提升。<BR>
假设有一个数组需要操作，由于数组是一个连续的内存空间，对其进行步长为1的操作拥有很好的空间局部性，那么可以当成一个很好的例子，在高速缓存器看来读取一个有n(n&gt;N)个元素的数组vector并不是一次性读完，而是分次读取，如果读取了k次那么至少有k次不命中，这是不可避免的，而对于读取的数据也不一定是我们需要的，用书上的例子来说：<BR>
vector:|[0]|[1]|[2]|[3]|[]|[]|[]|[]|[]|[]|[]|<BR>
假设操作数组的每一个元素，我们一次读取三个内存的值，类型为int，因为原理都一样。那么在初始化时候，高速缓存器为空，在第一次操作的时候，读取了四个(如上所示)，此时一定经过了一次 不命中 。<BR>
很好理解，因为缓存器空，所以第一次操作必然不命中，所以我们需要向下级存储器读取我们需要的数据，那么第二访问高速缓存的时候，可以命中`vector[0]`，依次命中后续两个，直到需要`vector[4]`，出现了不命中，那么我们就需要重复上一步，再次读取三个数据，依次类推直到结束。`vector:|[0]|[1]|[2]|[3]|[4]|[5]|[6]|[7]|[]|[]|[]|`<BR>
现在我们能够从一定层面上解释为什么局部性好的程序比局部性差的程序要有更好的效率了，原因就在对于高速缓存器的利用，**首先反复利用本地临时变量能够充分的调用高速缓存器的功能做到读写的最优化，其次步长为越小也越能尽最大的能力发挥高速缓存器读取的数据**，在这点上再回过头思考多维数组的遍历并进行操作，如果没有考虑空间局部性(即先操作大块，再操作小块)，那么在高速缓存器中，它的不命中率令人发指，这也是操作不当效率低的原因。<BR>
另一方面，对于不同步长而言，其影响的也是高速缓存器的命中率，还是上方的vector<BR>
    步长       | 1 | 2 | 3 | 4 | 5 |<BR>
    不命中/命中 |1/4|1/2|2/3|1/1|1/1|<BR>
可以看出来，对于步长而言，当到了一定的上限以后，每次的请求都会不命中，那么这时候本层的高速缓存器相当于作废，时间全都耗费在下层数据传送到上层的时间，因为每次读取都是不命中，可以利用上方的例子自己试着推理一下。<BR>
以上所说的每次读取下一级别存储器数据的时候，都是按照内存对齐，来读取的，如果你的内存数据，例如读取结构体时，没有放在内存对齐的位置(此处所说的内存对齐位置是以每次该级别存储器读取的大小为对齐倍数，而不是结构体在内存中存储时的内存对齐位置)，那么会将该位置的前后补齐倍数的起始位置来读取<BR>
    下一级别存储器     0 1 2 3 4 5 6 7 8 9 A B C D E F<BR>
    结构体数据存放位置在 4~F<BR>
    每次该级别的存储器读取 12个数据<BR>
    那么本次由于结构体存放的没有对齐到提取的内存位置，所有提取的可能会是 0~B<BR>
也就意味着，并不是每次缓存读取都是如此的完美，恰好都从内存中数据的首部开始读取，而是整片根据内存倍数进行读取。
</DD>
</DL>

</DD>
<DT>Tensorflow</DT>
<!--property:date_created=1517217182-->
<!--property:date_modified=1517217182-->
<DD>
<DL>
<DT>编译</DT>
<!--property:date_created=1517217190-->
<!--property:date_modified=1517222466-->
<DD>
cmake .. -A x64 -DCMAKE_BUILD_TYPE=Release <BR>
More? -DSWIG_EXECUTABLE=E:/code/tensorflow/swigwin-3.0.12/swig.exe <BR>
More? -DPYTHON_WXECUTABLE=D:/Program Files/Anaconda3/python.exe <BR>
More? -DPYTHON_LIBRARYS=D:/Program Files/Anaconda3/libs/python35.lib <BR>
More? -Dtensorflow_ENABLE_GPU=ON <BR>
More? -DCUDNN_HOME=&quot;D:/cudnn-9.1-windows10-x64-v7/cuda&quot;<BR>
<BR>
MSBuild /p:/Configuration=Release tf_python_build_pip_package.vcxproj<BR>
<BR>
http://blog.csdn.net/DawnRanger/article/details/77755412
</DD>
</DL>

</DD>
<DT>caffe</DT>
<!--property:date_created=1517222419-->
<!--property:date_modified=1517222419-->
<DD>
<DL>
<DT>编译</DT>
<!--property:date_created=1517222424-->
<!--property:date_modified=1517461523-->
<DD>
http://blog.csdn.net/shakevincent/article/details/51694686<BR>
<BR>
https://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy<BR>
<BR>
https://www.cnblogs.com/leoking01/p/6951750.html<BR>
<BR>
http://blog.csdn.net/akashaicrecorder/article/details/71016942
</DD>
</DL>

</DD>
<DT>FTP</DT>
<!--property:date_created=1516785432-->
<!--property:date_modified=1516785438-->
<DD>
C<DL>
<DT>C#获取网络文件夹文件</DT>
<!--property:date_created=1516785440-->
<!--property:date_modified=1516785458-->
<DD>
我在之前做过一个FTP的客户端工具。<BR>
drw   文件夹<BR>
-rw    文件（有扩展名或无扩展名）<BR>
我是根据服务端返回的报文进行分析获取的列表。<BR>
给你一些代码片段：<BR>
/// &lt;summary&gt;<BR>
        /// 获取指定目录下的文件和文件夹。<BR>
        /// &lt;/summary&gt;<BR>
        /// &lt;param name=&quot;path&quot;&gt;要获取的目录&lt;/param&gt;<BR>
        /// &lt;param name=&quot;WRMethods&quot;&gt;要发送到FTP服务器的密令。&lt;/param&gt;<BR>
        /// &lt;returns&gt;&lt;/returns&gt;<BR>
        public string[] GetFileList(string path, string WRMethods)//从ftp服务器上获得文件列表<BR>
        {<BR>
            WebResponse response;<BR>
            string[] downloadFiles;<BR>
            int conut = 4;<BR>
            StringBuilder result = new StringBuilder();<BR>
            Connect(path);<BR>
            if (FTPVariable.IsUseProxy_ftp)<BR>
            {<BR>
                reqFTP.Proxy = FtpProxy.GetFtpSelectProxy(FTPVariable.FtpCommand_transferProxyName);<BR>
            }<BR>
            reqFTP.ReadWriteTimeout = 12000;<BR>
            //如果不应销毁到服务器的连接，则为 true；否则为 false。默认值为 true。<BR>
            //<BR>
            reqFTP.Method = WRMethods;<BR>
            try<BR>
            {<BR>
                response = (FtpWebResponse)reqFTP.GetResponse();<BR>
                goto Ftp_lbl_03;<BR>
            }<BR>
            catch (WebException webex)<BR>
            {<BR>
                GetReply(webex.Message);<BR>
                if (ReplyCode == 530)// 未登录。<BR>
                {<BR>
                    goto Ftp_lbl_04;<BR>
                }<BR>
                else if (ReplyCode == 550)<BR>
                {<BR>
                    goto Ftp_lbl_04;<BR>
                }<BR>
                else<BR>
                {<BR>
                    FtpManage.SetLog(&quot;获取列表超时,等候1秒后重试!&quot;);<BR>
                    goto Ftp_lbl_01;<BR>
                }<BR>
            }<BR>
        Ftp_lbl_01:<BR>
            try<BR>
            {<BR>
                FtpManage.SetLog(&quot;正在连接服务器 &quot; + FtpRemoteHost);<BR>
                response = GetRequest(path, WRMethods);<BR>
            }<BR>
            catch (WebException)<BR>
            {<BR>
                FtpManage.SetLog(&quot;获取列表超时,等候1秒后重试!&quot;);<BR>
                downloadFiles = null;<BR>
                System.Threading.Thread.Sleep(1000);<BR>
                if (conut == 0)<BR>
                {<BR>
                    goto Ftp_lbl_02;<BR>
                }<BR>
                conut--;<BR>
                goto Ftp_lbl_01;<BR>
            }<BR>
            catch (Exception ex)<BR>
            {<BR>
                MSG.Show(ex.Message, Global.GetRS[&quot;msgTilteError&quot;], MessageBoxButton.OK, MsgIco.Error);<BR>
                FtpManage.SetLog(&quot;命令执行失败,原因:&quot; + ex.Message);<BR>
                downloadFiles = null;<BR>
                return downloadFiles;<BR>
            }<BR>
        Ftp_lbl_03:<BR>
            StreamReader reader = new StreamReader(response.GetResponseStream(), System.Text.Encoding.Default);//中文文件名<BR>
            string line = reader.ReadLine();<BR>
            while (line != null)<BR>
            {<BR>
                result.Append(line);<BR>
                result.Append(&quot;\n&quot;);<BR>
                line = reader.ReadLine();<BR>
            }<BR>
            if (result.Length == 0)<BR>
            {<BR>
                return null;<BR>
            }<BR>
            // to remove the trailing '\n'<BR>
            result.Remove(result.ToString().LastIndexOf('\n'), 1);<BR>
            reader.Close();<BR>
            response.Close();<BR>
            FtpManage.SetLog(&quot;命令已成功执行&quot;);<BR>
            return result.ToString().Split('\n');<BR>
        Ftp_lbl_04:<BR>
            FtpManage.SetLog(ReplyInfo);<BR>
            return null;<BR>
        Ftp_lbl_02:<BR>
            FtpManage.SetLog(&quot;550 获取列表失败,无法连接远程服务器!&quot;);<BR>
            FtpManage.ftpmanage.IsRefurbish = true;<BR>
            return null;<BR>
        }<BR>
/// &lt;summary&gt;<BR>
        /// 获取指定目录下的文件和文件夹。<BR>
        /// &lt;/summary&gt;<BR>
        /// &lt;param name=&quot;path&quot;&gt;要获取的目录&lt;/param&gt;<BR>
        /// &lt;returns&gt;&lt;/returns&gt;<BR>
        public string[] GetFileList(string path)//从ftp服务器上获得文件列表<BR>
        {<BR>
            return GetFileList(FTPVariable.FtpURLhead + FtpRemoteHost + &quot;/&quot; + path, WebRequestMethods.Ftp.ListDirectory);<BR>
        }<BR>
        /// &lt;summary&gt;<BR>
        /// 获取指定目录下的文件和文件夹。<BR>
        /// &lt;/summary&gt;<BR>
        /// &lt;returns&gt;&lt;/returns&gt;<BR>
        public string[] GetFileList()//从ftp服务器上获得文件列表<BR>
        {<BR>
            return GetFileList(FTPVariable.FtpURLhead + FtpRemoteHost + &quot;/&quot;, WebRequestMethods.Ftp.ListDirectory);<BR>
        }<BR>
        /// &lt;summary&gt;<BR>
        /// 获取目录和文件名,返回目录表。<BR>
        /// &lt;/summary&gt;<BR>
        /// &lt;param name=&quot;path&quot;&gt;要获取的目录&lt;/param&gt;<BR>
        /// &lt;returns&gt;&lt;/returns&gt;<BR>
        public string[] GetCatalog_FileList(string path)<BR>
        {<BR>
            string[] fountainhead = GetFileList(FTPVariable.FtpURLhead + FtpRemoteHost + &quot;/&quot; + path, WebRequestMethods.Ftp.ListDirectoryDetails);<BR>
            string[] Catalog = null;<BR>
            if (fountainhead == null)<BR>
            {<BR>
                return null;<BR>
            }<BR>
            Catalog = new string[fountainhead.Length];<BR>
            for (int i = 3; i &lt; fountainhead.Length; i++)<BR>
            {<BR>
                Catalog[i - 3] += fountainhead[i].Substring(55, fountainhead[i].Length - 55) + &quot;&amp;&quot;;//FileName<BR>
                Catalog[i - 3] += fountainhead[i].Substring(30, 12) + &quot;&amp;&quot;;//FileSize<BR>
                Catalog[i - 3] += fountainhead[i].Substring(42, 13) + &quot;&amp;&quot;;//AmendDate<BR>
                Catalog[i - 3] += fountainhead[i].Substring(0, 3) + &quot;&amp;&quot;;<BR>
            }<BR>
            return Catalog;<BR>
        }
</DD>
<DT>C/C++</DT>
<!--property:date_created=1516785498-->
<!--property:date_modified=1516785620-->
<DD>
libcurl<BR>
wininet<BR>
<BR>
查看lftp源码中mget怎么实现的
</DD>
<DT>curl</DT>
<!--property:date_created=1517625058-->
<!--property:date_modified=1517625058-->
<!--property:expanded-->
<DD>
<DL>
<DT>编译</DT>
<!--property:date_created=1517625065-->
<!--property:date_modified=1517625074-->
<DD>
http://windows.php.net/downloads/php-sdk/deps/vc14/x64/
</DD>
</DL>

</DD>
</DL>

</DD>
<DT>图形图像处理</DT>
<!--property:date_created=1518077980-->
<!--property:date_modified=1518077980-->
<DD>
<DL>
<DT>安卓图形图像处理</DT>
<!--property:date_created=1518077988-->
<!--property:date_modified=1518077995-->
<DD>
http://www.jb51.net/Special/214.htm
</DD>
<DT>java图形图像处理</DT>
<!--property:date_created=1518078008-->
<!--property:date_modified=1518078018-->
<DD>
http://blog.csdn.net/it_man/article/details/7606218
</DD>
</DL>

</DD>
<DT>树莓派</DT>
<!--property:date_created=1518165142-->
<!--property:date_modified=1518165142-->
<DD>
<DL>
<DT>安装远程控制系统</DT>
<!--property:date_created=1518165150-->
<!--property:date_modified=1518227277-->
<DD>
//vnc<BR>
http://shumeipai.nxez.com/2013/09/04/login-rpi-with-vnc.html?variant=zh-cn<BR>
<BR>
//开源n00bRAT<BR>
http://www.freebuf.com/sectool/687.html<BR>
<BR>
<BR>
//8款开源软件<BR>
http://www.linuxprobe.com/screen-recorder-in-linux.html<BR>
http://www.linuxprobe.com/screen-recorder-in-linux.html
</DD>
</DL>

</DD>
<DT>Opencv</DT>
<!--property:date_created=1518227783-->
<!--property:date_modified=1518227783-->
<!--property:expanded-->
<DD>
<DL>
<DT>Ubuntu编译安装</DT>
<!--property:date_created=1518227793-->
<!--property:date_modified=1518235860-->
<DD>
16.04<BR>
http://blog.csdn.net/li_wen01/article/details/71641408<BR>
<BR>
14.04<BR>
http://blog.csdn.net/u013831198/article/details/70215925<BR>
<BR>
17.04<BR>
http://www.linuxidc.com/Linux/2017-10/147316.htm<BR>
<BR>
<BR>
<BR>
cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local -D OPENCV_EXTRA_MODULES_PATH=../opencv_contrib-3.3.1/modules/ .. <BR>
<BR>
//编译运行<BR>
<BR>
CC = g++ -std=c++11<BR>
CFLAGS = -I/usr/local/include<BR>
LDFLAGS = -L/usr/local//lib<BR>
LDFLAGS += -lopencv_core -lopencv_calib3d -lopencv_xfeatures2d -lopencv_tracking -lopencv_features2d -lopencv_highgui -lopencv_imgcodecs -lopencv_ximgproc -lopencv_imgproc -lpthread -lm -lstdc++ -lgomp<BR>
SRC = opencvtest.cpp<BR>
<BR>
all:<BR>
        $(CC) $(CFLAGS) $(SRC) $(LDFLAGS) -o opencvtest<BR>
clean:<BR>
        rm -rf *.o opencvtest<BR>
<BR>
<BR>
<BR>
http://blog.csdn.net/CupidYzw97/article/details/74857467<BR>
http://blog.csdn.net/xiangxianghehe/article/details/78780269<BR>
<BR>
cmake -D CMAKE_BUILD_TYPE=RELEASE \<BR>
  -D CMAKE_INSTALL_PREFIX=/usr/local \<BR>
  -D INSTALL_C_EXAMPLES=ON \<BR>
  -D INSTALL_PYTHON_EXAMPLES=ON \<BR>
  -D WITH_TBB=ON \<BR>
  -D WITH_V4L=ON \<BR>
  -D WITH_QT=ON \<BR>
  -D WITH_OPENGL=ON \<BR>
  -D OPENCV_EXTRA_MODULES_PATH=../opencv_contrib/modules \<BR>
  -D BUILD_EXAMPLES=ON ..<BR>
<BR>
cmake -D CMAKE_BUILD_TYPE=RELEASE \<BR>
  -DCMAKE_INSTALL_PREFIX=/usr/local \<BR>
  -D INSTALL_C_EXAMPLES=OFF \<BR>
  -D INSTALL_PYTHON_EXAMPLES=OFF \<BR>
  -D WITH_TBB=ON \<BR>
  -D WITH_V4L=ON \<BR>
  -D WITH_QT=ON \<BR>
  -D WITH_OPENGL=ON \<BR>
  -D OPENCV_EXTRA_MODULES_PATH=../opencv_contrib/modules \<BR>
  -D BUILD_EXAMPLES=OFF ..<BR>
<BR>
cmake \<BR>
-D CMAKE_BUILD_TYPE=RELEASE \<BR>
-D CMAKE_INSTALL_PREFIX=/usr/local \<BR>
-D WITH_CUDA=ON \<BR>
-D ENABLE_FAST_MATH=1 \<BR>
-D CUDA_FAST_MATH=1 \<BR>
-D WITH_CUBLAS=1 \<BR>
-D INSTALL_C_EXAMPLES=OFF \<BR>
-D INSTALL_PYTHON_EXAMPLES=ON \<BR>
-D OPENCV_EXTRA_MODULES_PATH=../opencv_contrib-3.3.0/modules  \<BR>
-D BUILD_SHARED_LIBS=ON \<BR>
-D WITH_GTK=ON \    <BR>
-D BUILD_EXAMPLES=ON ..  
</DD>
</DL>

</DD>
<DT>linux</DT>
<!--property:date_created=1517816521-->
<!--property:date_modified=1517816521-->
<DD>
<DL>
<DT>第三方库连接</DT>
<!--property:date_created=1517816529-->
<!--property:date_modified=1517816556-->
<DD>
1.Ubuntu目录结构<BR>
在Ubuntu使用记录（常用命令与目录树）中我总结了一些关于Ubuntu/Linux的目录的一些知识，这里回顾一下。<BR>
软件主要分为3类，可以用which命令查看，一个软件/命令的位置<BR>
①/sbin<BR>
表示系统的一些程序，比如shutdown<BR>
②/bin<BR>
表示一些可以用在bash上面的命令，比如ps，ls等<BR>
③/usr/bin<BR>
表示其他安装的软件，比如我们需要apt-get install安装的软件，比如firefox，gcc，codeblocks等等<BR>
<BR>
2.库文件<BR>
总结自：http://www.cnblogs.com/skynet/p/3372855.html<BR>
<BR>
（1）什么是库<BR>
简单说，库就是一些头文件与库文件（可能包括静态库与动态库两种）的集合。<BR>
库文件通过头文件向外导出接口，头文件中有函数的声明，库文件中是对应的实现。<BR>
<BR>
（2）位置<BR>
①安装的第三方软件<BR>
/usr/bin                             可执行文件<BR>
/usr/lib                              可执行文件的库文件<BR>
/usr/include                     可执行文件的头文件<BR>
②安装的第三方库<BR>
/usr/local/bin                   安装的库的一些测试程序<BR>
/usr/local/lib                    安装的库的库文件<BR>
/usr/local/include            安装的库的头文件<BR>
<BR>
（3）静态库<BR>
①格式<BR>
.a<BR>
②加载阶段<BR>
编译四大阶段的链接阶段<BR>
③本质<BR>
一系列目标文件（.o文件）的集合<BR>
④特点<BR>
程序在运行时与函数库再无瓜葛，移植方便。<BR>
浪费空间和资源，所有相关的目标文件与涉及到的函数库被链接合成一个可执行文件。<BR>
如果库有更新，且要加载新库，需重新编译整个应用程序。<BR>
⑤使用<BR>
在Ubuntu/Linux下面，只需在编译的时候指定搜索路径与静态库名<BR>
-L         表示要连接的库所在目录<BR>
-l          表示链接时需要的静态库（比如libev的静态库文件libev.a在编译的时候，只需要-lev即可）<BR>
<BR>
（4）动态库<BR>
①格式<BR>
.so<BR>
②加载阶段<BR>
动态库是在程序运行时，才被加载到内存中。<BR>
多个程序如果使用相同的动态库，在内存中只会存在一份拷贝。<BR>
③特点<BR>
可以实现进程间资源共享，因此也叫坐共享库。<BR>
使得程序升级变地简单，只需要更新动态库文件即可。<BR>
甚至可以做到链接载入完全由程序员在程序代码中控制（显式调用）。<BR>
④使用<BR>
由于涉及到编译以及运行两个阶段的库文件查找，所以有两个需要注意的地方。<BR>
A。编译阶段<BR>
一样的-L和-l<BR>
B。运行阶段<BR>
由于需要在运行的时候也要找到动态库文件的位置。<BR>
这个是在/etc/ld.so.cache文件里面记载的，系统默认在这个文件里面记载有/lib以及/usr/lib<BR>
所以，如果你是安装的第三方库，或者是自己生成了一个动态库，你的库文件是在/usr/local/lib中或者其他地方，系统是默认找不到的。<BR>
这个时候，编译没有问题，可是一旦运行，系统就会提示找不到某某库文件。<BR>
解决办法是修改/etc/ld.so.cache，但是注意，由于这不是一个配置文件，所以不能直接修改。<BR>
要通过/etc/ld.so.conf来修改，假设我安装了第三方库libev，库的目录是/usr/local/lib，那么我就要这样做。<BR>
$vim /etc/ls.so.conf<BR>
另起一行，加上/usr/local/lib<BR>
$ldconfig     ,该命令会根据ld.so.conf文件重建ld.so.cache文件，这个时候就能愉快地使用第三方库啦！<BR>
⑤补充<BR>
ldd命令，ldd 某应用程序<BR>
可以查看该应用程序依赖的动态链接库。<BR>

</DD>
<DT>运行时库链接</DT>
<!--property:date_created=1517982817-->
<!--property:date_modified=1517983901-->
<DD>
一般我们在Linux下执行某些外部程序的时候可能会提示找不到共享库的错误, 比如:<BR>
<BR>
tmux: error while loading shared libraries: libevent-1.4.so.2: cannot open shared object file: No such file or directory<BR>
<BR>
原因一般有两个, 一个是操作系统里确实没有包含该共享库(lib*.so.*文件)或者共享库版本不对, 遇到这种情况那就去网上下载并安装上即可. <BR>
<BR>
另外一个原因就是已经安装了该共享库, 但执行需要调用该共享库的程序的时候, 程序按照默认共享库路径找不到该共享库文件. <BR>
<BR>
所以安装共享库后要注意共享库路径设置问题, 如下:<BR>
<BR>
1) 如果共享库文件安装到了/lib或/usr/lib目录下, 那么需执行一下ldconfig命令<BR>
<BR>
ldconfig命令的用途, 主要是在默认搜寻目录(/lib和/usr/lib)以及动态库配置文件/etc/ld.so.conf内所列的目录下, 搜索出可共享的动态链接库(格式如lib*.so*), 进而创建出动态装入程序(ld.so)所需的连接和缓存文件. 缓存文件默认为/etc/ld.so.cache, 此文件保存已排好序的动态链接库名字列表. <BR>
<BR>
2) 如果共享库文件安装到了/usr/local/lib(很多开源的共享库都会安装到该目录下)或其它&quot;非/lib或/usr/lib&quot;目录下, 那么在执行ldconfig命令前, 还要把新共享库目录加入到共享库配置文件/etc/ld.so.conf中, 如下:<BR>
<BR>
# cat /etc/ld.so.conf<BR>
include ld.so.conf.d/*.conf<BR>
# echo &quot;/usr/local/lib&quot; &gt;&gt; /etc/ld.so.conf<BR>
# ldconfig<BR>
<BR>
3) 如果共享库文件安装到了其它&quot;非/lib或/usr/lib&quot; 目录下,  但是又不想在/etc/ld.so.conf中加路径(或者是没有权限加路径). 那可以export一个全局变量LD_LIBRARY_PATH, 然后运行程序的时候就会去这个目录中找共享库. <BR>
<BR>
LD_LIBRARY_PATH的意思是告诉loader在哪些目录中可以找到共享库. 可以设置多个搜索目录, 这些目录之间用冒号分隔开. 比如安装了一个mysql到/usr/local/mysql目录下, 其中有一大堆库文件在/usr/local/mysql/lib下面, 则可以在.bashrc或.bash_profile或shell里加入以下语句即可:<BR>
<BR>
export LD_LIBRARY_PATH=/usr/local/mysql/lib:$LD_LIBRARY_PATH    <BR>
<BR>
一般来讲这只是一种临时的解决方案, 在没有权限或临时需要的时候使用.<BR>
<BR>
4）如果程序需要的库文件比系统目前存在的村文件版本低，可以做一个链接<BR>
比如：<BR>
error while loading shared libraries: libncurses.so.4: cannot open shared<BR>
object file: No such file or directory<BR>
<BR>
ls /usr/lib/libncu*<BR>
/usr/lib/libncurses.a   /usr/lib/libncurses.so.5<BR>
/usr/lib/libncurses.so  /usr/lib/libncurses.so.5.3<BR>
<BR>
可见虽然没有libncurses.so.4，但有libncurses.so.5，是可以向下兼容的<BR>
建一个链接就好了<BR>
ln -s  /usr/lib/libncurses.so.5.3  /usr/lib/libncurses.so.4<BR>
<BR>
出处：http://blog.csdn.net/sahusoft/article/details/7388617<BR>
      http://www.vrlinux.com/shujukuyingyong/20100407/26958.html<BR>
<BR>
<BR>
<BR>
用 find 命令查找 libmysqlclient.so.18 在哪个目录：<BR>
<BR>
# find / -name &quot;libmysqlclient.so.18&quot;<BR>
<BR>
/u01/app/mysql/lib/libmysqlclient.so.18<BR>
<BR>
进入用户Home目录，打开.bash_profile文件，给环境变量 LD_LIBRARY_PATH 加上 libmysqlclient.so.18 的所在目录。<BR>
<BR>
# cd ~      // 进入用户的Home目录<BR>
<BR>
# vi .bash_profile    // 用 v i 打开 .bash_profile 文件<BR>
<BR>
如下图指示编辑 .bash_profile 文件并保存：
</DD>
</DL>

</DD>
<DT>RTSP</DT>
<!--property:date_created=1516328752-->
<!--property:date_modified=1516328840-->
<DD>
主码流<BR>
rtsp://admin:admin12345@192.168.4.64:554/h264/ch1/main/av_stream 			vlc请求视频流<BR>
rtsp://admin:12345@192.0.0.64:554/MPEG-4/ch1/main/av_stream  <BR>
<BR>
//自麻溜<BR>
rtsp://admin:12345@192.0.0.64/mpeg4/ch1/sub/av_stream  <BR>
  <BR>
rtsp://admin:12345@192.0.0.64/h264/ch1/sub/av_stream  
</DD>
<DT>相机连接流程</DT>
<!--property:date_created=1515574729-->
<!--property:date_modified=1515574790-->
<DD>
必须要素：<BR>
<BR>
1.      必须包含subject头域<BR>
2.      SDP中session name必须填写Play<BR>
3.      SDP中不能懈怠audio<BR>
4.      SDP中的video必须携带PS属性<BR>
<BR>
以上4要素缺一不可。<BR>
示例：<BR>
<BR>
1.      正确流程<BR>
<BR>
P1-&gt;IPC<BR>
<BR>
INVITEsip:34020000001320000001@192.168.50.171 SIP/2.0<BR>
Via: SIP/2.0/UDP192.168.50.22:5060;branch=32dbcde3<BR>
From: &quot;1001&quot;&lt;sip:1001@192.168.50.22&gt;;tag=591cf984<BR>
Contact:&lt;sip:1001@192.168.50.22:5060&gt;<BR>
To:&lt;sip:34020000001320000001@192.168.50.171&gt;<BR>
Call-ID:14416987936de3e8ed55fe07400dcce022@1632a8c0<BR>
CSeq: 172 INVITE<BR>
Max-Forwards: 70<BR>
Subject:34020000001320000001:0,1001:0<BR>
Content-Type: application/sdp<BR>
Content-Length: 381<BR>
 <BR>
v=0<BR>
o=root 853265891 853265891 IN IP4192.168.50.22<BR>
s=Play<BR>
c=IN IP4 192.168.50.22<BR>
t=0 0<BR>
m=video 19690 RTP/AVP 126 125 99 34 96<BR>
a=rtpmap:126 H264/90000<BR>
a=fmtp:126 profile-level-id=42e01e<BR>
a=rtpmap:125 H264S/90000<BR>
a=fmtp:125 profile-level-id=42e01e<BR>
a=rtpmap:99 MP4V-ES/90000<BR>
a=fmtp:99 profile-level-id=3<BR>
a=rtpmap:96 PS/90000<BR>
 <BR>
IPC-&gt;P1<BR>
SIP/2.0 200 OK<BR>
Via: SIP/2.0/UDP192.168.50.22:5060;branch=32dbcde3<BR>
From: &quot;1001&quot;&lt;sip:1001@192.168.50.22&gt;;tag=591cf984<BR>
To:&lt;sip:34020000001320000001@192.168.50.171&gt;;tag=1292444290<BR>
Call-ID:14416987936de3e8ed55fe07400dcce022@1632a8c0<BR>
CSeq: 172 INVITE<BR>
Contact:&lt;sip:1005@192.168.50.171:5060&gt;<BR>
Content-Type: application/sdp<BR>
User-Agent: IP Camera<BR>
Content-Length:   267<BR>
 <BR>
v=0<BR>
o=1005 1935 1935 IN IP4 192.168.50.171<BR>
s=play<BR>
c=IN IP4 192.168.50.171<BR>
t=0 0<BR>
m=video 15060 RTP/AVP 96<BR>
a=sendonly<BR>
a=rtpmap:96 PS/90000<BR>
 <BR>
2.      不正确流程<BR>
<BR>
P1-&gt;IPC<BR>
INVITEsip:34020000001320000001@192.168.50.171 SIP/2.0<BR>
Via: SIP/2.0/UDP192.168.50.22:5060;branch=55b46723<BR>
From: &quot;1001&quot;&lt;sip:1001@192.168.50.22&gt;;tag=1a72242e<BR>
Contact: &lt;sip:1001@192.168.50.22:5060&gt;<BR>
To:&lt;sip:34020000001320000001@192.168.50.171&gt;<BR>
Call-ID:1441698966743435f475c5f89133b42b83@1632a8c0<BR>
CSeq: 170 INVITE<BR>
Max-Forwards: 70<BR>
Subject:34020000001320000001:0,1001:0<BR>
Content-Type: application/sdp<BR>
Content-Length: 553<BR>
 <BR>
v=0<BR>
o=root 1437886243 1437886243 IN IP4192.168.50.22<BR>
s=Play<BR>
c=IN IP4 192.168.50.22<BR>
t=0 0<BR>
m=audio38406 RTP/AVP 0 8 3 114 18<BR>
a=rtpmap:0 PCMU/8000<BR>
a=rtpmap:8 PCMA/8000<BR>
a=rtpmap:3 GSM/8000<BR>
a=rtpmap:114 AMR/8000<BR>
a=fmtp:114 mode-set=7<BR>
a=rtpmap:18 G729/8000<BR>
m=video24674 RTP/AVP 126 125 99<BR>
a=recvonly<BR>
a=rtpmap:126 H264/90000<BR>
a=fmtp:126 profile-level-id=42e01e<BR>
a=rtpmap:125 H264S/90000<BR>
a=fmtp:125 profile-level-id=42e01e<BR>
a=rtpmap:99 MP4V-ES/90000<BR>
a=fmtp:99 profile-level-id=3<BR>
 <BR>
 <BR>
IPC-&gt;P1<BR>
SIP/2.0 200 OK<BR>
Via: SIP/2.0/UDP 192.168.50.22:5060;branch=55b46723<BR>
From: &quot;1001&quot;&lt;sip:1001@192.168.50.22&gt;;tag=1a72242e<BR>
To:&lt;sip:34020000001320000001@192.168.50.171&gt;;tag=2000948179<BR>
Call-ID:1441698966743435f475c5f89133b42b83@1632a8c0<BR>
CSeq: 170 INVITE<BR>
Contact:&lt;sip:1005@192.168.50.171:5060&gt;<BR>
Content-Type: application/sdp<BR>
User-Agent: IP Camera<BR>
Content-Length:   108<BR>
 <BR>
v=0<BR>
o=1005 3764 3764 IN IP4 192.168.50.171<BR>
s=play<BR>
c=IN IP4 192.168.50.171<BR>
t=0 0<BR>
m=video 15060RTP/AVP
</DD>
</DL>
</BODY>
</HTML>
