<!DOCTYPE NoteCase-File>
<!--LastNote:31-->
<HTML>
<HEAD>
<meta content="text/html;charset=UTF-8" http-equiv="Content-Type">
<meta name="generator" content="NoteCase 1.9.8">
<TITLE></TITLE>
</HEAD>
<BODY>
<DL>
<DT>C#研究代码</DT>
<!--property:date_created=1515136331-->
<!--property:date_modified=1515136331-->
<DD>
<DL>
<DT>开关机</DT>
<!--property:date_created=1515136346-->
<!--property:date_modified=1515136858-->
<DD>
// 程序开机自动启动<BR>
void autostart()<BR>
{<BR>
    HKEY hKey;<BR>
    QString strRegPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot;;<BR>
<BR>
    //1、找到系统的启动项  <BR>
    if (RegOpenKeyEx(HKEY_CURRENT_USER, strRegPath.toStdString().c_str(), 0, KEY_ALL_ACCESS, &amp;hKey) == ERROR_SUCCESS) ///打开启动项       <BR>
    {<BR>
        //2、得到本程序自身的全路径<BR>
        TCHAR strExeFullDir[MAX_PATH];<BR>
        GetModuleFileName(NULL, strExeFullDir, MAX_PATH);<BR>
<BR>
        //3、判断注册表项是否已经存在<BR>
        TCHAR strDir[MAX_PATH] = {};<BR>
        DWORD nLength = MAX_PATH;<BR>
        long result = RegGetValue(hKey, nullptr, &quot;GISRestart&quot;, RRF_RT_REG_SZ, 0, strDir, &amp;nLength);<BR>
<BR>
        //4、已经存在<BR>
        if (result != ERROR_SUCCESS || _tcscmp(strExeFullDir, strDir) != 0)<BR>
        {<BR>
            //5、添加一个子Key,并设置值，&quot;GISRestart&quot;是应用程序名字（不加后缀.exe） <BR>
            RegSetValueEx(hKey, &quot;GISRestart&quot;, 0, REG_SZ, (LPBYTE)strExeFullDir, (lstrlen(strExeFullDir) + 1)*sizeof(TCHAR));<BR>
<BR>
            //6、关闭注册表<BR>
            RegCloseKey(hKey);<BR>
        }<BR>
    }<BR>
    else<BR>
    {<BR>
        QMessageBox::warning(0, QString::fromLocal8Bit(&quot;警告&quot;), QString::fromLocal8Bit(&quot;\n系统参数错误,不能随系统启动n&quot;));<BR>
    }<BR>
}<BR>
<BR>
// 取消开机自动启动<BR>
void SGISRestartDlg::cancelAutoStart()<BR>
{<BR>
    HKEY hKey;<BR>
    QString strRegPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot;;<BR>
<BR>
    //1、找到系统的启动项  <BR>
    if (RegOpenKeyEx(HKEY_CURRENT_USER, strRegPath.toStdString().c_str(), 0, KEY_ALL_ACCESS, &amp;hKey) == ERROR_SUCCESS)<BR>
    {<BR>
        //2、删除值<BR>
        RegDeleteValue(hKey, &quot;GISRestart&quot;);<BR>
<BR>
        //3、关闭注册表<BR>
        RegCloseKey(hKey);<BR>
    }<BR>
}<BR>
<BR>
<BR>
//定时关机<BR>
Process p = new Process();<BR>
           p.StartInfo.FileName = &quot;cmd.exe &quot;;<BR>
           p.StartInfo.UseShellExecute = false;<BR>
           p.StartInfo.RedirectStandardInput = true;<BR>
           p.StartInfo.RedirectStandardOutput = true;<BR>
           p.StartInfo.RedirectStandardError = true;<BR>
           p.StartInfo.CreateNoWindow = true;<BR>
           p.Start();<BR>
           p.StandardInput.WriteLine(&quot;at time shutdown -s&quot;);   //填CMD命令<BR>
           p.StandardInput.WriteLine(&quot;exit &quot;);<BR>
           string strRst = p.StandardOutput.ReadToEnd();<BR>
           MessageBox.Show(strRst);<BR>
           p.WaitForExit();<BR>
<BR>
<BR>
//定时关机<BR>
ProcessStartInfo psi = new ProcessStartInfo(&quot;shutdown&quot;, &quot;/s /t 300 /c 关机了&quot;);<BR>
Process.Start(psi);<BR>
<BR>
//定时开机<BR>
[DllImport(&quot;kernel32.dll&quot;)]<BR>
    public static extern SafeWaitHandle CreateWaitableTimer(IntPtr lpTimerAttributes, bool bManualReset, string lpTimerName);<BR>
<BR>
    [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]<BR>
    [return: MarshalAs(UnmanagedType.Bool)]<BR>
    public static extern bool SetWaitableTimer(SafeWaitHandle hTimer, [In] ref long pDueTime, int lPeriod, IntPtr pfnCompletionRoutine, IntPtr lpArgToCompletionRoutine, bool fResume);<BR>
    /// &lt;summary&gt;<BR>
    /// 设置唤醒时间<BR>
    /// &lt;/summary&gt;<BR>
    private void SetWaitForWakeUpTime(DateTime OnTime)<BR>
    {<BR>
      DateTime utc = OnTime;<BR>
      long duetime = utc.ToFileTime();<BR>
            using (SafeWaitHandle handle = CreateWaitableTimer(IntPtr.Zero, true, &quot;MyWaitabletimer&quot;))<BR>
      {<BR>
        if (SetWaitableTimer(handle, ref duetime, 0, IntPtr.Zero, IntPtr.Zero, true))<BR>
        {<BR>
          using (EventWaitHandle wh = new EventWaitHandle(false, EventResetMode.AutoReset))<BR>
          {<BR>
            wh.SafeWaitHandle = handle;<BR>
            Application.SetSuspendState(PowerState.Hibernate, true, false);<BR>
            wh.WaitOne();<BR>
          }<BR>
        }<BR>
        else<BR>
        {<BR>
          throw new Win32Exception(Marshal.GetLastWin32Error());<BR>
        }<BR>
      }<BR>
<BR>
    }<BR>

</DD>
</DL>

</DD>
<DT>pjsip</DT>
<!--property:date_created=1515478068-->
<!--property:date_modified=1515727977-->
<DD>
     今天抽空写下以GB28181的方式获取摄像机视频流以备后用，同时也希望能帮助到正着手开发GB28181对接视频的同学，这块的资料实在不多。<BR>
<BR>
今天讲的内容不涉及到平台对接，平台对接下次有时间再讲，平台对接相对更麻烦点。通过GB28181获取摄像机视频流，首先需要摄像机支持GB28181<BR>
<BR>
，如何知道摄像机是否支持GB28181协议呢？请看下图：<BR>
<BR>
<BR>
<BR>
                                                            图1.摄像机28181协议配置图<BR>
<BR>
图1 展示了海康摄像机配置GB28181页面，其他厂家摄像机GB28181配置页面（我遇到的）基本跟海康配置的页面相同。<BR>
<BR>
下面介绍下各配置项基本意义：<BR>
<BR>
   本地端口：默认为5060，SIP服务发送命令给摄像机时需要知道摄像机GB28181端口号，要不向哪发？<BR>
<BR>
SIP服务器ID:说简单就是 服务器的标识，只不过这个标识有一定的要求，具体请参见28181-2001标准安全防范视频监控联网系统信息传输交换控制技术要求.pdf<BR>
<BR>
                    当然也可以参考新点的文档，新旧文档这部分差异不大。文档在从群里下载。<BR>
<BR>
SIP服务域：实际就是SIP服务器ID前10位。<BR>
<BR>
SIP服务器地址：SIP服务所在机器的IP地址（如果存在多网卡建议将不用的网卡禁用掉）。<BR>
<BR>
SIP服务器端口：SIP服务Port，其他SIP服务发送命令到此端口与之通信。<BR>
<BR>
其他的配置默认即可。<BR>
<BR>
   GB28181配置好以后，需要启动摄像机GB28181服务。<BR>
<BR>
启动摄像机GB28181的方法是勾选“启用”选项，启动成功后，摄像机会向SIP Server发送注册消息，通过抓包可以看到具体的注册消息内容：<BR>
<BR>
<BR>
<BR>
                            图2 摄像机发送注册消息图<BR>
<BR>
看下注册消息的具体内容：<BR>
<BR>
<BR>
<BR>
                                       图3 具体注册消息图<BR>
<BR>
重要是是Cantact信息，包含了摄像机GB28181 SIP ID 以及IP地址和端口号，这样与摄像机通信的SIP服务就知道往哪里回应答消息。<BR>
<BR>
     摄像机端基本介绍了完了（摄像机端相当于SIP Client），下面 介绍CG28181 服务端也即 SIP Server,这正是我们要实现的。<BR>
<BR>
实现CG28181服务端可以借助于现有的开源库 PJSIP,自己实现开发量还是很大的,具体的实现步骤如下：<BR>
<BR>
一. 将PJSIP运行起来，毕竟人家是一个服务。只有运行以后才能接收客户端发来的消息。<BR>
<BR>
bool Init(std::string concat, int logLevel)<BR>
{<BR>
    this-&gt;concat = concat;<BR>
    pj_log_set_level(logLevel);<BR>
    auto status = pj_init();<BR>
 <BR>
    status = pjlib_util_init();<BR>
 <BR>
    pj_caching_pool_init(&amp;cachingPool, &amp;pj_pool_factory_default_policy, 0);<BR>
 <BR>
    status = pjsip_endpt_create(&amp;cachingPool.factory, nullptr, &amp;endPoint);<BR>
                 <BR>
    status = pjsip_tsx_layer_init_module(endPoint);<BR>
 <BR>
    status = pjsip_ua_init_module(endPoint, nullptr);<BR>
 <BR>
    pool = pj_pool_create(&amp;cachingPool.factory, &quot;proxyapp&quot;, 4000, 4000, nullptr);<BR>
    auto pjStr =StrToPjstr(GetAddr());<BR>
 <BR>
    pj_sockaddr_in pjAddr;<BR>
    pjAddr.sin_family = pj_AF_INET();<BR>
    pj_inet_aton(&amp;pjStr, &amp;pjAddr.sin_addr);<BR>
 <BR>
    auto port = GetPort();<BR>
    pjAddr.sin_port = pj_htons(static_cast&lt;pj_uint16_t&gt;(GetPort()));<BR>
　　　　status = pjsip_udp_transport_start(endPoint, &amp;pjAddr, nullptr, 1, nullptr);<BR>
      if (status != PJ_SUCCESS) return status;<BR>
 <BR>
      auto realm = StrToPjstr(GetLocalDomain());<BR>
      return pjsip_auth_srv_init(pool, &amp;authentication, &amp;realm, lookup, 0) == PJ_SUCCESS ? true : false;<BR>
         <BR>
}<BR>
　　以上是PJSip初始化的代码，需要将服务将要监听的端口传给PJSIP,这样服务就在监听的端口接收SIP 消息了。<BR>
<BR>
二. 应答注册消息<BR>
<BR>
     摄像机端发送来Register消息后，如过服务端不应答，摄像机端会一直发送直到收到服务端应答为止。如果服务器端重新运行，需要手动再次<BR>
<BR>
开启摄像机，如果等摄像机自己再次发送注册消息可能是一个小时以后，我们当然不希望那么久。<BR>
<BR>
服务端应答注册消息代码<BR>
bool OnReceive(pjsip_rx_data* rdata) override<BR>
{<BR>
    if(rdata-&gt;msg_info.cseq-&gt;method.id == PJSIP_REGISTER_METHOD)<BR>
    {<BR>
    　　auto expires = static_cast&lt;pjsip_expires_hdr*&gt;(pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_EXPIRES, nullptr));<BR>
    　　auto authHdr = static_cast&lt;pjsip_authorization_hdr*&gt;(pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_AUTHORIZATION, nullptr));<BR>
    　　if(expires &amp;&amp; expires-&gt;ivalue &gt; 0 )<BR>
    　　{<BR>
        if(authHdr)<BR>
        {<BR>
        　　cout &lt;&lt;&quot;receive register info&quot;&lt;&lt;endl;<BR>
        　　response(rdata, PJSIP_SC_OK, DateHead);<BR>
        　　QureryDeviceInfo(rdata);<BR>
        }<BR>
        else<BR>
        {<BR>
        　　response(rdata, PJSIP_SC_UNAUTHORIZED, AuthenHead);<BR>
        }<BR>
        return true;<BR>
    　　}<BR>
    }<BR>
    return false;<BR>
}<BR>
　　<BR>
OnReceive 是服务端接收注册消息以后的响应方法，也就是说要将OnReceive作为入参传给PJSIP,完成此项功能在初始化&lt;br data-filtered=&quot;filtered&quot;&gt;PJSIP Moudle时。至于PJSIP moudle，<BR>
这里不多解释，想要知道细节的话，可以查看PJSIP文档，文档群里有，<BR>
代码如下：<BR>
bool  Init(std::string concat, int loglevel)<BR>
{<BR>
　　bool ret = false;<BR>
  if(!mainModule)<BR>
　{<BR>
    ret = context.Init(concat,loglevel);<BR>
    if(!ret) return ret;<BR>
 <BR>
    static struct pjsip_module moudle =<BR>
    {<BR>
    　　nullptr, nullptr,<BR>
      { &quot;MainModule&quot;, 10 },<BR>
      -1,<BR>
     PJSIP_MOD_PRIORITY_APPLICATION,<BR>
     nullptr,<BR>
     nullptr,<BR>
     nullptr,<BR>
     nullptr,<BR>
    nullptr,<BR>
    &amp;CGSipMedia::OnReceive,<BR>
    nullptr,<BR>
    nullptr,<BR>
    nullptr,<BR>
    };<BR>
    mainModule = &amp;moudle;<BR>
    pjsip_inv_callback callback;<BR>
    pj_bzero(&amp;callback, sizeof(callback));<BR>
    callback.on_state_changed = &amp;onStateChanged;<BR>
    callback.on_new_session = &amp;onNewSession;<BR>
    callback.on_tsx_state_changed = &amp;onTsxStateChanged;<BR>
    callback.on_rx_offer = &amp;onRxOffer;<BR>
    callback.on_rx_reinvite = &amp;onRxReinvite;<BR>
    callback.on_create_offer = &amp;onCreateOffer;<BR>
    callback.on_send_ack = &amp;onSendAck;<BR>
    ret = context.RegisterCallback(&amp;callback);<BR>
    if(!ret ) return ret;<BR>
 <BR>
    context.InitModule();<BR>
    ret  = context.RegisterModule(mainModule);<BR>
    if(!ret ) return ret;<BR>
 <BR>
    CGSipModule::GetInstance().Init();<BR>
    ret = context.CreateWorkThread(&amp;proc,workthread,nullptr,&quot;proxy&quot;);<BR>
    }<BR>
    return ret;<BR>
    }<BR>
　<BR>
<BR>
OnReceive方法内Resonse方法实现了发送响应数据到客户端（摄像机）:<BR>
 void Response(pjsip_rx_data* rdata, int st_code,int headType) <BR>
 {<BR>
  　　std::lock_guard&lt;mutex&gt; lk(lock);<BR>
     pjsip_tx_data* tdata;<BR>
   　pjsip_endpt_create_response(endPoint, rdata, st_code, nullptr, &amp;tdata);<BR>
     auto date = DateTimeFormatter::format(LocalDateTime(), &quot;%Y-%m-%dT%H:%M:%S&quot;);<BR>
     pj_str_t c;<BR>
     pj_str_t key;<BR>
     pjsip_hdr *hdr;<BR>
     switch(headType)<BR>
      {<BR>
           case DateHead:                                                        <BR>
           　　key = pj_str(&quot;Date&quot;);<BR>
           　　hdr = reinterpret_cast&lt;pjsip_hdr*&gt;(pjsip_date_hdr_create(pool, &amp;key, pj_cstr(&amp;c, date.c_str())));<BR>
          　　 pjsip_msg_add_hdr(tdata-&gt;msg, hdr);<BR>
          　　 break;<BR>
           case AuthenHead:<BR>
           　　pjsip_auth_srv_challenge(&amp;authentication, nullptr, nullptr, nullptr, PJ_FALSE, tdata);<BR>
           　　break;<BR>
              default:<BR>
               break;<BR>
       }<BR>
      pjsip_response_addr addr;<BR>
      pjsip_get_response_addr(pool, rdata, &amp;addr);<BR>
      pjsip_endpt_send_response(endPoint, &amp;addr, tdata, nullptr, nullptr);<BR>
   }<BR>
<BR>
<BR>
实际也就是利用发PJSIP发送一些字符串给客户端。具体发送了些什么，可以抓个包看下。<BR>
<BR>
<BR>
<BR>
图4 SIP服务应答注册消息<BR>
<BR>
SIP 服务实际回了“200 OK” 给摄像机端。看下具体的消息内容：<BR>
<BR>
<BR>
<BR>
                                  图5  “200 OK” 具体内容<BR>
<BR>
      SIP服务端响应注册命令后，发送Invite请求，请求catalog信息，也就是设备基本信息，具体的方法上面已<BR>
<BR>
给出具体的内容是：<BR>
<BR>
void QueryDeviveInfo(GBDevice *device, const string&amp; scheme = &quot;Catalog&quot;)<BR>
{<BR>
　　char szQuerInfo[200] = { 0 };<BR>
　　pj_ansi_snprintf(szQuerInfo, 200,<BR>
   &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;<BR>
   &quot;&lt;Query&gt;\n&quot;<BR>
  &quot;&lt;CmdType&gt;%s&lt;/CmdType&gt;\n&quot;<BR>
  &quot;&lt;SN&gt;17430&lt;/SN&gt;\n&quot;<BR>
  &quot;&lt;DeviceID&gt;%s&lt;/DeviceID&gt;\n&quot;<BR>
  &quot;&lt;/Query&gt;\n&quot;, scheme.c_str(), device-&gt;GetUser()<BR>
  );<BR>
　　pjsip_tx_data *tdata;<BR>
　　const pjsip_method method = { PJSIP_OTHER_METHOD,{ &quot;MESSAGE&quot;, 7 } };<BR>
　　auto text = StrToPjstr(string(szQuerInfo));<BR>
　　pjsip_endpt_create_request(endPoint, &amp;method, &amp;StrToPjstr(device-&gt;GetSipIpUrl()), &amp;StrToPjstr(concat), &amp;StrToPjstr(device-&gt;GetSipCodecUrl()),&amp;StrToPjstr(concat), nullptr, -1, &amp;text, &amp;tdata);<BR>
　　tdata-&gt;msg-&gt;body-&gt;content_type.type = pj_str(&quot;Application&quot;);<BR>
　　tdata-&gt;msg-&gt;body-&gt;content_type.subtype = pj_str(&quot;MANSCDP+xml&quot;);<BR>
　　pjsip_endpt_send_request(endPoint, tdata, -1, nullptr, nullptr);&lt;br data-filtered=&quot;filtered&quot;&gt;}<BR>
　<BR>
<BR>
SIP服务端 发送了请求catalog  消息，摄像机端收到消息发送其自身的catalog消息，SIP 服务端将在OnReceive中收到具体的catalog消息。取catalog消息的方法如下：<BR>
<BR>
bool OnReceive(pjsip_rx_data* rdata) override<BR>
{<BR>
　　if (rdata-&gt;msg_info.cseq-&gt;method.id == PJSIP_OTHER_METHOD)<BR>
　　{<BR>
    CGXmlParser xmlParser(context.GetMessageBody(rdata));<BR>
    CGDynamicStruct dynamicStruct;<BR>
    dynamicStruct.Set(xmlParser.GetXml());<BR>
 <BR>
    auto cmd = xmlParser.GetXml()-&gt;firstChild()-&gt;nodeName();<BR>
    auto cmdType = dynamicStruct.Get&lt;std::string&gt;(&quot;CmdType&quot;);<BR>
    if (cmdType != &quot;Catalog&quot;) return false;<BR>
             <BR>
    auto DeviceID = dynamicStruct.Get&lt;std::string&gt;(&quot;DeviceID&quot;);<BR>
                 <BR>
    Vector deviceList = dynamicStruct.Get&lt;Vector&gt;(&quot;DeviceList&quot;);<BR>
 <BR>
    for (auto&amp; x : deviceList)<BR>
    {<BR>
    　　CGCatalogInfo devinfo;<BR>
    try<BR>
    {<BR>
    　　devinfo.PlatformAddr = rdata-&gt;pkt_info.src_name;<BR>
    　　devinfo.PlatformPort = rdata-&gt;pkt_info.src_port;<BR>
 <BR>
    　　devinfo.Address = x[&quot;Address&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Name = WstringToString(x[&quot;Name&quot;].convert&lt;wstring&gt;());<BR>
    　　devinfo.Manufacturer = x[&quot;Manufacturer&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Model = x[&quot;Model&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Owner = x[&quot;Owner&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Civilcode = x[&quot;CivilCode&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Registerway = x[&quot;RegisterWay&quot;].convert&lt;int&gt;();<BR>
    　　devinfo.Secrecy = x[&quot;Secrecy&quot;].convert&lt;int&gt;();<BR>
    　　//devinfo.IPAddress = x[&quot;IPAddress&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.DeviceID = x[&quot;DeviceID&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Status= x[&quot;Status&quot;].convert&lt;string&gt;();<BR>
    }<BR>
    catch (...)<BR>
    {<BR>
        //continue;<BR>
    }<BR>
    if(callback)<BR>
    {<BR>
        callback(user, &amp;devinfo);<BR>
    }<BR>
    //SipControlModule::GetInstance().CatalogCallBack(devinfo);<BR>
    }<BR>
         <BR>
    response(rdata, PJSIP_SC_OK,NoHead);<BR>
    return true;<BR>
　　SIP服务取都摄像机的信息后就可以发送请求视频信息了，请求视频最为关键的是SDP，下面看下SDP信息如何填写:<BR>
<BR>
static string createSDP(MediaContext&amp; mediaContext)<BR>
{<BR>
    char str[500] = { 0 };<BR>
    pj_ansi_snprintf(str, 500,<BR>
    &quot;v=0\n&quot;<BR>
    &quot;o=%s 0 0 IN IP4 %s\n&quot;<BR>
    &quot;s=Play\n&quot;<BR>
    &quot;c=IN IP4 %s\n&quot;<BR>
    &quot;t=0 0\n&quot;<BR>
    &quot;m=video %d RTP/AVP 96 98 97\n&quot;<BR>
    &quot;a=recvonly\n&quot;<BR>
    &quot;a=rtpmap:96 PS/90000\n&quot;<BR>
    &quot;a=rtpmap:98 H264/90000\n&quot;<BR>
    &quot;a=rtpmap:97 MPEG4/90000\n&quot;<BR>
    &quot;y=0100000001\n&quot;,<BR>
    mediaContext.GetDeviceId().c_str(),<BR>
    mediaContext.GetRecvAddress().c_str(),<BR>
    mediaContext.GetRecvAddress().c_str(),<BR>
    mediaContext.GetRecvPort()<BR>
            );<BR>
    return str;<BR>
}<BR>
　　发送请求视频命令到摄像机端当然也是通过PJSIP API实现代码如下：<BR>
bool Invite(pjsip_dialog *dlg, MediaContext mediaContext, string sdp)<BR>
{<BR>
    pjsip_inv_session *inv;<BR>
    if (PJ_SUCCESS != pjsip_inv_create_uac(dlg, nullptr, 0, &amp;inv)) return false;<BR>
    pjsip_tx_data *tdata;<BR>
    if (PJ_SUCCESS != pjsip_inv_invite(inv, &amp;tdata)) return false;<BR>
    pjsip_media_type type;<BR>
    type.type = pj_str(&quot;application&quot;);<BR>
    type.subtype = pj_str(&quot;sdp&quot;);<BR>
    auto text = pj_str(const_cast&lt;char *&gt;(sdp.c_str()));<BR>
    try<BR>
    {<BR>
        tdata-&gt;msg-&gt;body = pjsip_msg_body_create(pool, &amp;type.type, &amp;type.subtype, &amp;text);<BR>
 <BR>
        auto hName = pj_str(&quot;Subject&quot;);<BR>
        auto subjectUrl = mediaContext.GetDeviceId() + &quot;:&quot; + SiralNum + &quot;,&quot; + GetInstance().GetCode() + &quot;:&quot; + SiralNum;<BR>
        auto hValue = pj_str(const_cast&lt;char*&gt;(subjectUrl.c_str()));<BR>
        auto hdr = pjsip_generic_string_hdr_create(pool, &amp;hName, &amp;hValue);<BR>
        pjsip_msg_add_hdr(tdata-&gt;msg, reinterpret_cast&lt;pjsip_hdr*&gt;(hdr));<BR>
        pjsip_inv_send_msg(inv, tdata);<BR>
    }<BR>
    catch (...)<BR>
    {<BR>
    }<BR>
    return true;<BR>
}<BR>
　　代码就不解释了，要想知道到底发了什么还是抓个包看看，无论你用什么方法只要抓包的数据是正确定说明发送成功了。<BR>
<BR>
<BR>
<BR>
                                                图6 服务端发送invite视频消息<BR>
<BR>
摄像机端收到Invite请求后，会将视频数据以rtp的方式推送到指定的端口，端口在invite消息指定。<BR>
<BR>
这样在指定的地址（ip + port）就可以拿到数据了。<BR>
<BR>
最后提供一个测试demo，demo的作用是可以让大家抓包，看看双方都发了些什么。<BR>
<BR>
demo运行界面如下：<BR>
<BR>
<BR>
<BR>
                                                                             图6 demo运行初始界面<BR>
<BR>
1.运行demo后，首先配置好配置，如果不知道可以默认，但IP地址需要修改，端口不能被占用。<BR>
<BR>
2.完成配置各配置项以后点击获取视频源按钮 等待摄像机端注册。<BR>
<BR>
3.摄像机端开启28181功能：具体的方法可以是：平台选择方式下拉框先选择一个非28181方式，点击保存，再选择28181方式并点击保存。<BR>
<BR>
4.摄像机端成功开启28181功能以后，视频源下拉框中会显示摄像机的名称信息。<BR>
<BR>
5.选中视频源下拉框中出现的选项并点击播放按钮，正常情况下会可以播放从摄像机端过来的视频流。<BR>
<BR>
   成功接入视频源并播放的运行界面如下。<DL>
<DT>code</DT>
<!--property:date_created=1515478081-->
<!--property:date_modified=1515566957-->
<DD>
//初始化pjsip服务<BR>
bool Init(std::string concat, int logLevel)<BR>
{<BR>
    this-&gt;concat = concat;<BR>
    pj_log_set_level(logLevel);<BR>
    auto status = pj_init();<BR>
 <BR>
    status = pjlib_util_init();<BR>
 <BR>
    pj_caching_pool_init(&amp;cachingPool, &amp;pj_pool_factory_default_policy, 0);<BR>
 <BR>
    status = pjsip_endpt_create(&amp;cachingPool.factory, nullptr, &amp;endPoint);<BR>
                 <BR>
    status = pjsip_tsx_layer_init_module(endPoint);<BR>
 <BR>
    status = pjsip_ua_init_module(endPoint, nullptr);<BR>
 <BR>
    pool = pj_pool_create(&amp;cachingPool.factory, &quot;proxyapp&quot;, 4000, 4000, nullptr);<BR>
    auto pjStr =StrToPjstr(GetAddr());<BR>
 <BR>
    pj_sockaddr_in pjAddr;<BR>
    pjAddr.sin_family = pj_AF_INET();<BR>
    pj_inet_aton(&amp;pjStr, &amp;pjAddr.sin_addr);<BR>
 <BR>
    auto port = GetPort();<BR>
    pjAddr.sin_port = pj_htons(static_cast&lt;pj_uint16_t&gt;(GetPort()));<BR>
　　　　status = pjsip_udp_transport_start(endPoint, &amp;pjAddr, nullptr, 1, nullptr);<BR>
      if (status != PJ_SUCCESS) return status;<BR>
 <BR>
      auto realm = StrToPjstr(GetLocalDomain());<BR>
      return pjsip_auth_srv_init(pool, &amp;authentication, &amp;realm, lookup, 0) == PJ_SUCCESS ? true : false;<BR>
         <BR>
}<BR>
<BR>
//摄像机发送注册消息，服务器返回应答消息<BR>
bool OnReceive(pjsip_rx_data* rdata) override<BR>
{<BR>
    if(rdata-&gt;msg_info.cseq-&gt;method.id == PJSIP_REGISTER_METHOD)<BR>
    {<BR>
    　　auto expires = static_cast&lt;pjsip_expires_hdr*&gt;(pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_EXPIRES, nullptr));<BR>
    　　auto authHdr = static_cast&lt;pjsip_authorization_hdr*&gt;(pjsip_msg_find_hdr(rdata-&gt;msg_info.msg, PJSIP_H_AUTHORIZATION, nullptr));<BR>
    　　if(expires &amp;&amp; expires-&gt;ivalue &gt; 0 )<BR>
    　　{<BR>
        if(authHdr)<BR>
        {<BR>
        　　cout &lt;&lt;&quot;receive register info&quot;&lt;&lt;endl;<BR>
        　　response(rdata, PJSIP_SC_OK, DateHead);<BR>
        　　QureryDeviceInfo(rdata);<BR>
        }<BR>
        else<BR>
        {<BR>
        　　response(rdata, PJSIP_SC_UNAUTHORIZED, AuthenHead);<BR>
        }<BR>
        return true;<BR>
    　　}<BR>
    }<BR>
    return false;<BR>
}<BR>
<BR>
<BR>
//上面的回答消息要作为参数传给pjsip服务器<BR>
bool  Init(std::string concat, int loglevel)<BR>
{<BR>
　　bool ret = false;<BR>
  if(!mainModule)<BR>
　{<BR>
    ret = context.Init(concat,loglevel);<BR>
    if(!ret) return ret;<BR>
 <BR>
    static struct pjsip_module moudle =<BR>
    {<BR>
    　　nullptr, nullptr,<BR>
      { &quot;MainModule&quot;, 10 },<BR>
      -1,<BR>
     PJSIP_MOD_PRIORITY_APPLICATION,<BR>
     nullptr,<BR>
     nullptr,<BR>
     nullptr,<BR>
     nullptr,<BR>
    nullptr,<BR>
    &amp;CGSipMedia::OnReceive,<BR>
    nullptr,<BR>
    nullptr,<BR>
    nullptr,<BR>
    };<BR>
    mainModule = &amp;moudle;<BR>
    pjsip_inv_callback callback;<BR>
    pj_bzero(&amp;callback, sizeof(callback));<BR>
    callback.on_state_changed = &amp;onStateChanged;<BR>
    callback.on_new_session = &amp;onNewSession;<BR>
    callback.on_tsx_state_changed = &amp;onTsxStateChanged;<BR>
    callback.on_rx_offer = &amp;onRxOffer;<BR>
    callback.on_rx_reinvite = &amp;onRxReinvite;<BR>
    callback.on_create_offer = &amp;onCreateOffer;<BR>
    callback.on_send_ack = &amp;onSendAck;<BR>
    ret = context.RegisterCallback(&amp;callback);<BR>
    if(!ret ) return ret;<BR>
 <BR>
    context.InitModule();<BR>
    ret  = context.RegisterModule(mainModule);<BR>
    if(!ret ) return ret;<BR>
 <BR>
    CGSipModule::GetInstance().Init();<BR>
    ret = context.CreateWorkThread(&amp;proc,workthread,nullptr,&quot;proxy&quot;);<BR>
    }<BR>
    return ret;<BR>
    }<BR>
}<BR>
<BR>
OnReceive方法内Response方法实现了发送响应数据到客户端（摄像机）:<BR>
void Response(pjsip_rx_data* rdata, int st_code,int headType) <BR>
 {<BR>
  　　std::lock_guard&lt;mutex&gt; lk(lock);<BR>
     pjsip_tx_data* tdata;<BR>
   　pjsip_endpt_create_response(endPoint, rdata, st_code, nullptr, &amp;tdata);<BR>
     auto date = DateTimeFormatter::format(LocalDateTime(), &quot;%Y-%m-%dT%H:%M:%S&quot;);<BR>
     pj_str_t c;<BR>
     pj_str_t key;<BR>
     pjsip_hdr *hdr;<BR>
     switch(headType)<BR>
      {<BR>
           case DateHead:                                                        <BR>
           　　key = pj_str(&quot;Date&quot;);<BR>
           　　hdr = reinterpret_cast&lt;pjsip_hdr*&gt;(pjsip_date_hdr_create(pool, &amp;key, pj_cstr(&amp;c, date.c_str())));<BR>
          　　 pjsip_msg_add_hdr(tdata-&gt;msg, hdr);<BR>
          　　 break;<BR>
           case AuthenHead:<BR>
           　　pjsip_auth_srv_challenge(&amp;authentication, nullptr, nullptr, nullptr, PJ_FALSE, tdata);<BR>
           　　break;<BR>
              default:<BR>
               break;<BR>
       }<BR>
      pjsip_response_addr addr;<BR>
      pjsip_get_response_addr(pool, rdata, &amp;addr);<BR>
      pjsip_endpt_send_response(endPoint, &amp;addr, tdata, nullptr, nullptr);<BR>
   }<BR>
<BR>
<BR>
//服务器请求catalog消息<BR>
void QueryDeviveInfo(GBDevice *device, const string&amp; scheme = &quot;Catalog&quot;)<BR>
{<BR>
　　char szQuerInfo[200] = { 0 };<BR>
　　pj_ansi_snprintf(szQuerInfo, 200,<BR>
   &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;<BR>
   &quot;&lt;Query&gt;\n&quot;<BR>
  &quot;&lt;CmdType&gt;%s&lt;/CmdType&gt;\n&quot;<BR>
  &quot;&lt;SN&gt;17430&lt;/SN&gt;\n&quot;<BR>
  &quot;&lt;DeviceID&gt;%s&lt;/DeviceID&gt;\n&quot;<BR>
  &quot;&lt;/Query&gt;\n&quot;, scheme.c_str(), device-&gt;GetUser()<BR>
  );<BR>
　　pjsip_tx_data *tdata;<BR>
　　const pjsip_method method = { PJSIP_OTHER_METHOD,{ &quot;MESSAGE&quot;, 7 } };<BR>
　　auto text = StrToPjstr(string(szQuerInfo));<BR>
　　pjsip_endpt_create_request(endPoint, &amp;method, &amp;StrToPjstr(device-&gt;GetSipIpUrl()), &amp;StrToPjstr(concat), &amp;StrToPjstr(device-&gt;GetSipCodecUrl()),&amp;StrToPjstr(concat), nullptr, -1, &amp;text, &amp;tdata);<BR>
　　tdata-&gt;msg-&gt;body-&gt;content_type.type = pj_str(&quot;Application&quot;);<BR>
　　tdata-&gt;msg-&gt;body-&gt;content_type.subtype = pj_str(&quot;MANSCDP+xml&quot;);<BR>
　　pjsip_endpt_send_request(endPoint, tdata, -1, nullptr, nullptr);<BR>
}<BR>
<BR>
//服务器接收摄像机传回的catalog消息<BR>
bool OnReceive(pjsip_rx_data* rdata) override<BR>
{<BR>
　　if (rdata-&gt;msg_info.cseq-&gt;method.id == PJSIP_OTHER_METHOD)<BR>
　　{<BR>
    CGXmlParser xmlParser(context.GetMessageBody(rdata));<BR>
    CGDynamicStruct dynamicStruct;<BR>
    dynamicStruct.Set(xmlParser.GetXml());<BR>
 <BR>
    auto cmd = xmlParser.GetXml()-&gt;firstChild()-&gt;nodeName();<BR>
    auto cmdType = dynamicStruct.Get&lt;std::string&gt;(&quot;CmdType&quot;);<BR>
    if (cmdType != &quot;Catalog&quot;) return false;<BR>
             <BR>
    auto DeviceID = dynamicStruct.Get&lt;std::string&gt;(&quot;DeviceID&quot;);<BR>
                 <BR>
    Vector deviceList = dynamicStruct.Get&lt;Vector&gt;(&quot;DeviceList&quot;);<BR>
 <BR>
    for (auto&amp; x : deviceList)<BR>
    {<BR>
    　　CGCatalogInfo devinfo;<BR>
    try<BR>
    {<BR>
    　　devinfo.PlatformAddr = rdata-&gt;pkt_info.src_name;<BR>
    　　devinfo.PlatformPort = rdata-&gt;pkt_info.src_port;<BR>
 <BR>
    　　devinfo.Address = x[&quot;Address&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Name = WstringToString(x[&quot;Name&quot;].convert&lt;wstring&gt;());<BR>
    　　devinfo.Manufacturer = x[&quot;Manufacturer&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Model = x[&quot;Model&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Owner = x[&quot;Owner&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Civilcode = x[&quot;CivilCode&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Registerway = x[&quot;RegisterWay&quot;].convert&lt;int&gt;();<BR>
    　　devinfo.Secrecy = x[&quot;Secrecy&quot;].convert&lt;int&gt;();<BR>
    　　//devinfo.IPAddress = x[&quot;IPAddress&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.DeviceID = x[&quot;DeviceID&quot;].convert&lt;string&gt;();<BR>
    　　devinfo.Status= x[&quot;Status&quot;].convert&lt;string&gt;();<BR>
    }<BR>
    catch (...)<BR>
    {<BR>
        //continue;<BR>
    }<BR>
    if(callback)<BR>
    {<BR>
        callback(user, &amp;devinfo);<BR>
    }<BR>
    //SipControlModule::GetInstance().CatalogCallBack(devinfo);<BR>
    }<BR>
         <BR>
    response(rdata, PJSIP_SC_OK,NoHead);<BR>
    return true;<BR>
}<BR>
<BR>
//服务器接收到catalog消息后，解析摄像机信息，然后回执SDP，请求视频信息<BR>
static string createSDP(MediaContext&amp; mediaContext)<BR>
{<BR>
    char str[500] = { 0 };<BR>
    pj_ansi_snprintf(str, 500,<BR>
    &quot;v=0\n&quot;<BR>
    &quot;o=%s 0 0 IN IP4 %s\n&quot;<BR>
    &quot;s=Play\n&quot;<BR>
    &quot;c=IN IP4 %s\n&quot;<BR>
    &quot;t=0 0\n&quot;<BR>
    &quot;m=video %d RTP/AVP 96 98 97\n&quot;<BR>
    &quot;a=recvonly\n&quot;<BR>
    &quot;a=rtpmap:96 PS/90000\n&quot;<BR>
    &quot;a=rtpmap:98 H264/90000\n&quot;<BR>
    &quot;a=rtpmap:97 MPEG4/90000\n&quot;<BR>
    &quot;y=0100000001\n&quot;,<BR>
    mediaContext.GetDeviceId().c_str(),<BR>
    mediaContext.GetRecvAddress().c_str(),<BR>
    mediaContext.GetRecvAddress().c_str(),<BR>
    mediaContext.GetRecvPort()<BR>
            );<BR>
    return str;<BR>
}<BR>
<BR>
<BR>
//请求视频函数<BR>
bool Invite(pjsip_dialog *dlg, MediaContext mediaContext, string sdp)<BR>
{<BR>
    pjsip_inv_session *inv;<BR>
    if (PJ_SUCCESS != pjsip_inv_create_uac(dlg, nullptr, 0, &amp;inv)) return false;<BR>
    pjsip_tx_data *tdata;<BR>
    if (PJ_SUCCESS != pjsip_inv_invite(inv, &amp;tdata)) return false;<BR>
    pjsip_media_type type;<BR>
    type.type = pj_str(&quot;application&quot;);<BR>
    type.subtype = pj_str(&quot;sdp&quot;);<BR>
    auto text = pj_str(const_cast&lt;char *&gt;(sdp.c_str()));<BR>
    try<BR>
    {<BR>
        tdata-&gt;msg-&gt;body = pjsip_msg_body_create(pool, &amp;type.type, &amp;type.subtype, &amp;text);<BR>
 <BR>
        auto hName = pj_str(&quot;Subject&quot;);<BR>
        auto subjectUrl = mediaContext.GetDeviceId() + &quot;:&quot; + SiralNum + &quot;,&quot; + GetInstance().GetCode() + &quot;:&quot; + SiralNum;<BR>
        auto hValue = pj_str(const_cast&lt;char*&gt;(subjectUrl.c_str()));<BR>
        auto hdr = pjsip_generic_string_hdr_create(pool, &amp;hName, &amp;hValue);<BR>
        pjsip_msg_add_hdr(tdata-&gt;msg, reinterpret_cast&lt;pjsip_hdr*&gt;(hdr));<BR>
        pjsip_inv_send_msg(inv, tdata);<BR>
    }<BR>
    catch (...)<BR>
    {<BR>
    }<BR>
    return true;<BR>
}<BR>
<BR>
//摄像机接收到请求信息后将视频以rtp的方式传输给指定----端口ip地址
</DD>
</DL>

</DD>
<DT>GB28181</DT>
<!--property:date_created=1515740245-->
<!--property:date_modified=1515740245-->
<DD>
<DL>
<DT>平台接入</DT>
<!--property:date_created=1515740253-->
<!--property:date_modified=1515740259-->
<DD>
libosip+libexosip+libxml<BR>
<BR>
前面两者负责sip协议的实现，libxml用来封装和解析实体信令<BR>
<BR>
  流媒体方面：从编码中获取的h.264+g711的视音频帧，进行PS媒体协议封装（自己写的PS封装协议），再经过RTP传输协议（自己实现）发送至平台<BR>
<BR>
 平台对收到的RTP流媒体进行解RTP,解PS，再进行h.264+g711的解码。<BR>
<BR>
<BR>
opensips,pjproject,ffmpeg<BR>
<BR>
<BR>
<BR>
uac功能实现<BR>
/*<BR>
  2  ===============================================================<BR>
  3  GBT28181 基于eXosip2,osip库实现注册UAC功能<BR>
  4  作者：程序人生<BR>
  5  博客地址：http://blog.csdn.net/hiwubihe<BR>
  6  QQ：1269122125<BR>
  7  注：请尊重原作者劳动成果，仅供学习使用，请勿盗用，违者必究！<BR>
  8  ================================================================<BR>
  9  */<BR>
 10 <BR>
 11 #include &lt;iostream&gt;<BR>
 12 #include &lt;string&gt;<BR>
 13 #include &lt;sstream&gt;<BR>
 14 #include &lt;osipparser2/osip_message.h&gt;<BR>
 15 #include &lt;osipparser2/osip_parser.h&gt;<BR>
 16 #include &lt;osipparser2/osip_port.h&gt;<BR>
 17 <BR>
 18 #include &lt;eXosip2/eXosip.h&gt;<BR>
 19 #include &lt;eXosip2/eX_setup.h&gt;<BR>
 20 #include &lt;eXosip2/eX_register.h&gt;<BR>
 21 #include &lt;eXosip2/eX_options.h&gt;<BR>
 22 #include &lt;eXosip2/eX_message.h&gt;<BR>
 23 #include &lt;arpa/inet.h&gt;<BR>
 24 #include &lt;sys/types.h&gt;<BR>
 25 #include &lt;sys/socket.h&gt;<BR>
 26 <BR>
 27 using namespace std;<BR>
 28 <BR>
 29 //本地监听IP<BR>
 30 #define LISTEN_ADDR (&quot;192.168.50.57&quot;)<BR>
 31 //本地监听端口<BR>
 32 #define UACPORT (&quot;5061&quot;)<BR>
 33 #define UACPORTINT (5061)<BR>
 34 //本UAC地址编码<BR>
 35 #define UACCODE (&quot;100110000201000000&quot;)<BR>
 36 //本地UAC密码<BR>
 37 #define UACPWD (&quot;12345&quot;)<BR>
 38 //远程UAS IP<BR>
 39 #define UAS_ADDR (&quot;192.168.50.57&quot;)<BR>
 40 //远程UAS 端口<BR>
 41 #define UAS_PORT (&quot;5060&quot;)<BR>
 42 //超时<BR>
 43 #define EXPIS 300<BR>
 44 <BR>
 45 //当前服务状态 1 已经注册 0 未注册<BR>
 46 static int iCurrentStatus;<BR>
 47 //注册成功HANDLE<BR>
 48 static int iHandle = -1;<BR>
 49 <BR>
 50 //SIP From/To 头部<BR>
 51 class CSipFromToHeader<BR>
 52 {<BR>
 53 public:<BR>
 54     CSipFromToHeader()<BR>
 55     {<BR>
 56     }<BR>
 57     ~CSipFromToHeader()<BR>
 58     {<BR>
 59     }<BR>
 60     void SetHeader(string addrCod, string addrI, string addrPor)<BR>
 61     {<BR>
 62         addrCode = addrCod;<BR>
 63         addrIp = addrI;<BR>
 64         addrPort = addrPor;<BR>
 65     }<BR>
 66     string GetFormatHeader()<BR>
 67     {<BR>
 68         std::stringstream stream;<BR>
 69         stream &lt;&lt; &quot;sip: &quot; &lt;&lt; addrCode &lt;&lt; &quot;@&quot; &lt;&lt; addrIp &lt;&lt; &quot;:&quot; &lt;&lt; addrPort;<BR>
 70         return stream.str();<BR>
 71     }<BR>
 72     //主机名称<BR>
 73     string GetCode()<BR>
 74     {<BR>
 75         std::stringstream stream;<BR>
 76         stream &lt;&lt; addrCode;<BR>
 77         return stream.str();<BR>
 78     }<BR>
 79     //主机地址<BR>
 80     string GetAddr()<BR>
 81     {<BR>
 82         std::stringstream stream;<BR>
 83         stream &lt;&lt; addrIp;<BR>
 84         return stream.str();<BR>
 85     }<BR>
 86     //端口<BR>
 87     string GetPort()<BR>
 88     {<BR>
 89         std::stringstream stream;<BR>
 90         stream &lt;&lt; addrPort;<BR>
 91         return stream.str();<BR>
 92     }<BR>
 93 <BR>
 94 private:<BR>
 95     string addrCode;<BR>
 96     string addrIp;<BR>
 97     string addrPort;<BR>
 98 };<BR>
 99 <BR>
100 //SIP Contract头部<BR>
101 class CContractHeader: public CSipFromToHeader<BR>
102 {<BR>
103 public:<BR>
104     CContractHeader()<BR>
105     {<BR>
106     }<BR>
107     ~CContractHeader()<BR>
108     {<BR>
109     }<BR>
110     void SetContractHeader(string addrCod, string addrI, string addrPor)<BR>
111     {<BR>
112         SetHeader(addrCod, addrI, addrPor);<BR>
113     }<BR>
114     string GetContractFormatHeader()<BR>
115     {<BR>
116 <BR>
117         std::stringstream stream;<BR>
118         stream &lt;&lt; &quot;&lt;sip:&quot; &lt;&lt; GetCode() &lt;&lt; &quot;@&quot; &lt;&lt; GetAddr() &lt;&lt; &quot;:&quot; &lt;&lt; GetPort()<BR>
119                 &lt;&lt; &quot;&gt;&quot;;<BR>
120         return stream.str();<BR>
121     }<BR>
122 };<BR>
123 <BR>
124 //发送注册信息<BR>
125 int SendRegister(int&amp; registerId, CSipFromToHeader &amp;from, CSipFromToHeader &amp;to,<BR>
126         CContractHeader &amp;contact, const string&amp; userName, const string&amp; pwd,<BR>
127         const int expires, int iType)<BR>
128 {<BR>
129     cout &lt;&lt; &quot;=============================================&quot; &lt;&lt; endl;<BR>
130     if (iType == 0)<BR>
131     {<BR>
132         cout &lt;&lt; &quot;注册请求信息：&quot; &lt;&lt; endl;<BR>
133     }<BR>
134     else if (iType == 1)<BR>
135     {<BR>
136         cout &lt;&lt; &quot;刷新注册信息：&quot; &lt;&lt; endl;<BR>
137     }<BR>
138     else<BR>
139     {<BR>
140         cout &lt;&lt; &quot;注销信息:&quot; &lt;&lt; endl;<BR>
141     }<BR>
142     cout &lt;&lt; &quot;registerId &quot; &lt;&lt; registerId &lt;&lt; endl;<BR>
143     cout &lt;&lt; &quot;from &quot; &lt;&lt; from.GetFormatHeader() &lt;&lt; endl;<BR>
144     cout &lt;&lt; &quot;to &quot; &lt;&lt; to.GetFormatHeader() &lt;&lt; endl;<BR>
145     cout &lt;&lt; &quot;contact&quot; &lt;&lt; contact.GetContractFormatHeader() &lt;&lt; endl;<BR>
146     cout &lt;&lt; &quot;userName&quot; &lt;&lt; userName &lt;&lt; endl;<BR>
147     cout &lt;&lt; &quot;pwd&quot; &lt;&lt; pwd &lt;&lt; endl;<BR>
148     cout &lt;&lt; &quot;expires&quot; &lt;&lt; expires &lt;&lt; endl;<BR>
149     cout &lt;&lt; &quot;=============================================&quot; &lt;&lt; endl;<BR>
150     //服务器注册<BR>
151     static osip_message_t *regMsg = 0;<BR>
152     int ret;<BR>
153 <BR>
154     ::eXosip_add_authentication_info(userName.c_str(), userName.c_str(),<BR>
155             pwd.c_str(), &quot;MD5&quot;, NULL);<BR>
156     eXosip_lock();<BR>
157     //发送注册信息 401响应由eXosip2库自动发送<BR>
158     if (0 == registerId)<BR>
159     {<BR>
160         // 注册消息的初始化<BR>
161         registerId = ::eXosip_register_build_initial_register(<BR>
162                 from.GetFormatHeader().c_str(), to.GetFormatHeader().c_str(),<BR>
163                 contact.GetContractFormatHeader().c_str(), expires, &amp;regMsg);<BR>
164         if (registerId &lt;= 0)<BR>
165         {<BR>
166             return -1;<BR>
167         }<BR>
168     }<BR>
169     else<BR>
170     {<BR>
171         // 构建注册消息<BR>
172         ret = ::eXosip_register_build_register(registerId, expires, &amp;regMsg);<BR>
173         if (ret != OSIP_SUCCESS)<BR>
174         {<BR>
175             return ret;<BR>
176         }<BR>
177         //添加注销原因<BR>
178         if (expires == 0)<BR>
179         {<BR>
180             osip_contact_t *contact = NULL;<BR>
181             char tmp[128];<BR>
182 <BR>
183             osip_message_get_contact(regMsg, 0, &amp;contact);<BR>
184             {<BR>
185                 sprintf(tmp, &quot;&lt;sip:%s@%s:%s&gt;;expires=0&quot;,<BR>
186                         contact-&gt;url-&gt;username, contact-&gt;url-&gt;host,<BR>
187                         contact-&gt;url-&gt;port);<BR>
188             }<BR>
189             //osip_contact_free(contact);<BR>
190             //reset contact header<BR>
191             osip_list_remove(&amp;regMsg-&gt;contacts, 0);<BR>
192             osip_message_set_contact(regMsg, tmp);<BR>
193             osip_message_set_header(regMsg, &quot;Logout-Reason&quot;, &quot;logout&quot;);<BR>
194         }<BR>
195     }<BR>
196     // 发送注册消息<BR>
197     ret = ::eXosip_register_send_register(registerId, regMsg);<BR>
198     if (ret != OSIP_SUCCESS)<BR>
199     {<BR>
200         registerId = 0;<BR>
201     }eXosip_unlock();<BR>
202 <BR>
203     return ret;<BR>
204 }<BR>
205 <BR>
206 //注册<BR>
207 void Register()<BR>
208 {<BR>
209     if (iCurrentStatus == 1)<BR>
210     {<BR>
211         cout &lt;&lt; &quot;当前已经注册&quot; &lt;&lt; endl;<BR>
212         return;<BR>
213     }<BR>
214     CSipFromToHeader stFrom;<BR>
215     stFrom.SetHeader(UACCODE, UAS_ADDR, UAS_PORT);<BR>
216     CSipFromToHeader stTo;<BR>
217     stTo.SetHeader(UACCODE, UAS_ADDR, UAS_PORT);<BR>
218     CContractHeader stContract;<BR>
219     stContract.SetContractHeader(UACCODE, LISTEN_ADDR, UACPORT);<BR>
220     //发送注册信息<BR>
221     int registerId = 0;<BR>
222     if (0 &gt; SendRegister(registerId, stFrom, stTo, stContract, UACCODE, UACPWD,<BR>
223             3000, 0))<BR>
224     {<BR>
225         cout &lt;&lt; &quot;发送注册失败&quot; &lt;&lt; endl;<BR>
226         return;<BR>
227     }<BR>
228     iCurrentStatus = 1;<BR>
229     iHandle = registerId;<BR>
230 }<BR>
231 //刷新注册<BR>
232 void RefreshRegister()<BR>
233 {<BR>
234     if (iCurrentStatus == 0)<BR>
235     {<BR>
236         cout &lt;&lt; &quot;当前未注册，不允许刷新&quot; &lt;&lt; endl;<BR>
237         return;<BR>
238     }<BR>
239     CSipFromToHeader stFrom;<BR>
240     stFrom.SetHeader(UACCODE, UAS_ADDR, UAS_PORT);<BR>
241     CSipFromToHeader stTo;<BR>
242     stTo.SetHeader(UACCODE, UAS_ADDR, UAS_PORT);<BR>
243     CContractHeader stContract;<BR>
244     stContract.SetContractHeader(UACCODE, LISTEN_ADDR, UACPORT);<BR>
245     //发送注册信息<BR>
246     if (0 &gt; SendRegister(iHandle, stFrom, stTo, stContract, UACCODE, UACPWD,<BR>
247             3000, 1))<BR>
248     {<BR>
249         cout &lt;&lt; &quot;发送刷新注册失败&quot; &lt;&lt; endl;<BR>
250         return;<BR>
251     }<BR>
252 }<BR>
253 //注销<BR>
254 void UnRegister()<BR>
255 {<BR>
256     if (iCurrentStatus == 0)<BR>
257     {<BR>
258         cout &lt;&lt; &quot;当前未注册，不允许注销&quot; &lt;&lt; endl;<BR>
259         return;<BR>
260     }<BR>
261     CSipFromToHeader stFrom;<BR>
262     stFrom.SetHeader(UACCODE, UAS_ADDR, UAS_PORT);<BR>
263     CSipFromToHeader stTo;<BR>
264     stTo.SetHeader(UACCODE, UAS_ADDR, UAS_PORT);<BR>
265     CContractHeader stContract;<BR>
266     stContract.SetContractHeader(UACCODE, LISTEN_ADDR, UACPORT);<BR>
267     //发送注册信息<BR>
268269     if (0 &gt; SendRegister( iHandle, stFrom, stTo, stContract, UACCODE, UACPWD,<BR>
270             0, 2))<BR>
271     {<BR>
272         cout &lt;&lt; &quot;发送注销失败&quot; &lt;&lt; endl;<BR>
273         return;<BR>
274     }<BR>
275     iCurrentStatus = 0;<BR>
276     iHandle = -1;<BR>
277 }<BR>
278 static void help()<BR>
279 {<BR>
280     const char<BR>
281             *b =<BR>
282     &quot;-------------------------------------------------------------------------------\n&quot;<BR>
283     &quot;SIP Library test process - uac v 1.0 (June 13, 2014)\n\n&quot;<BR>
284     &quot;SIP UAC端 注册,刷新注册,注销实现\n\n&quot;<BR>
285     &quot;Author: 程序人生\n\n&quot;<BR>
286     &quot;博客地址:http://blog.csdn.net/hiwubihe QQ:1269122125\n\n&quot;<BR>
287     &quot;-------------------------------------------------------------------------------\n&quot;<BR>
288     &quot;\n&quot;<BR>
289     &quot;              0:Register\n&quot;<BR>
290     &quot;              1:RefreshRegister\n&quot;<BR>
291     &quot;              2:UnRegister\n&quot;<BR>
292     &quot;              3:clear scream\n&quot;<BR>
293     &quot;              4:exit\n&quot;<BR>
294     &quot;-------------------------------------------------------------------------------\n&quot;<BR>
295     &quot;\n&quot;;<BR>
296     fprintf(stderr, b, strlen(b));<BR>
297     cout &lt;&lt; &quot;please select method :&quot;;<BR>
298 }<BR>
299 //服务处理线程<BR>
300 void *serverHandle(void *pUser)<BR>
301 {<BR>
302     sleep(3);<BR>
303     help();<BR>
304     char ch = getchar();<BR>
305     getchar();<BR>
306     while (1)<BR>
307     {<BR>
308         switch (ch)<BR>
309         {<BR>
310         case '0':<BR>
311             //注册<BR>
312             Register();<BR>
313             break;<BR>
314         case '1':<BR>
315             //刷新注册<BR>
316             RefreshRegister();<BR>
317             break;<BR>
318         case '2':<BR>
319             //注销<BR>
320             UnRegister();<BR>
321             break;<BR>
322         case '3':<BR>
323             if (system(&quot;clear&quot;) &lt; 0)<BR>
324             {<BR>
325                 cout &lt;&lt; &quot;clear scream error&quot; &lt;&lt; endl;<BR>
326                 exit(1);<BR>
327             }<BR>
328             break;<BR>
329         case '4':<BR>
330             cout &lt;&lt; &quot;exit sipserver......&quot; &lt;&lt; endl;<BR>
331             getchar();<BR>
332             exit(0);<BR>
333         default:<BR>
334             cout &lt;&lt; &quot;select error&quot; &lt;&lt; endl;<BR>
335             break;<BR>
336         }<BR>
337         cout &lt;&lt; &quot;press any key to continue......&quot; &lt;&lt; endl;<BR>
338         getchar();<BR>
339         help();<BR>
340         ch = getchar();<BR>
341         getchar();<BR>
342     }<BR>
343     return NULL;<BR>
344 }<BR>
345 <BR>
346 //事件处理线程<BR>
347 void *eventHandle(void *pUser)<BR>
348 {<BR>
349     eXosip_event_t* osipEventPtr = (eXosip_event_t*) pUser;<BR>
350     switch (osipEventPtr-&gt;type)<BR>
351     {<BR>
352     //需要继续验证REGISTER是什么类型<BR>
353     case EXOSIP_REGISTRATION_SUCCESS:<BR>
354     case EXOSIP_REGISTRATION_FAILURE:<BR>
355     {<BR>
356         cout&lt;&lt;&quot;收到状态码:&quot;&lt;&lt;osipEventPtr-&gt;response-&gt;status_code&lt;&lt;&quot;报文&quot;&lt;&lt;endl;<BR>
357         if(osipEventPtr-&gt;response-&gt;status_code == 401)<BR>
358         {<BR>
359             cout&lt;&lt;&quot;发送鉴权报文&quot;&lt;&lt;endl;<BR>
360         }<BR>
361         else if(osipEventPtr-&gt;response-&gt;status_code == 200)<BR>
362         {<BR>
363             cout&lt;&lt;&quot;接收成功&quot;&lt;&lt;endl;<BR>
364         }<BR>
365         else<BR>
366         {}<BR>
367     }<BR>
368         break;<BR>
369     default:<BR>
370         cout &lt;&lt; &quot;The sip event type that not be precessed.the event &quot;<BR>
371             &quot;type is : &quot; &lt;&lt; osipEventPtr-&gt;type &lt;&lt; endl;<BR>
372         break;<BR>
373     }<BR>
374     eXosip_event_free(osipEventPtr);<BR>
375     return NULL;<BR>
376 }<BR>
377 <BR>
378 int main()<BR>
379 {<BR>
380     iCurrentStatus = 0;<BR>
381     //库处理结果<BR>
382     int result = OSIP_SUCCESS;<BR>
383     //初始化库<BR>
384     if (OSIP_SUCCESS != (result = eXosip_init()))<BR>
385     {<BR>
386         printf(&quot;eXosip_init failure.\n&quot;);<BR>
387         return 1;<BR>
388     }<BR>
389     cout &lt;&lt; &quot;eXosip_init success.&quot; &lt;&lt; endl;<BR>
390     eXosip_set_user_agent(NULL);<BR>
391     //监听<BR>
392     if (OSIP_SUCCESS != eXosip_listen_addr(IPPROTO_UDP, NULL, UACPORTINT,<BR>
393             AF_INET, 0))<BR>
394     {<BR>
395         printf(&quot;eXosip_listen_addr failure.\n&quot;);<BR>
396         return 1;<BR>
397     }<BR>
398     //设置监听网卡<BR>
399     if (OSIP_SUCCESS != eXosip_set_option(<BR>
400     EXOSIP_OPT_SET_IPV4_FOR_GATEWAY,<BR>
401             LISTEN_ADDR))<BR>
402     {<BR>
403         return -1;<BR>
404     }<BR>
405     //开启服务线程<BR>
406     pthread_t pthser;<BR>
407     if (0 != pthread_create(&amp;pthser, NULL, serverHandle, NULL))<BR>
408     {<BR>
409         printf(&quot;创建主服务失败\n&quot;);<BR>
410         return -1;<BR>
411     }<BR>
412     //事件用于等待<BR>
413     eXosip_event_t* osipEventPtr = NULL;<BR>
414     //开启事件循环<BR>
415     while (true)<BR>
416     {<BR>
417         //等待事件 0的单位是秒，500是毫秒<BR>
418         osipEventPtr = ::eXosip_event_wait(0, 200);<BR>
419         //处理eXosip库默认处理<BR>
420         {<BR>
421             usleep(500 * 1000);<BR>
422             eXosip_lock();<BR>
423             //一般处理401/407采用库默认处理<BR>
424             eXosip_default_action(osipEventPtr);<BR>
425             eXosip_unlock();<BR>
426         }<BR>
427         //事件空继续等待<BR>
428         if (NULL == osipEventPtr)<BR>
429         {<BR>
430             continue;<BR>
431         }<BR>
432         //开启线程处理事件并在事件处理完毕将事件指针释放<BR>
433         pthread_t pth;<BR>
434         if (0 != pthread_create(&amp;pth, NULL, eventHandle, (void*) osipEventPtr))<BR>
435         {<BR>
436             printf(&quot;创建线程处理事件失败\n&quot;);<BR>
437             continue;<BR>
438         }<BR>
439         osipEventPtr = NULL;<BR>
440     }<BR>
441 }
</DD>
<DT>UAC</DT>
<!--property:date_created=1515740275-->
<!--property:date_modified=1515740280-->
<DD>
代理客户端程序<BR>
<BR>
/** <BR>
 * 一个使用了 osip 和 eXosip 库的 UAC 代理客户端的演示程序 <BR>
 *  <BR>
 * - 只是简单的演示了使用了 osip 和 eXosip2 库的 UAC 代理客户端的如下几个功能： <BR>
 * * i 发起呼叫 INVITE 请求 <BR>
 * * h 挂断会话 <BR>
 * * s 执行方法 INFO  <BR>
 * * m 执行方法 MESSAGE <BR>
 *  <BR>
 * 编 译：g++ -I/usr/local/include -L/usr/local/lib ua_client.cpp -o ua_client -leXosip2 -losip2 -losipparser2 -lpthread <BR>
 *  <BR>
 */  <BR>
  <BR>
#include &lt;osip2/osip_mt.h&gt;  <BR>
#include &lt;eXosip2/eXosip.h&gt;  <BR>
  <BR>
#include &lt;netinet/in.h&gt;  <BR>
#include &lt;sys/socket.h&gt;  <BR>
#include &lt;sys/types.h&gt;  <BR>
  <BR>
#include &lt;iostream&gt;  <BR>
#include &lt;string&gt;  <BR>
  <BR>
using namespace std;  <BR>
  <BR>
int main(int argc, char* argv[])  <BR>
{  <BR>
    eXosip_event_t *je;  <BR>
    osip_message_t *reg = NULL;  <BR>
    osip_message_t *invite = NULL;  <BR>
    osip_message_t *ack = NULL;  <BR>
    osip_message_t *info = NULL;  <BR>
    osip_message_t *message = NULL;  <BR>
    int call_id, dialog_id;  <BR>
    int i,flag;  <BR>
    int flag1 = 1;  <BR>
    int id;  <BR>
      <BR>
    string strIdentity = &quot;sip:136@133.37.55.136&quot;;  <BR>
    string strRegisterer = &quot;sip:133.37.55.136:5060&quot;; // server ip  <BR>
  <BR>
    string strSrcCall = &quot;sip:136@133.37.55.136&quot;;  <BR>
    string strDestCall = &quot;sip:136@133.37.55.136:5060&quot;; // server ip  <BR>
  <BR>
      <BR>
    char command;  <BR>
    char tmp[4096];  <BR>
    char localip[128];  <BR>
  <BR>
    string strHelp = string(&quot;\n\t--&gt; 命令字符 功能描述 &lt;--\n\n&quot;)  <BR>
                        + &quot;\t\tr 向服务器注册\n&quot;  <BR>
                        + &quot;\t\tc 取消注册\n&quot;  <BR>
                        + &quot;\t\ti 发起呼叫请求\n&quot;  <BR>
                        + &quot;\t\th 挂断\n&quot;  <BR>
                        + &quot;\t\tq 退出程序\n&quot;  <BR>
                        + &quot;\t\ts 执行方法 INFO\n&quot;  <BR>
                        + &quot;\t\tm 执行方法 MESSAGE\n&quot;  <BR>
                        + &quot;\t\te 帮助\n\n&quot;;  <BR>
    cout &lt;&lt; strHelp;  <BR>
  <BR>
    string strMsg;  <BR>
  <BR>
    i = eXosip_init ();  <BR>
    if (i != 0)  <BR>
    {  <BR>
        cout &lt;&lt; &quot;\t--&gt; Couldn't initialize eXosip! &lt;--\n&quot;;  <BR>
        return -1;  <BR>
    }  <BR>
    else  <BR>
    {  <BR>
        cout &lt;&lt; &quot;\t--&gt; eXosip_init successfully! &lt;-- \n\n&quot;;  <BR>
    }  <BR>
  <BR>
    i = eXosip_listen_addr (IPPROTO_UDP, NULL, 5061, AF_INET, 0);  <BR>
    if (i != 0)  <BR>
    {  <BR>
        eXosip_quit ();  <BR>
        cerr &lt;&lt; &quot;\n\t--&gt; Couldn't initialize transport layer! &lt;-- \n\n&quot;;  <BR>
        return -1;  <BR>
    }  <BR>
    flag = 1;  <BR>
    while (flag)  <BR>
    {  <BR>
        cout &lt;&lt; &quot;请输入一个命令字符：\t&quot;;  <BR>
        cin &gt;&gt; command;  <BR>
        <BR>
        switch (command)  <BR>
        {  <BR>
        case 'r':  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; This modal isn't commpleted! \n&quot; &lt;&lt; endl;  <BR>
            break;  <BR>
  <BR>
        case 'i': // 初始化的 INVITE 请求  <BR>
            i = eXosip_call_build_initial_invite (&amp;invite,   <BR>
                                                  strDestCall.c_str(),   <BR>
                                                  strSrcCall.c_str(),   <BR>
                                                  NULL,   <BR>
                                                  &quot;This is a call for a conversation&quot;);  <BR>
            if (i != 0)  <BR>
            {  <BR>
                cout &lt;&lt; &quot;\n --&gt; Intial INVITE failed! &lt;-- \n&quot;;  <BR>
                break;  <BR>
            }  <BR>
  <BR>
            // 符合 SDP 格式, 其中属性 a 是自定义格式,也就是说可以存放自己的信息,   <BR>
            // 但是只能是两列,比如帐户信息  <BR>
            // 但是经测试,格式: v o t必不可少,原因未知,估计是协议栈在传输时需要检查的  <BR>
  <BR>
            strMsg = string(&quot;v=0\r\n&quot;)  <BR>
                   + &quot;o=anonymous 0 0 IN IP4 0.0.0.0\r\n&quot;  <BR>
                   + &quot;t=1 10\r\n&quot;  <BR>
                   + &quot;a=username:bluesea\r\n&quot;  <BR>
                   + &quot;a=password:123456\r\n&quot;;  <BR>
  <BR>
            osip_message_set_body (invite, strMsg.c_str(), strMsg.length());  <BR>
            osip_message_set_content_type (invite, &quot;application/sdp&quot;);  <BR>
        <BR>
            // 这里使用了锁机制以保证同步  <BR>
            eXosip_lock ();  <BR>
            i = eXosip_call_send_initial_invite (invite);  <BR>
            eXosip_unlock ();  <BR>
            flag1 = 1;  <BR>
            while (flag1)  <BR>
            {  <BR>
                je = eXosip_event_wait (0, 200);  <BR>
                if (je == NULL)  <BR>
                {  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; No response or the time is over! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
                }  <BR>
            <BR>
                switch (je-&gt;type)  <BR>
                {  <BR>
                case EXOSIP_CALL_INVITE:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; a new invite reveived! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                // announce processing by a remote app  <BR>
                case EXOSIP_CALL_PROCEEDING:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; proceeding! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                // announce ringback  <BR>
                case EXOSIP_CALL_RINGING:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; ringing! &lt;--\n&quot;   <BR>
                         &lt;&lt; &quot;\n\tcall_id is &quot; &lt;&lt; je-&gt;cid   <BR>
                         &lt;&lt; &quot;, dialog_id is &quot; &lt;&lt; je-&gt;did &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                // 收到请求，表示连接成功，下面发送回复确认  <BR>
                case EXOSIP_CALL_ANSWERED:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; ok! connected! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    call_id = je-&gt;cid;  <BR>
                    dialog_id = je-&gt;did;  <BR>
                    cout &lt;&lt; &quot;\n\tcall_id is &quot; &lt;&lt; je-&gt;cid   <BR>
                         &lt;&lt; &quot;, dialog_id is &quot; &lt;&lt; je-&gt;did &lt;&lt; endl;  <BR>
                    eXosip_call_build_ack (je-&gt;did, &amp;ack);  <BR>
                    eXosip_call_send_ack (je-&gt;did, ack);  <BR>
                    flag1 = 0;  <BR>
                    break;  <BR>
  <BR>
                case EXOSIP_CALL_CLOSED:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; the other sid closed! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                case EXOSIP_CALL_ACK:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; ACK received! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                default:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; other response!\n&quot; &lt;&lt;endl;  <BR>
                    break;  <BR>
                }  <BR>
            <BR>
                eXosip_event_free (je);  <BR>
            }  <BR>
  <BR>
            break;  <BR>
  <BR>
        case 'h':  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; Holded ! \n&quot; &lt;&lt; endl;  <BR>
        <BR>
            eXosip_lock ();  <BR>
            eXosip_call_terminate (call_id, dialog_id);  <BR>
            eXosip_unlock ();  <BR>
            break;  <BR>
  <BR>
        case 'c':  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; This modal isn't commpleted! \n&quot; &lt;&lt; endl;  <BR>
            break;  <BR>
  <BR>
        case 's':  <BR>
            // 传输 INFO 方法  <BR>
            eXosip_call_build_info (dialog_id, &amp;info);  <BR>
              <BR>
            snprintf (tmp , 4096, &quot;hello,bluesea&quot;);  <BR>
            osip_message_set_body (info, tmp, strlen(tmp));  <BR>
  <BR>
            // 格式可以任意设定, text/plain 代表文本信息  <BR>
            osip_message_set_content_type (info, &quot;text/plain&quot;);  <BR>
            eXosip_call_send_request (dialog_id, info);  <BR>
            break;  <BR>
  <BR>
        case 'm':  <BR>
            // 传输 MESSAGE方法,也就是即时消息，  <BR>
            // 和 INFO 方法相比，主要区别，是 MESSAGE 不用建立连接，直接传输信息，  <BR>
            // 而 INFO 必须在建立 INVITE 的基础上传输。  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; the mothed :MESSAGE \n&quot; &lt;&lt; endl;  <BR>
            eXosip_message_build_request (&amp;message,   <BR>
                                          &quot;MESSAGE&quot;,   <BR>
                                          strDestCall.c_str(),   <BR>
                                          strSrcCall.c_str(),   <BR>
                                          NULL);  <BR>
            strMsg = &quot;message: hello bluesea!&quot;;  <BR>
            osip_message_set_body (message, strMsg.c_str(), strMsg.length());  <BR>
        <BR>
            // 假设格式是xml  <BR>
            osip_message_set_content_type (message, &quot;text/xml&quot;);  <BR>
            eXosip_message_send_request (message);  <BR>
            break;  <BR>
  <BR>
        case 'q':  <BR>
            eXosip_quit ();  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; Exit the setup! \n&quot; &lt;&lt; endl;;  <BR>
            flag = 0;  <BR>
            break;  <BR>
  <BR>
        case 'e':  <BR>
            cout &lt;&lt; strHelp &lt;&lt; endl;  <BR>
            break;  <BR>
  <BR>
        default:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; 不支持的命令 &lt;--\n&quot; &lt;&lt; endl;  <BR>
            break;  <BR>
        }  <BR>
    }  <BR>
  <BR>
    return 0;  <BR>
}  <BR>
<BR>
<BR>
<BR>
、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、<BR>
	USA代理服务器程序<BR>
<BR>
<BR>
/** <BR>
 * 一个使用了 osip 和 eXosip 库的 UAS 代理服务端的演示程序 <BR>
 *  <BR>
 * - 只是简单的演示了使用了 osip 和 eXosip2 库的 UAS 代理服务端的如下几个功能： <BR>
 *  <BR>
 * 编 译：g++ -I/usr/local/include -L/usr/local/lib ua_server.cpp -o ua_server -leXosip2 -losip2 -losipparser2 -lpthread <BR>
 *  <BR>
 */  <BR>
  <BR>
#include &lt;eXosip2/eXosip.h&gt;  <BR>
  <BR>
#include &lt;netinet/in.h&gt;  <BR>
#include &lt;sys/socket.h&gt;  <BR>
#include &lt;sys/types.h&gt;  <BR>
  <BR>
#include &lt;iostream&gt;  <BR>
#include &lt;fstream&gt;  <BR>
#include &lt;string&gt;  <BR>
  <BR>
using namespace std;  <BR>
  <BR>
int main()  <BR>
{  <BR>
    eXosip_event_t *je = NULL;  <BR>
    osip_message_t *ack = NULL;  <BR>
    osip_message_t *invite = NULL;  <BR>
    osip_message_t *answer = NULL;  <BR>
    sdp_message_t *remote_sdp = NULL;  <BR>
    int call_id, dialog_id;  <BR>
    int i,j;  <BR>
    int id;  <BR>
  <BR>
    char *sour_call = &quot;sip:136@133.37.55.136&quot;;  <BR>
    char *dest_call = &quot;sip:136@133.37.55.136:5061&quot;; //client ip/port  <BR>
  <BR>
    char command;  <BR>
    char tmp[4096];  <BR>
    char localip[128];  <BR>
    int pos = 0;  <BR>
  <BR>
    // 初始化 sip  <BR>
    i = eXosip_init ();  <BR>
    if (i != 0)  <BR>
    {  <BR>
        cerr &lt;&lt; &quot;\n\t--&gt; Can't initialize eXosip!\n&quot;;  <BR>
        return -1;  <BR>
    }  <BR>
    else  <BR>
    {  <BR>
        cout &lt;&lt; &quot;\n\t--&gt; eXosip_init successfully!\n&quot;;  <BR>
    }  <BR>
      <BR>
    i = eXosip_listen_addr (IPPROTO_UDP, NULL, 5060, AF_INET, 0);  <BR>
    if (i != 0)  <BR>
    {  <BR>
        eXosip_quit ();  <BR>
        cerr &lt;&lt; &quot;\n\t--&gt; eXosip_listen_addr error! Couldn't initialize transport layer!\n&quot;;  <BR>
    }  <BR>
  <BR>
    for(;;)  <BR>
    {  <BR>
        // 侦听是否有消息到来  <BR>
        je = eXosip_event_wait (0, 50);   <BR>
  <BR>
        // 协议栈带有此语句,具体作用未知  <BR>
        eXosip_lock ();  <BR>
        eXosip_default_action (je);  <BR>
        eXosip_automatic_refresh ();  <BR>
        eXosip_unlock ();  <BR>
  <BR>
        if (je == NULL) // 没有接收到消息，继续  <BR>
        {  <BR>
            continue;  <BR>
        }  <BR>
  <BR>
        switch (je-&gt;type)  <BR>
        {  <BR>
        case EXOSIP_MESSAGE_NEW: // 新的消息到来  <BR>
            cout &lt;&lt; &quot;\n\t*** EXOSIP_MESSAGE_NEW!\n&quot; &lt;&lt; endl;  <BR>
  <BR>
            if (MSG_IS_MESSAGE (je-&gt;request)) // 如果接收到的消息类型是 MESSAGE  <BR>
            {  <BR>
                {  <BR>
                    osip_body_t *body;  <BR>
                    osip_message_get_body (je-&gt;request, 0, &amp;body);   <BR>
                    cout &lt;&lt; &quot;I get the msg is: &quot; &lt;&lt; body-&gt;body &lt;&lt; endl;  <BR>
                }  <BR>
  <BR>
                // 按照规则，需要回复 OK 信息  <BR>
                eXosip_message_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
                eXosip_message_send_answer (je-&gt;tid, 200, answer);  <BR>
            }  <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_INVITE: // INVITE 请求消息  <BR>
            // 得到接收到消息的具体信息  <BR>
            cout &lt;&lt; &quot;\n\tReceived a INVITE msg from &quot; &lt;&lt; je-&gt;request-&gt;req_uri-&gt;host   <BR>
                 &lt;&lt; &quot; : &quot; &lt;&lt; je-&gt;request-&gt;req_uri-&gt;port   <BR>
                 &lt;&lt; &quot;, username is &quot; &lt;&lt; je-&gt;request-&gt;req_uri-&gt;username &lt;&lt; endl;  <BR>
  <BR>
            // 得到消息体,认为该消息就是 SDP 格式.  <BR>
            remote_sdp = eXosip_get_remote_sdp (je-&gt;did);  <BR>
            call_id = je-&gt;cid;  <BR>
            dialog_id = je-&gt;did;  <BR>
          <BR>
            eXosip_lock ();  <BR>
  <BR>
            eXosip_call_send_answer (je-&gt;tid, 180, NULL);  <BR>
            i = eXosip_call_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
            if (i != 0)  <BR>
            {  <BR>
                cout &lt;&lt; &quot;\n\t--&gt; This request msg is invalid! Cann't response!\n&quot; &lt;&lt; endl;  <BR>
                eXosip_call_send_answer (je-&gt;tid, 400, NULL);  <BR>
            }  <BR>
            else  <BR>
            {  <BR>
                snprintf (tmp, 4096,  <BR>
                    &quot;v=0\r\n&quot;  <BR>
                    &quot;o=anonymous 0 0 IN IP4 0.0.0.0\r\n&quot;  <BR>
                    &quot;t=1 10\r\n&quot;  <BR>
                    &quot;a=username:rainfish\r\n&quot;  <BR>
                    &quot;a=password:123\r\n&quot;);  <BR>
              <BR>
                // 设置回复的SDP消息体,下一步计划分析消息体  <BR>
                // 没有分析消息体，直接回复原来的消息，这一块做的不好。  <BR>
                osip_message_set_body (answer, tmp, strlen(tmp));  <BR>
                osip_message_set_content_type (answer, &quot;application/sdp&quot;);  <BR>
              <BR>
                eXosip_call_send_answer (je-&gt;tid, 200, answer);  <BR>
                cout &lt;&lt; &quot;\n\t--&gt; send 200 over!&quot; &lt;&lt; endl;  <BR>
            }  <BR>
  <BR>
            eXosip_unlock ();  <BR>
          <BR>
            // 显示出在 sdp 消息体中的 attribute 的内容,里面计划存放我们的信息  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; The INFO is :\n&quot; ;  <BR>
            while (!osip_list_eol ( &amp;(remote_sdp-&gt;a_attributes), pos))  <BR>
            {  <BR>
                sdp_attribute_t *at;  <BR>
              <BR>
                //这里解释了为什么在SDP消息体中属性a里面存放必须是两列  <BR>
                at = (sdp_attribute_t *) osip_list_get ( &amp;remote_sdp-&gt;a_attributes, pos);  <BR>
                cout &lt;&lt; &quot;\n\t&quot; &lt;&lt; at-&gt;a_att_field   <BR>
                     &lt;&lt; &quot; : &quot; &lt;&lt; at-&gt;a_att_value &lt;&lt; endl;  <BR>
              <BR>
                pos ++;  <BR>
            }  <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_ACK:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; ACK recieved!\n&quot; &lt;&lt; endl;  <BR>
            // printf (&quot;the cid is %s, did is %s\n&quot;, je-&gt;did, je-&gt;cid);   <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_CLOSED:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; the remote hold the session!\n&quot; &lt;&lt; endl;  <BR>
            // eXosip_call_build_ack(dialog_id, &amp;ack);  <BR>
            // eXosip_call_send_ack(dialog_id, ack);   <BR>
            i = eXosip_call_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
            if (i != 0)  <BR>
            {  <BR>
                printf (&quot;This request msg is invalid!Cann't response!\n&quot;);  <BR>
                eXosip_call_send_answer (je-&gt;tid, 400, NULL);  <BR>
            }  <BR>
            else  <BR>
            {  <BR>
                eXosip_call_send_answer (je-&gt;tid, 200, answer);  <BR>
                cout &lt;&lt; &quot;\n\t--&gt; bye send 200 over!\n&quot;;  <BR>
            }   <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_MESSAGE_NEW:  <BR>
  <BR>
            cout &lt;&lt; &quot;\n\t*** EXOSIP_CALL_MESSAGE_NEW\n&quot; &lt;&lt; endl;  <BR>
            if (MSG_IS_INFO(je-&gt;request) ) // 如果传输的是 INFO 方法  <BR>
            {  <BR>
                eXosip_lock ();  <BR>
                i = eXosip_call_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
                if (i == 0)  <BR>
                {  <BR>
                    eXosip_call_send_answer (je-&gt;tid, 200, answer);  <BR>
                }  <BR>
  <BR>
                eXosip_unlock ();  <BR>
  <BR>
                {  <BR>
                    osip_body_t *body;  <BR>
                    osip_message_get_body (je-&gt;request, 0, &amp;body);  <BR>
                    cout &lt;&lt; &quot;the body is &quot; &lt;&lt; body-&gt;body &lt;&lt; endl;  <BR>
                }  <BR>
            }  <BR>
            break;   <BR>
  <BR>
        default:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; Could not parse the msg!\n&quot; &lt;&lt; endl;  <BR>
        }  <BR>
    }   <BR>
  <BR>
    return 0;  <BR>
}  
</DD>
<DT>opencv</DT>
<!--property:date_created=1515740310-->
<!--property:date_modified=1515740318-->
<!--property:expanded-->
<DD>
clone opencv 和 opencv_conrib<BR>
<BR>
现在CMake<BR>
<BR>
configure<BR>
<BR>
配置<BR>
OPENCV_EXTRA_MODULES_PATH = opencv_contirb的path<DL>
<DT>编译</DT>
<!--property:date_created=1515740334-->
<!--property:date_modified=1515740334-->
<DT>人脸识别</DT>
<!--property:date_created=1515740503-->
<!--property:date_modified=1515740503-->
<!--property:expanded-->
<DD>
<DL>
<DT>基于python</DT>
<!--property:date_created=1515740512-->
<!--property:date_modified=1515740538-->
<DD>
openCV3的安装这里我说一下mac上的安装方法<BR>
<BR>
openCV3 在mac采用brew安装  如果brew没用过可以看下我之前写的安装Libpng的帖子里面有一些注意事项<BR>
<BR>
brew update #更新brew<BR>
<BR>
brew install opencv3 --with-contrib --with-python3 --without-python  #安装opencv3 保证python为3.x<BR>
<BR>
正常情况下就开始安装了 安装之后 找到opencv的so文件 <BR>
<BR>
默认在  /usr/local/Cellar/opencv3/3.1.0_4/lib/python3.6/site-packages/   #根据你的版本会有差异<BR>
<BR>
找到你python的安装位置的site-packages 目录<BR>
<BR>
默认在  /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/ #根据你的版本会有差异<BR>
<BR>
然后做一个软链<BR>
<BR>
ln -s /usr/local/Cellar/opencv3/3.2.0/lib/python3.6/site-packages/cv2.cpython-36m-darwin.so ./cv2<BR>
<BR>
<BR>
import cv2  <BR>
import numpy as np  <BR>
#指定图片的人脸识别然后存储  <BR>
img = cv2.imread(&quot;./333.jpg&quot;)  <BR>
color = (0, 255, 0)  <BR>
  <BR>
grey = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  <BR>
  <BR>
classfier = cv2.CascadeClassifier(&quot;./data/haarcascades/haarcascade_frontalface_alt2.xml&quot;)  <BR>
  <BR>
faceRects = classfier.detectMultiScale(grey, scaleFactor=1.2, minNeighbors=3, minSize=(32, 32))  <BR>
if len(faceRects) &gt; 0:  # 大于0则检测到人脸  <BR>
    for faceRect in faceRects:  # 单独框出每一张人脸  <BR>
        x, y, w, h = faceRect  <BR>
        cv2.rectangle(img, (x - 10, y - 10), (x + w + 10, y + h + 10), color, 3) #5控制绿色框的粗细  <BR>
  <BR>
# 写入图像  <BR>
cv2.imwrite('./aaa.jpg',img)  
</DD>
</DL>

</DD>
</DL>

</DD>
</DL>

</DD>
<DT>opencv</DT>
<!--property:date_created=1515752319-->
<!--property:date_modified=1515752319-->
<DD>
<DL>
<DT>opencv编译</DT>
<!--property:date_created=1515752333-->
<!--property:date_modified=1515752900-->
<DD>
https://github.com/opencv/opencv_3rdparty/branches/all<BR>
第三方库<BR>
<BR>
ffmpeg处理<BR>
1.解压压缩文件，获得目录中的三个文件 ffmpeg_version.cmake/opencv_ffmpeg.dll/opencv_ffmpeg_64.dll<BR>
<BR>
复制到opencv/sources/3rdparty/ffmpeg目录下<BR>
<BR>
编辑 ffmpeg.cmake<BR>
message(STATUS &quot;FFMPEG: Package successfully downloaded&quot;)<BR>
include(${CMAKE_CURRENT_LIST_DIR}/ffmpeg_version.cmake)<BR>
<BR>
ipppicv配置<BR>
解压文件<BR>
创建文件夹<BR>
unpack,解压得到的ippicv_win复制到新建的unpack中<BR>
将downloader.cmake内容修改为<BR>
#<BR>
# The script downloads ICV package<BR>
#<BR>
# On return this will define:<BR>
# OPENCV_ICV_PATH - path to unpacked downloaded package<BR>
#<BR>
<BR>
function(_icv_downloader)<BR>
  # Commit SHA in the opencv_3rdparty repo<BR>
  set(IPPICV_BINARIES_COMMIT &quot;81a676001ca8075ada498583e4166079e5744668&quot;)<BR>
  # Define actual ICV versions<BR>
  if(APPLE)<BR>
    set(OPENCV_ICV_PACKAGE_NAME &quot;ippicv_macosx_20151201.tgz&quot;)<BR>
    set(OPENCV_ICV_PACKAGE_HASH &quot;4ff1fde9a7cfdfe7250bfcd8334e0f2f&quot;)<BR>
    set(OPENCV_ICV_PLATFORM &quot;macosx&quot;)<BR>
    set(OPENCV_ICV_PACKAGE_SUBDIR &quot;/ippicv_osx&quot;)<BR>
  elseif(UNIX)<BR>
    if(ANDROID AND NOT (ANDROID_ABI STREQUAL x86 OR ANDROID_ABI STREQUAL x86_64))<BR>
      return()<BR>
    endif()<BR>
    set(OPENCV_ICV_PACKAGE_NAME &quot;ippicv_linux_20151201.tgz&quot;)<BR>
    set(OPENCV_ICV_PACKAGE_HASH &quot;808b791a6eac9ed78d32a7666804320e&quot;)<BR>
    set(OPENCV_ICV_PLATFORM &quot;linux&quot;)<BR>
    set(OPENCV_ICV_PACKAGE_SUBDIR &quot;/ippicv_lnx&quot;)<BR>
  elseif(WIN32 AND NOT ARM)<BR>
    set(OPENCV_ICV_PACKAGE_NAME &quot;ippicv_windows_20151201.zip&quot;)<BR>
    set(OPENCV_ICV_PACKAGE_HASH &quot;04e81ce5d0e329c3fbc606ae32cad44d&quot;)<BR>
    set(OPENCV_ICV_PLATFORM &quot;windows&quot;)<BR>
    set(OPENCV_ICV_PACKAGE_SUBDIR &quot;/ippicv_win&quot;)<BR>
  else()<BR>
    return() # Not supported<BR>
  endif()<BR>
<BR>
  set(OPENCV_ICV_UNPACK_PATH &quot;${CMAKE_CURRENT_LIST_DIR}/unpack&quot;)<BR>
  set(OPENCV_ICV_PATH &quot;${OPENCV_ICV_UNPACK_PATH}${OPENCV_ICV_PACKAGE_SUBDIR}&quot;)<BR>
<BR>
  message(STATUS &quot;ICV: Package successfully downloaded&quot;)<BR>
  set(OPENCV_ICV_PATH &quot;${OPENCV_ICV_PATH}&quot; PARENT_SCOPE)<BR>
endfunction()<BR>
<BR>
_icv_downloader()<BR>
<BR>
处理face_landmark_model.dat文件下载失败原因<BR>
<BR>

</DD>
<DT>New node</DT>
<!--property:date_created=1516249394-->
<!--property:date_modified=1516249394-->
</DL>

</DD>
<DT>Osip2&amp;Exosip2</DT>
<!--property:date_created=1515575286-->
<!--property:date_modified=1515575473-->
<DD>
<BR>
库名	功能<BR>
Osip2	一个开源的SIP协议栈，使用C编写，主要提供解析SIP和SDP消息的API和事物处理的状态机。<BR>
Exosip2	是对Osip2协议栈的封装和调用，作为Osip2的一个扩展协议集，使得Osip2更容易被使用。<BR>
Boost	一个准标准库，相当于对STL的的延续和扩充。<BR>
Loki	C++的模板类库<BR>
<BR>
sip事务的概念：一个sip请求以及由它触发的一系列应答（包括临时应答和一个最终应答）。<BR>
<BR>
sip请求有6种（核心规范定义的，也有扩展），也叫6个方法(Method字段标识)：INVITE, ACK, OPTIONS, BYE, CANCEL, REGISTER<BR>
<BR>
sip 请求的格式包括请求行(如INVITE sip:192.168.101.30 SIP/2.0)，sip应答的格式包括状态行(如SIP/2.0 100 Trying)；sip应答的状态码从100到699，其中100~199是临时(provisional)应答。<BR>
<BR>
INVITE请求是三次握手机制，其他请求都采用两次握手机制。<BR>
<BR>
CANCEL 请求用于取消悬而未决的事务，我的理解是一方发出INVITE，但是另一方始终没有做出应答，发出200OK消息（超过了默认的振铃时长），那么UAC会 自动发出一个CANCEL请求，UAS返回200OK，并且同时发出487状态码的应答，UAC再对收到的487消息发出ACK确认，即最开始的 INVITE和487以及ACK构成三次握手。<BR>
<BR>
OPTIONS请求用于询问服务器的性能情况，包括这个服务器所支持的方法（可能会有扩展方法）和会话描述协议。<BR>
<BR>
代理服务器的三种类型：保留呼叫状态代理、保留状态代理、不保留状态代理。这三种类型的代理在处理能力和所占用资源上有差别，在代理分发中我们采用网络核心无状态，而在流量较小的网络边界采用智能性高的保留（呼叫）状态服务器处理路由。<BR>
<BR>
sip消息编码采用文本方式（即使用字符串），相对的是二进制的编码方式，前者易于调试和扩展，后者则有利于节省带宽。<BR>
<BR>
sip标题头：<BR>
CALL-ID 字 段用于标识一个特定邀请以及与这个邀请相关的所有后续事务（即标识一个会话），比如一方发起邀请加入一个国际象棋的会话，那么INVITE请求以及应答， BYE请求以及应答都共享一个CALL-ID，因为这两个事务都属于一个特定邀请。而两个用户之间可以同时存在多个邀请（比如在下象棋的同时发起聊天的邀 请），那么一个邀请中的后续事务将通过这个邀请特有的CALL-ID来区分，如一方发出BYE消息来结束聊天，但是下棋仍然进行中，那么另一方将根据 BYE消息的CALL-ID来确定要结束的究竟是哪一个会话。 <BR>
<BR>
CSeq 字段是用来给同一个会话中的 事务进行排序的。可以理解为，会话由CALL-ID来标识，会话中的事务则由CSeq标识。除了ACK请求和CANCEL请求，INVITE之后的请求中 CSeq字段的数字是最初请求(INVITE)的CSeq递增的结果。而ACK和CANCEL请求则拥有与它所确认（取消）的请求相同的CSeq数字部 分，只是方法名不同。<BR>
(sip标题头续)<BR>
Contact 字段是被呼叫方发送200OK消息时带上的，包含了被叫方的真实IP，这样sip服务器在路由第一个INVITE请求之后就可以被卸载掉（越过），不再需要存在于信令路径中。<BR>
<BR>
Recode-Route和Route字 段是用来使sip服务器保留在每次请求中，不被绕过。Record-Route字段由信令路径上的服务器添加（每经过一个信令路径上必须存在的代理，就添 加一个Record-Route标题头），maddr参数包含该代理的IP地址。被叫方发出的200OK应答包含Record-Route和 Contact字段（Record-Route可能有多个），呼叫方收到200OK后根据这两个字段创建用于后续请求的Route标题头（可能有多个）， 其包含的是信令路径上的下一跳的下一跳的（hehe，有点别扭，不过意思是对的）真实IP。<BR>
<BR>
To 字段 总是包含被呼叫方的地址（通过sip代理时是公用地址，点对点时是真实ip），要注意的是区别该标题头和sip消息请求行中的Request-URI。 To在信令路径中不会被代理改变，然而Request-URI包含的是信令路径中下一跳的地址，因此在路途中被每个代理改变。<BR>
<BR>
Via 字 段存储所有处理请求的代理地址（包括用户代理和sip代理），它可以用来检测路由循环，也用于使应答消息经过请求消息来时相同的路径（方向相反）。因此， 在请求消息发送时，via标题头的数量是随着跳数逐渐增加的，而应答消息返回时，via标题头的数量则逐渐递减（每经过一跳则剥离一个有它自己地址的 Via标题头）。<BR>
(sip标题头完)<BR>
<BR>
sip消息可能含有消息体（一个或多个），通常是会话描述符，也可以是照片或其他附件。一般情况下，消息体只对UA有意义，因此可被端到端加密。有时候，sip代理处于控制的原因也需要检查被交换媒体的信息。 <BR>
 NVITE事务：<BR>
<BR>
SIP使用UDP传输协议来传送INVITE消息时，要使用逐 跳重传机制保证INVITE的最终传送，即用户代理UA和sip代理proxy都要保证INVITE到达下一跳，下一跳收到时会返回一个临时应答 （proxy返回100Trying，UA返回100Trying和180ringing），代理在限定时间内收不到应答即会重传INVITE。<BR>
<BR>
临时应答（100~199）用于阻止逐跳INVITE重传，没有端到端的可靠传输，也就是说当被叫方返回180应答时，如果在路径中途丢失，也不会重传。<BR>
<BR>
最终应答（200~699）能被保证到达它们想要去的目的地。<BR>
成 功应答（200~299）被可靠地传送到呼叫方UA，但不是使用逐跳重传机制。只有呼叫方UA能为最终成功应答发送一个ACK（直接发送到被叫方UA）， 如果成功应答在路径中途丢失或者UA发出的ACK丢失，那么被叫方会在限定时间内收不到ACK时重新发送最终应答，直到收到ACK的确认。<BR>
非成功最终应答（300~699）使用和INVITE一样的逐跳机制。被叫方用户代理将持续重传非成功应答（给前一跳），直到收到ACK为止（proxy也可以为非成功应答发送ACK）。<BR>
CANCEL事务：<BR>
CANCEL事务与INVITE事务都是逐跳事务，但是处理方法不同，路径上的每一个代理收到CANCEL请求时，都会发送一个最终应答来响应（而不是发出临时应答），并且向下一跳发送一个CANCEL请求。
</DD>
<DT>osip</DT>
<!--property:date_created=1515669641-->
<!--property:date_modified=1515669654-->
<DD>
ares_platform.h,<BR>
<BR>
ares_platform.c,<BR>
<BR>
ares_create_query.c<DL>
<DT>UAC代理</DT>
<!--property:date_created=1515731364-->
<!--property:date_modified=1515731372-->
<!--property:expanded-->
<DD>
    ----------- UAC 代理客户端的代码整理 ---------------  <BR>
   <BR>
/** <BR>
 * 一个使用了 osip 和 eXosip 库的 UAC 代理客户端的演示程序 <BR>
 *  <BR>
 * - 只是简单的演示了使用了 osip 和 eXosip2 库的 UAC 代理客户端的如下几个功能： <BR>
 * * i 发起呼叫 INVITE 请求 <BR>
 * * h 挂断会话 <BR>
 * * s 执行方法 INFO  <BR>
 * * m 执行方法 MESSAGE <BR>
 *  <BR>
 * 编 译：g++ -I/usr/local/include -L/usr/local/lib ua_client.cpp -o ua_client -leXosip2 -losip2 -losipparser2 -lpthread <BR>
 *  <BR>
 */  <BR>
  <BR>
#include &lt;osip2/osip_mt.h&gt;  <BR>
#include &lt;eXosip2/eXosip.h&gt;  <BR>
  <BR>
#include &lt;netinet/in.h&gt;  <BR>
#include &lt;sys/socket.h&gt;  <BR>
#include &lt;sys/types.h&gt;  <BR>
  <BR>
#include &lt;iostream&gt;  <BR>
#include &lt;string&gt;  <BR>
  <BR>
using namespace std;  <BR>
  <BR>
int main(int argc, char* argv[])  <BR>
{  <BR>
    eXosip_event_t *je;  <BR>
    osip_message_t *reg = NULL;  <BR>
    osip_message_t *invite = NULL;  <BR>
    osip_message_t *ack = NULL;  <BR>
    osip_message_t *info = NULL;  <BR>
    osip_message_t *message = NULL;  <BR>
    int call_id, dialog_id;  <BR>
    int i,flag;  <BR>
    int flag1 = 1;  <BR>
    int id;  <BR>
      <BR>
    string strIdentity = &quot;sip:136@133.37.55.136&quot;;  <BR>
    string strRegisterer = &quot;sip:133.37.55.136:5060&quot;; // server ip  <BR>
  <BR>
    string strSrcCall = &quot;sip:136@133.37.55.136&quot;;  <BR>
    string strDestCall = &quot;sip:136@133.37.55.136:5060&quot;; // server ip  <BR>
  <BR>
      <BR>
    char command;  <BR>
    char tmp[4096];  <BR>
    char localip[128];  <BR>
  <BR>
    string strHelp = string(&quot;\n\t--&gt; 命令字符 功能描述 &lt;--\n\n&quot;)  <BR>
                        + &quot;\t\tr 向服务器注册\n&quot;  <BR>
                        + &quot;\t\tc 取消注册\n&quot;  <BR>
                        + &quot;\t\ti 发起呼叫请求\n&quot;  <BR>
                        + &quot;\t\th 挂断\n&quot;  <BR>
                        + &quot;\t\tq 退出程序\n&quot;  <BR>
                        + &quot;\t\ts 执行方法 INFO\n&quot;  <BR>
                        + &quot;\t\tm 执行方法 MESSAGE\n&quot;  <BR>
                        + &quot;\t\te 帮助\n\n&quot;;  <BR>
    cout &lt;&lt; strHelp;  <BR>
  <BR>
    string strMsg;  <BR>
  <BR>
    i = eXosip_init ();  <BR>
    if (i != 0)  <BR>
    {  <BR>
        cout &lt;&lt; &quot;\t--&gt; Couldn't initialize eXosip! &lt;--\n&quot;;  <BR>
        return -1;  <BR>
    }  <BR>
    else  <BR>
    {  <BR>
        cout &lt;&lt; &quot;\t--&gt; eXosip_init successfully! &lt;-- \n\n&quot;;  <BR>
    }  <BR>
  <BR>
    i = eXosip_listen_addr (IPPROTO_UDP, NULL, 5061, AF_INET, 0);  <BR>
    if (i != 0)  <BR>
    {  <BR>
        eXosip_quit ();  <BR>
        cerr &lt;&lt; &quot;\n\t--&gt; Couldn't initialize transport layer! &lt;-- \n\n&quot;;  <BR>
        return -1;  <BR>
    }  <BR>
    flag = 1;  <BR>
    while (flag)  <BR>
    {  <BR>
        cout &lt;&lt; &quot;请输入一个命令字符：\t&quot;;  <BR>
        cin &gt;&gt; command;  <BR>
        <BR>
        switch (command)  <BR>
        {  <BR>
        case 'r':  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; This modal isn't commpleted! \n&quot; &lt;&lt; endl;  <BR>
            break;  <BR>
  <BR>
        case 'i': // 初始化的 INVITE 请求  <BR>
            i = eXosip_call_build_initial_invite (&amp;invite,   <BR>
                                                  strDestCall.c_str(),   <BR>
                                                  strSrcCall.c_str(),   <BR>
                                                  NULL,   <BR>
                                                  &quot;This is a call for a conversation&quot;);  <BR>
            if (i != 0)  <BR>
            {  <BR>
                cout &lt;&lt; &quot;\n --&gt; Intial INVITE failed! &lt;-- \n&quot;;  <BR>
                break;  <BR>
            }  <BR>
  <BR>
            // 符合 SDP 格式, 其中属性 a 是自定义格式,也就是说可以存放自己的信息,   <BR>
            // 但是只能是两列,比如帐户信息  <BR>
            // 但是经测试,格式: v o t必不可少,原因未知,估计是协议栈在传输时需要检查的  <BR>
  <BR>
            strMsg = string(&quot;v=0\r\n&quot;)  <BR>
                   + &quot;o=anonymous 0 0 IN IP4 0.0.0.0\r\n&quot;  <BR>
                   + &quot;t=1 10\r\n&quot;  <BR>
                   + &quot;a=username:bluesea\r\n&quot;  <BR>
                   + &quot;a=password:123456\r\n&quot;;  <BR>
  <BR>
            osip_message_set_body (invite, strMsg.c_str(), strMsg.length());  <BR>
            osip_message_set_content_type (invite, &quot;application/sdp&quot;);  <BR>
        <BR>
            // 这里使用了锁机制以保证同步  <BR>
            eXosip_lock ();  <BR>
            i = eXosip_call_send_initial_invite (invite);  <BR>
            eXosip_unlock ();  <BR>
            flag1 = 1;  <BR>
            while (flag1)  <BR>
            {  <BR>
                je = eXosip_event_wait (0, 200);  <BR>
                if (je == NULL)  <BR>
                {  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; No response or the time is over! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
                }  <BR>
            <BR>
                switch (je-&gt;type)  <BR>
                {  <BR>
                case EXOSIP_CALL_INVITE:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; a new invite reveived! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                // announce processing by a remote app  <BR>
                case EXOSIP_CALL_PROCEEDING:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; proceeding! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                // announce ringback  <BR>
                case EXOSIP_CALL_RINGING:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; ringing! &lt;--\n&quot;   <BR>
                         &lt;&lt; &quot;\n\tcall_id is &quot; &lt;&lt; je-&gt;cid   <BR>
                         &lt;&lt; &quot;, dialog_id is &quot; &lt;&lt; je-&gt;did &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                // 收到请求，表示连接成功，下面发送回复确认  <BR>
                case EXOSIP_CALL_ANSWERED:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; ok! connected! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    call_id = je-&gt;cid;  <BR>
                    dialog_id = je-&gt;did;  <BR>
                    cout &lt;&lt; &quot;\n\tcall_id is &quot; &lt;&lt; je-&gt;cid   <BR>
                         &lt;&lt; &quot;, dialog_id is &quot; &lt;&lt; je-&gt;did &lt;&lt; endl;  <BR>
                    eXosip_call_build_ack (je-&gt;did, &amp;ack);  <BR>
                    eXosip_call_send_ack (je-&gt;did, ack);  <BR>
                    flag1 = 0;  <BR>
                    break;  <BR>
  <BR>
                case EXOSIP_CALL_CLOSED:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; the other sid closed! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                case EXOSIP_CALL_ACK:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; ACK received! &lt;--\n&quot; &lt;&lt; endl;  <BR>
                    break;  <BR>
  <BR>
                default:  <BR>
                    cout &lt;&lt; &quot;\n\t--&gt; other response!\n&quot; &lt;&lt;endl;  <BR>
                    break;  <BR>
                }  <BR>
            <BR>
                eXosip_event_free (je);  <BR>
            }  <BR>
  <BR>
            break;  <BR>
  <BR>
        case 'h':  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; Holded ! \n&quot; &lt;&lt; endl;  <BR>
        <BR>
            eXosip_lock ();  <BR>
            eXosip_call_terminate (call_id, dialog_id);  <BR>
            eXosip_unlock ();  <BR>
            break;  <BR>
  <BR>
        case 'c':  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; This modal isn't commpleted! \n&quot; &lt;&lt; endl;  <BR>
            break;  <BR>
  <BR>
        case 's':  <BR>
            // 传输 INFO 方法  <BR>
            eXosip_call_build_info (dialog_id, &amp;info);  <BR>
              <BR>
            snprintf (tmp , 4096, &quot;hello,bluesea&quot;);  <BR>
            osip_message_set_body (info, tmp, strlen(tmp));  <BR>
  <BR>
            // 格式可以任意设定, text/plain 代表文本信息  <BR>
            osip_message_set_content_type (info, &quot;text/plain&quot;);  <BR>
            eXosip_call_send_request (dialog_id, info);  <BR>
            break;  <BR>
  <BR>
        case 'm':  <BR>
            // 传输 MESSAGE方法,也就是即时消息，  <BR>
            // 和 INFO 方法相比，主要区别，是 MESSAGE 不用建立连接，直接传输信息，  <BR>
            // 而 INFO 必须在建立 INVITE 的基础上传输。  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; the mothed :MESSAGE \n&quot; &lt;&lt; endl;  <BR>
            eXosip_message_build_request (&amp;message,   <BR>
                                          &quot;MESSAGE&quot;,   <BR>
                                          strDestCall.c_str(),   <BR>
                                          strSrcCall.c_str(),   <BR>
                                          NULL);  <BR>
            strMsg = &quot;message: hello bluesea!&quot;;  <BR>
            osip_message_set_body (message, strMsg.c_str(), strMsg.length());  <BR>
        <BR>
            // 假设格式是xml  <BR>
            osip_message_set_content_type (message, &quot;text/xml&quot;);  <BR>
            eXosip_message_send_request (message);  <BR>
            break;  <BR>
  <BR>
        case 'q':  <BR>
            eXosip_quit ();  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; Exit the setup! \n&quot; &lt;&lt; endl;;  <BR>
            flag = 0;  <BR>
            break;  <BR>
  <BR>
        case 'e':  <BR>
            cout &lt;&lt; strHelp &lt;&lt; endl;  <BR>
            break;  <BR>
  <BR>
        default:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; 不支持的命令 &lt;--\n&quot; &lt;&lt; endl;  <BR>
            break;  <BR>
        }  <BR>
    }  <BR>
  <BR>
    return 0;  <BR>
}  <BR>
    ----------- UAS 代理服务器端的代码整理 ---------------  <BR>
  <BR>
/** <BR>
 * 一个使用了 osip 和 eXosip 库的 UAS 代理服务端的演示程序 <BR>
 *  <BR>
 * - 只是简单的演示了使用了 osip 和 eXosip2 库的 UAS 代理服务端的如下几个功能： <BR>
 *  <BR>
 * 编 译：g++ -I/usr/local/include -L/usr/local/lib ua_server.cpp -o ua_server -leXosip2 -losip2 -losipparser2 -lpthread <BR>
 *  <BR>
 */  <BR>
  <BR>
#include &lt;eXosip2/eXosip.h&gt;  <BR>
  <BR>
#include &lt;netinet/in.h&gt;  <BR>
#include &lt;sys/socket.h&gt;  <BR>
#include &lt;sys/types.h&gt;  <BR>
  <BR>
#include &lt;iostream&gt;  <BR>
#include &lt;fstream&gt;  <BR>
#include &lt;string&gt;  <BR>
  <BR>
using namespace std;  <BR>
  <BR>
int main()  <BR>
{  <BR>
    eXosip_event_t *je = NULL;  <BR>
    osip_message_t *ack = NULL;  <BR>
    osip_message_t *invite = NULL;  <BR>
    osip_message_t *answer = NULL;  <BR>
    sdp_message_t *remote_sdp = NULL;  <BR>
    int call_id, dialog_id;  <BR>
    int i,j;  <BR>
    int id;  <BR>
  <BR>
    char *sour_call = &quot;sip:136@133.37.55.136&quot;;  <BR>
    char *dest_call = &quot;sip:136@133.37.55.136:5061&quot;; //client ip/port  <BR>
  <BR>
    char command;  <BR>
    char tmp[4096];  <BR>
    char localip[128];  <BR>
    int pos = 0;  <BR>
  <BR>
    // 初始化 sip  <BR>
    i = eXosip_init ();  <BR>
    if (i != 0)  <BR>
    {  <BR>
        cerr &lt;&lt; &quot;\n\t--&gt; Can't initialize eXosip!\n&quot;;  <BR>
        return -1;  <BR>
    }  <BR>
    else  <BR>
    {  <BR>
        cout &lt;&lt; &quot;\n\t--&gt; eXosip_init successfully!\n&quot;;  <BR>
    }  <BR>
      <BR>
    i = eXosip_listen_addr (IPPROTO_UDP, NULL, 5060, AF_INET, 0);  <BR>
    if (i != 0)  <BR>
    {  <BR>
        eXosip_quit ();  <BR>
        cerr &lt;&lt; &quot;\n\t--&gt; eXosip_listen_addr error! Couldn't initialize transport layer!\n&quot;;  <BR>
    }  <BR>
  <BR>
    for(;;)  <BR>
    {  <BR>
        // 侦听是否有消息到来  <BR>
        je = eXosip_event_wait (0, 50);   <BR>
  <BR>
        // 协议栈带有此语句,具体作用未知  <BR>
        eXosip_lock ();  <BR>
        eXosip_default_action (je);  <BR>
        eXosip_automatic_refresh ();  <BR>
        eXosip_unlock ();  <BR>
  <BR>
        if (je == NULL) // 没有接收到消息，继续  <BR>
        {  <BR>
            continue;  <BR>
        }  <BR>
  <BR>
        switch (je-&gt;type)  <BR>
        {  <BR>
        case EXOSIP_MESSAGE_NEW: // 新的消息到来  <BR>
            cout &lt;&lt; &quot;\n\t*** EXOSIP_MESSAGE_NEW!\n&quot; &lt;&lt; endl;  <BR>
  <BR>
            if (MSG_IS_MESSAGE (je-&gt;request)) // 如果接收到的消息类型是 MESSAGE  <BR>
            {  <BR>
                {  <BR>
                    osip_body_t *body;  <BR>
                    osip_message_get_body (je-&gt;request, 0, &amp;body);   <BR>
                    cout &lt;&lt; &quot;I get the msg is: &quot; &lt;&lt; body-&gt;body &lt;&lt; endl;  <BR>
                }  <BR>
  <BR>
                // 按照规则，需要回复 OK 信息  <BR>
                eXosip_message_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
                eXosip_message_send_answer (je-&gt;tid, 200, answer);  <BR>
            }  <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_INVITE: // INVITE 请求消息  <BR>
            // 得到接收到消息的具体信息  <BR>
            cout &lt;&lt; &quot;\n\tReceived a INVITE msg from &quot; &lt;&lt; je-&gt;request-&gt;req_uri-&gt;host   <BR>
                 &lt;&lt; &quot; : &quot; &lt;&lt; je-&gt;request-&gt;req_uri-&gt;port   <BR>
                 &lt;&lt; &quot;, username is &quot; &lt;&lt; je-&gt;request-&gt;req_uri-&gt;username &lt;&lt; endl;  <BR>
  <BR>
            // 得到消息体,认为该消息就是 SDP 格式.  <BR>
            remote_sdp = eXosip_get_remote_sdp (je-&gt;did);  <BR>
            call_id = je-&gt;cid;  <BR>
            dialog_id = je-&gt;did;  <BR>
          <BR>
            eXosip_lock ();  <BR>
  <BR>
            eXosip_call_send_answer (je-&gt;tid, 180, NULL);  <BR>
            i = eXosip_call_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
            if (i != 0)  <BR>
            {  <BR>
                cout &lt;&lt; &quot;\n\t--&gt; This request msg is invalid! Cann't response!\n&quot; &lt;&lt; endl;  <BR>
                eXosip_call_send_answer (je-&gt;tid, 400, NULL);  <BR>
            }  <BR>
            else  <BR>
            {  <BR>
                snprintf (tmp, 4096,  <BR>
                    &quot;v=0\r\n&quot;  <BR>
                    &quot;o=anonymous 0 0 IN IP4 0.0.0.0\r\n&quot;  <BR>
                    &quot;t=1 10\r\n&quot;  <BR>
                    &quot;a=username:rainfish\r\n&quot;  <BR>
                    &quot;a=password:123\r\n&quot;);  <BR>
              <BR>
                // 设置回复的SDP消息体,下一步计划分析消息体  <BR>
                // 没有分析消息体，直接回复原来的消息，这一块做的不好。  <BR>
                osip_message_set_body (answer, tmp, strlen(tmp));  <BR>
                osip_message_set_content_type (answer, &quot;application/sdp&quot;);  <BR>
              <BR>
                eXosip_call_send_answer (je-&gt;tid, 200, answer);  <BR>
                cout &lt;&lt; &quot;\n\t--&gt; send 200 over!&quot; &lt;&lt; endl;  <BR>
            }  <BR>
  <BR>
            eXosip_unlock ();  <BR>
          <BR>
            // 显示出在 sdp 消息体中的 attribute 的内容,里面计划存放我们的信息  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; The INFO is :\n&quot; ;  <BR>
            while (!osip_list_eol ( &amp;(remote_sdp-&gt;a_attributes), pos))  <BR>
            {  <BR>
                sdp_attribute_t *at;  <BR>
              <BR>
                //这里解释了为什么在SDP消息体中属性a里面存放必须是两列  <BR>
                at = (sdp_attribute_t *) osip_list_get ( &amp;remote_sdp-&gt;a_attributes, pos);  <BR>
                cout &lt;&lt; &quot;\n\t&quot; &lt;&lt; at-&gt;a_att_field   <BR>
                     &lt;&lt; &quot; : &quot; &lt;&lt; at-&gt;a_att_value &lt;&lt; endl;  <BR>
              <BR>
                pos ++;  <BR>
            }  <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_ACK:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; ACK recieved!\n&quot; &lt;&lt; endl;  <BR>
            // printf (&quot;the cid is %s, did is %s\n&quot;, je-&gt;did, je-&gt;cid);   <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_CLOSED:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; the remote hold the session!\n&quot; &lt;&lt; endl;  <BR>
            // eXosip_call_build_ack(dialog_id, &amp;ack);  <BR>
            // eXosip_call_send_ack(dialog_id, ack);   <BR>
            i = eXosip_call_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
            if (i != 0)  <BR>
            {  <BR>
                printf (&quot;This request msg is invalid!Cann't response!\n&quot;);  <BR>
                eXosip_call_send_answer (je-&gt;tid, 400, NULL);  <BR>
            }  <BR>
            else  <BR>
            {  <BR>
                eXosip_call_send_answer (je-&gt;tid, 200, answer);  <BR>
                cout &lt;&lt; &quot;\n\t--&gt; bye send 200 over!\n&quot;;  <BR>
            }   <BR>
            break;  <BR>
  <BR>
        case EXOSIP_CALL_MESSAGE_NEW:  <BR>
  <BR>
            cout &lt;&lt; &quot;\n\t*** EXOSIP_CALL_MESSAGE_NEW\n&quot; &lt;&lt; endl;  <BR>
            if (MSG_IS_INFO(je-&gt;request) ) // 如果传输的是 INFO 方法  <BR>
            {  <BR>
                eXosip_lock ();  <BR>
                i = eXosip_call_build_answer (je-&gt;tid, 200, &amp;answer);  <BR>
                if (i == 0)  <BR>
                {  <BR>
                    eXosip_call_send_answer (je-&gt;tid, 200, answer);  <BR>
                }  <BR>
  <BR>
                eXosip_unlock ();  <BR>
  <BR>
                {  <BR>
                    osip_body_t *body;  <BR>
                    osip_message_get_body (je-&gt;request, 0, &amp;body);  <BR>
                    cout &lt;&lt; &quot;the body is &quot; &lt;&lt; body-&gt;body &lt;&lt; endl;  <BR>
                }  <BR>
            }  <BR>
            break;   <BR>
  <BR>
        default:  <BR>
            cout &lt;&lt; &quot;\n\t--&gt; Could not parse the msg!\n&quot; &lt;&lt; endl;  <BR>
        }  <BR>
    }   <BR>
  <BR>
    return 0;  <BR>
}  
</DD>
<DT>exosip2文档</DT>
<!--property:date_created=1515731524-->
<!--property:date_modified=1515738900-->
<DD>
libeXosip2文档<BR>
<BR>
1.想要用eXosip服务，你的首要任务是要先初始化eXosip内容和libosip库（解析状态机），这必须要在所有操作之前做的事<BR>
<BR>
同样你必须在交换层，选择一种协议（UDP, TCP，TLS或者是DTLS）<BR>
<BR>
下面便是基本的一些操作<BR>
1.1     初始化跟踪信息<BR>
#include &lt;eXosip2/eXosip.h&gt;<BR>
<BR>
eXosip *ctx;<BR>
int i  = 0;<BR>
int port = 5060;<BR>
TRACE_INITIALIZE(6, NULL);<BR>
<BR>
1.2    初始化eXosip(和osip)栈<BR>
ctx = eXosip_malloc();<BR>
if(ctx == NULL)<BR>
return -1;<BR>
<BR>
i = eXosip_init(ctx);<BR>
if(i != 0)<BR>
return -1;<BR>
<BR>
1.3  打开一个UDP socket接收信号<BR>
i = eXosip_listen_addr (ctx, IPPROTO_UDP, NULL, port, AF_INET, 0);<BR>
if (i!=0)<BR>
  {<BR>
    eXosip_quit(ctx);<BR>
    fprintf (stderr, &quot;could not initialize transport layer\n&quot;);<BR>
    return -1;<BR>
  }<BR>
<BR>
/*<BR>
还可以选择其他协议<BR>
UDP:<BR>
i = eXosip_listen_addr (ctx, IPPROTO_UDP, NULL, 5060, AF_INET, 0);<BR>
TCP:<BR>
i = eXosip_listen_addr (ctx, IPPROTO_TCP, NULL, 5060, AF_INET, 0);<BR>
TLS:<BR>
i = eXosip_listen_addr (ctx, IPPROTO_TCP, NULL, 5061, AF_INET, 1);<BR>
DTLS:<BR>
i = eXosip_listen_addr (ctx, IPPROTO_UDP, NULL, 5061, AF_INET, 1);<BR>
*/<BR>
<BR>
选择TLS协议可能需要特殊的设置，TLS实际上引入了两个有趣的特性:<BR>
<BR>
使用certiticates和钥匙，它有助于信任/验证远程服务器<BR>
它还加密数据，以便中间没有人能够读取SIP流量。<BR>
<BR>
如果你不需要服务器验证，TLS很容易安装。您不需要配置任何证书、密钥或根证书…<BR>
下面对的代码就是用来取消服务器证书验证的<BR>
<BR>
int val = 0；<BR>
i = eXosip_set_option(ctx, EX_OSIP_OTP_SET_TLS_VERIFY_CERTIFICATE, (void*) &amp;val);<BR>
<BR>
如果需要验证，还需要做一些工作。您需要的取决于您的平台/操作系统。<BR>
<BR>
在windows上注册：<BR>
在Windows中，使用“Windows证书存储具有内置的支持”。因此，你只需要添加你的证书和密钥在官方的Windows证书存储”。<BR>
<BR>
在mac上注册：<BR>
在MacOSX，exosip为证书存储的内置支持<BR>
<BR>
在其他平台注册：<BR>
eXosip_tls_ctx_t = tls_info;<BR>
memset(&amp;tls_info, 0, sizeof(eXosip_tls_ctx_t));<BR>
snprintf(tls_info.client.cert, sizeof(tls_info.client.cert), &quot;user-cert.crt&quot;);<BR>
snprintf(tls_info.client.priv_key, sizeof(tls_info.client.priv_key), &quot;user-privkey.crt&quot;);<BR>
snprintf(tls_info.client.priv_key_pw, sizeof(tls_info.client.priv_key_pw), &quot;password&quot;);<BR>
snprintf(tls_info.root_ca_cert, sizeof(tls_info.root_ca_cert), &quot;cacert.crt&quot;);<BR>
<BR>
i = eXosip_set_option (ctx, EXOSIP_OPT_SET_TLS_CERTIFICATES_INFO, (void*)&amp;tls_info);<BR>
<BR>
1.4 额外需要初始化的一些设置<BR>
一些选项可以被修改，但是大部分最好还是用默认设置，如果您的SIP服务配置正确，则不需要超出缺省值的设置。<BR>
下面是一些宏<BR>
EXOSIP_OPT_UDP_KEEP_ALIVE 1<BR>
EXOSIP_OPT_UDP_LEARN_PORT 2<BR>
EXOSIP_OPT_USE_RPORT 7<BR>
EXOSIP_OPT_SET_IPV4_FOR_GATEWAY 8<BR>
EXOSIP_OPT_ADD_DNS_CACHE 9<BR>
EXOSIP_OPT_DELETE_DNS_CACHE 10<BR>
EXOSIP_OPT_SET_IPV6_FOR_GATEWAY 12<BR>
EXOSIP_OPT_ADD_ACCOUNT_INFO 13<BR>
EXOSIP_OPT_DNS_CAPABILITIES 14<BR>
EXOSIP_OPT_SET_DSCP 15<BR>
EXOSIP_OPT_REGISTER_WITH_DATE 16<BR>
EXOSIP_OPT_SET_HEADER_USER_AGENT 17<BR>
EXOSIP_OPT_SET_TLS_VERIFY_CERTIFICATE 500<BR>
EXOSIP_OPT_SET_TLS_CERTIFICATES_INFO 501<BR>
EXOSIP_OPT_SET_TLS_CLIENT_CERTIFICATE_NAME 502<BR>
EXOSIP_OPT_SET_TLS_SERVER_CERTIFICATE_NAME 503<BR>
<BR>
下面是一个基本配置，可能适合于常规配置：<BR>
int val;<BR>
eXosip_set_user_agent (ctx, &quot;exosipdemo/0.0.0&quot;);<BR>
val=17000;<BR>
eXosip_set_option (ctx, EXOSIP_OPT_UDP_KEEP_ALIVE, (void*)&amp;val);<BR>
val=2;<BR>
eXosip_set_option (ctx, EXOSIP_OPT_DNS_CAPABILITIES, (void*)&amp;val);<BR>
val=1;<BR>
eXosip_set_option (ctx, EXOSIP_OPT_USE_RPORT, (void*)&amp;val);<BR>
val=26;<BR>
eXosip_set_option (ctx, EXOSIP_OPT_SET_DSCP, (void*)&amp;dscp_value);<BR>
eXosip_set_option (ctx, EXOSIP_OPT_SET_IPV4_FOR_GATEWAY, &quot;sip.antisip.com&quot;);<BR>
<BR>
NAT和联系人报头<BR>
这里需要特殊强调，大部分的exosip2栈本身无关…<BR>
<BR>
使用SIP最重要的特性是能够接收SIP请求。如果你的手机保持沉默，你不会高兴的。然而，在理论上无法猜测哪些内容应该包含我们正在创建的联络头。<BR>
<BR>
大多数代理将修理断了联系，不管为什么exosip2或SIP的应用提供了一个错误的价值。SIP规范对各种客户机和服务器行为的联系验证不很清楚。<BR>
<BR>
然而：<BR>
        1.没关系，什么exosip2代理将修复，最正确。<BR>
	2.不管你认为什么是正确的，有些人认为另一种方式是正确的。<BR>
	3。无论SIP、代理和人员：网络规则总是首先应用！；<BR>
	<BR>
<BR>
无论如何，去避免以下问题<BR>
       1.你应该尽自己所能去提供正确的消息在联系上	，你应该尽最大努力把正确的信息联系起来。<BR>
	2.大多数情况下，你不能，但无论如何都应该有效。<BR>
	<BR>
结论：<BR>
	1.没有任何配置（NAT，眩晕等），您的代理应该能够找到如何到达您（在现有的连接）<BR>
	2.如果它不能（不管什么原因），你可以尝试的解决方法和选择。<BR>
	<BR>
解决方法：<BR>
此选项有助于exosip2检测是当你有几个因素：（例如VPN和eth0）。这将有助于检测是通过接触。通常的参数是代理。（谨慎：由于DNS操作，方法可能会阻塞）<BR>
<BR>
eXosip_set_option(ctx, EXOSIP_OPT_SET_IPV4_FOR_GATEWAY, &quot;sip.antisio.com&quot;);<BR>
<BR>
伪装：当发送你的第一个SIP请求（登记？选择？）上面的答案，通过将包含“接受”和“报告”参数：那些IP /端口是你接触代理头所需的精确的。眩晕将检测类似的IP /端口，但另一个目的地（眩晕服务器）。因此，眩晕不是正确的方法。<BR>
,这样，发送个请求给你的代理，验证方式是（发送还是请求）参数，使用伪装<BR>
eXosip_masquerade_contact(ctx, &quot;91.121.81.212&quot;, 10456);<BR>
<BR>
exosip_opt_udp_learn_port选项：如果你想再通过“接收”和“报告”自动与UDP。使用下面的代码，第二个寄存器（在身份验证之后）？或第二输出请求将包含伪装接触头。如果你用STUN协议值伪装，它也应该被使用。<BR>
<BR>
eXosip_masquerade_contact (ctx, &quot;192.168.2.1&quot;, 5080); <BR>
val=1;<BR>
eXosip_set_option (ctx, EXOSIP_OPT_UDP_LEARN_PORT, &amp;val);<BR>
<BR>
EXOSIP_OPT_USE_RPORT选项：仅用破碎的NAT。在传出要求“报告”参数删除此选项。这应该永远不用。<BR>
<BR>
val=0;<BR>
eXosip_set_option (ctx, EXOSIP_OPT_USE_RPORT, &amp;val);<BR>
<BR>
<BR>
2	HANDLE eXosip2 events	(exosip2事件处理, eXosip_event_t)<BR>
<BR>
2.1 eXosip_event包含你所有需要的信息<BR>
	rid: identifier for registrations.  （注册标识符）<BR>
	tid: identifier for transactions.    （事物标识符）<BR>
	cid, did identifiers for calls.         （调用标示符）<BR>
	sid, did: identifier for outgoing subscriptions.  （传出订阅标识符）<BR>
	nid, did: identifier for incoming subscriptions.  （传入订阅标识符）<BR>
	request: outgoing or incoming request for the event  （事件出入栈请求）<BR>
	answer: outgoing or incoming answer for the event   （事件出入应答）<BR>
	ack: outgoing or incoming ACK for the event      (事件传入传出ACK)<BR>
	<BR>
	这些标示符，被重新用于相关exosip2 API，使他变得更简单更易于控制，回答和ACK是完全复制你可以访问，不需要对exosip2加锁<BR>
	现在你必须要去处理exosip事件，这里是一些从eXosip2栈获取exosip事件的方法代码<BR>
	eXosip_event_t *evt;<BR>
	for(;;)<BR>
	{<BR>
		evt = eXosip_event_wait(ctx, 0, 50);<BR>
		eXosip_lock(ctx);<BR>
		eXosip_automatic_action(ctx);<BR>
		eXosip_unlock(ctx);<BR>
<BR>
		if(evt == NULL)			<BR>
			continue;<BR>
		if(evt-&gt;type == EXOSIP_CALL_NEW)<BR>
		{<BR>
			...			<BR>
		}<BR>
		else if(evt-&gt;type == EXOSIP_CALL_ACK)<BR>
		{<BR>
			...		<BR>
		}<BR>
		else if(evt-&gt;type == EXOSIP_CALL_ANSWERED)<BR>
		{<BR>
			...		<BR>
		}<BR>
		else<BR>
			....<BR>
			<BR>
		eXosip_event_free(evt);<BR>
	}<BR>
<BR>
你没发送一个sip消息就会接受到一个事件，每个事件包含受影响事务的原始请求和可用时触发事件的最后响应。<BR>
<BR>
您可以访问这些消息的所有标头，并将它们存储在自己的上下文中，用于其他操作或图形显示。<BR>
<BR>
例如：<BR>
	当你接受到一个REFER请求，请求呼叫转移，你通常会检索的”指的是“头：<BR>
	<BR>
	osip_header_t* referto_head = NULL;<BR>
	i = osip_message_header_get_byname(evt-&gt;sip, &quot;refer-to&quot;, 0, &amp;referto_head);<BR>
	if(referto_head == NULL || refferto_head-&gt;hvalue == NULL)<BR>
	<BR>
	接听180来电<BR>
	if(evt-&gt;type == EXOSIP_CALL_NEW)<BR>
	{<BR>
		eXosip_lock(ctx);<BR>
		eXosip_call_send_answer(ctx, evt-&gt;tid, 180, NULL);<BR>
		eXosip_unlock(ctx);	<BR>
	}<BR>
<BR>
	答案200确定来电：（同时检查在EVT的附件&gt;的要求！<BR>
	<BR>
	Answer 200 ok to an incoming MESSAGE:(also check the attachment in evt-&gt;request!)<BR>
<BR>
	if(evt-&gt;type == EXOSIP_MESSAGE_NEW &amp;&amp; osip_strcasecmp(minfo.method, &quot;MESSAGE&quot;) == 0)<BR>
	{<BR>
		osip_message_t *answer=NULL;<BR>
		  int i;<BR>
		  eXosip_lock (ctx);<BR>
		  i = eXosip_message_build_answer (ctx, evt-&gt;tid, 200, &amp;answer);<BR>
		  i = eXosip_message_send_answer (ctx, evt-&gt;tid, 200, answer);<BR>
		  eXosip_unlock (ctx);<BR>
	}<BR>
<BR>
	处理对话框里的入栈呼叫，（呼叫转移）<BR>
	if (evt-&gt;type == EXOSIP_CALL_MESSAGE_NEW &amp;&amp; osip_strcasecmp (minfo.method, &quot;REFER&quot;) == 0)<BR>
	 {<BR>
		  osip_header_t *refer_to = NULL;<BR>
		  eXosip_lock (ctx);<BR>
		  i = eXosip_call_build_answer (ctx, evt-&gt;tid, 202, &amp;answer);<BR>
		  i = eXosip_call_send_answer (ctx, evt-&gt;tid, 202, answer);<BR>
		  i = osip_message_header_get_byname (evt-&gt;request, &quot;refer-to&quot;, 0, &amp;refer_to);<BR>
		  if (i &gt;= 0) {<BR>
		    printf (&quot;you must start call to: %s\n&quot;, refer_to-&gt;hvalue);<BR>
		    ...<BR>
		  }<BR>
		  else {<BR>
		  }<BR>
		  eXosip_call_terminate (ctx, evt-&gt;cid, evt-&gt;did, 486);<BR>
		  eXosip_unlock (ctx);<BR>
	}<BR>
<BR>
<BR>
<BR>

</DD>
<DT>sip协议开发</DT>
<!--property:date_created=1516346817-->
<!--property:date_modified=1516346835-->
<DD>
rtp必须关闭
</DD>
</DL>

</DD>
<DT>USX协议</DT>
<!--property:date_created=1516355397-->
<!--property:date_modified=1516355406-->
<DD>
关见字:<BR>
<BR>
UDP UDX RTP,RUDP<BR>
<BR>
UDP可靠传输,UDP文件传输,P2P<BR>
<BR>
UDP文件传输<BR>
<BR>
 <BR>
<BR>
一种基于UDP的可靠传输协议-UDX<BR>
<BR>
 <BR>
<BR>
UDX作为一个新的协议,从研发到成功经力了相当长一段时间.<BR>
<BR>
http://topic.csdn.net/u/20091130/12/0ea2c403-b7bd-4b27-bc17-6e5b5cd4cd55.html<BR>
<BR>
http://bbs.gameres.com/showthread.asp?page=end&amp;threadid=154641<BR>
<BR>
 <BR>
<BR>
目前算法基本已经定型,以其稳定高效,接口封富得到了广大网友开发者好评!<BR>
<BR>
 <BR>
<BR>
UDX开发说明文档.<BR>
<BR>
UDX是完全基于标准c++开发的一套UDP传输库,类似TCP,是一种可靠传输算法.主要是兼顾TCP的可靠性和UDP的实时性.另外一个最重要的优势是算法的可控性.<BR>
<BR>
    UDX的目的是为了让开发人员更好更快的去开发开效率的UDP网络应用软件,UDX主要是以oo的概念来设计开发的,接口SDK形式提供,提供方法和事件模式,也提供API WIN32 DLL.activex,提供静态库,动态库版本.<BR>
    UDX内置文件传输接口,支持UDP中转,P2P接口,流式,包式封装,大简化程序员的工作量,提供20多个实用的例子代码.根据其特点,可以用于文件传输,IM(www.commnetsoft.com),视频聊天,聊天室,视频监控等,当然还可以用在竟技类,rpg等游戏 中,根据实际情况决定<BR>
  目前有windows版本和linux版本.<BR>
 <BR>
<BR>
 <BR>
<BR>
经过本人及各位好友的测试,在传输效率上和QQ直传效率相当,在很多情况都是略胜QQ的文件传输.在效率和重传率方面优于开源的UDT,raknet,jrtp等库.<BR>
<BR>
 <BR>
<BR>
是UDP开发者的首选.<BR>
<BR>
 <BR>
<BR>
UDX的作者是野蛮人(QQ 24508609 MSN WPLLG@HOTMAIL.COM)<BR>
<BR>
<BR>
http://blog.csdn.net/wwwllg/article/details/5883545<BR>
<BR>

</DD>
<DT>rtp数据传输</DT>
<!--property:date_created=1516249401-->
<!--property:date_modified=1516249421-->
<DD>
可以通过生成SDP文件给播放器在指定端口接收数据播放,如果你不用动态调整编码器什么的就不用考虑另外发送RTCP.<BR>
而且RTCP必须自己实现RTSP服务结合起来用,没有实现RTSP服务,就谈不上实现RTCP.<BR>
<BR>
具体H264字节流拆包和RTP封包方法如下:<BR>
<BR>
UINT MediaStreamH264::TransportData(PBYTE pData, UINT dataSize, int pts)<BR>
{<BR>
PBYTE p_buffer = pData;<BR>
int	i_buffer = dataSize;<BR>
<BR>
UINT writeSize = 0;<BR>
<BR>
while( i_buffer &gt; 4 &amp;&amp; ( p_buffer[0] != 0 || p_buffer[1] != 0 || p_buffer[2] != 1 ) )<BR>
{<BR>
i_buffer--;<BR>
p_buffer++;<BR>
}<BR>
<BR>
/* Split nal units */<BR>
while( i_buffer &gt; 4 )<BR>
{<BR>
int i_offset;<BR>
int i_size = i_buffer;<BR>
int i_skip = i_buffer;<BR>
<BR>
/* search nal end */<BR>
for( i_offset = 4; i_offset+2 &lt; i_buffer ; i_offset++)<BR>
{<BR>
if( p_buffer[i_offset] == 0 &amp;&amp; p_buffer[i_offset+1] == 0 &amp;&amp; p_buffer[i_offset+2] == 1 )<BR>
{<BR>
/* we found another startcode */<BR>
i_size = i_offset - ( p_buffer[i_offset-1] == 0 ? 1 : 0);<BR>
i_skip = i_offset;<BR>
break;<BR>
} <BR>
}<BR>
/* TODO add STAP-A to remove a lot of overhead with small slice/sei/... */<BR>
UINT iWrite = TransportH264Nal(p_buffer, i_size, pts, (i_size &gt;= i_buffer) );<BR>
if (iWrite &gt; 0 )<BR>
writeSize += iWrite;<BR>
<BR>
i_buffer -= i_skip;<BR>
p_buffer += i_skip;<BR>
}<BR>
return writeSize;<BR>
}<BR>
<BR>
UINT MediaStreamH264::TransportH264Nal(const PBYTE pNal, UINT nalSize, INT32 pts, BOOL isLast)<BR>
{<BR>
ATLock atlock(&amp;m_tlockRun);<BR>
<BR>
if (m_bRun == FALSE)<BR>
return 0;<BR>
<BR>
if( nalSize &lt; 5 )<BR>
return 0;<BR>
<BR>
UINT	mtu = m_nMTU;<BR>
<BR>
const int i_max = mtu - RTP_HEADER_SIZE; /* payload max in one packet */<BR>
int i_nal_hdr;<BR>
int i_nal_type;<BR>
<BR>
i_nal_hdr = pNal[3];<BR>
i_nal_type = i_nal_hdr&amp;0x1f;<BR>
<BR>
string sps;<BR>
string pps;<BR>
<BR>
if( i_nal_type == 7 || i_nal_type == 8 )<BR>
{<BR>
/* XXX Why do you want to remove them ? It will break streaming with <BR>
* SPS/PPS change (broadcast) ? */<BR>
return 0;<BR>
}<BR>
<BR>
/* Skip start code */<BR>
PBYTE p_data = pNal;<BR>
int	i_data = nalSize;<BR>
<BR>
p_data += 3;<BR>
i_data -= 3;<BR>
<BR>
int writeSize = 0;<BR>
<BR>
if( i_data &lt;= i_max )<BR>
{<BR>
/* Single NAL unit packet */<BR>
//writeSize = m_pRtpTransport-&gt;SetRtpData(p_data, i_data, pts, isLast);<BR>
writeSize = m_pRtpTransport-&gt;Write(p_data, i_data, m_nRtpPayloadType, pts, 0, isLast);<BR>
if (writeSize &lt;= 0)<BR>
return 0;<BR>
return writeSize;<BR>
}<BR>
else<BR>
{<BR>
/* FU-A Fragmentation Unit without interleaving */<BR>
const int i_count = ( i_data-1 + i_max-2 - 1 ) / (i_max-2);<BR>
int i;<BR>
<BR>
p_data++;<BR>
i_data--;<BR>
<BR>
for( i = 0; i &lt; i_count; i++ )<BR>
{<BR>
const int i_payload =  (i_data &lt; (i_max-2)) ? i_data : (i_max-2);<BR>
const int nalSize = 2 + i_payload;<BR>
<BR>
m_Packet.ExtendBuffer(nalSize);<BR>
<BR>
/* FU indicator */<BR>
m_Packet.m_pData[0] = 0x00 | (i_nal_hdr &amp; 0x60) | 28;<BR>
/* FU header */<BR>
m_Packet.m_pData[1] = ( i == 0 ? 0x80 : 0x00 ) | ( (i == i_count-1) ? 0x40 : 0x00 )  | i_nal_type;<BR>
<BR>
/* FU payload */<BR>
memcpy( &amp;m_Packet.m_pData[2], p_data, i_payload );<BR>
<BR>
m_Packet.m_DataSize = nalSize;<BR>
<BR>
//int iWrite = m_pRtpTransport-&gt;SetRtpData(m_Packet.m_pData, m_Packet.m_DataSize, pts, isLast &amp;&amp; (i == i_count-1));<BR>
int iWrite = m_pRtpTransport-&gt;Write(m_Packet.m_pData, m_Packet.m_DataSize, m_nRtpPayloadType, pts, 0, isLast &amp;&amp; (i == i_count-1));<BR>
if (iWrite &gt; 0)<BR>
writeSize += iWrite;<BR>
<BR>
i_data -= i_payload;<BR>
p_data += i_payload;<BR>
}<BR>
}<BR>
return writeSize;<BR>
}<BR>
<DL>
<DT>H264解析RGB</DT>
<!--property:date_created=1516595541-->
<!--property:date_modified=1516598575-->
<DD>
全局变量建在头文件里报重定义，一定要cpp里边，然后extern进去头文件<BR>
<BR>
void  PtzCamera::OnStreamReadyProc(void *pUserData, void* buff, long size, int frametype)<BR>
{	<BR>
	int got_picture = 0;<BR>
	int decode_len = 0;<BR>
<BR>
	//写文件<BR>
	//static FILE *file1 = fopen(&quot;10.avi&quot;, &quot;wb+&quot;);<BR>
	//fwrite(buff, size, 1, file1);<BR>
<BR>
	//return;<BR>
	PtzCamera* pvs = (PtzCamera*)pUserData;<BR>
<BR>
	pvs-&gt;m_tmtLastRecvVideo = time(NULL);<BR>
<BR>
	if (pvs-&gt;m_nDecode &lt; 0)<BR>
	{<BR>
		return;<BR>
	}<BR>
	if(pvs-&gt;m_nDecode == 1) /*由内部解码，内部解码出RGB图像通过OnRealRGBReady传出*/<BR>
	{<BR>
		if(pvs-&gt;m_pfnOnStreamReady != NULL)<BR>
			pvs-&gt;m_pfnOnStreamReady(pvs-&gt;m_pUserData,buff,size,frametype);<BR>
		return;<BR>
	}<BR>
<BR>
	if (pvs-&gt;m_nCodec == VE_CODEC_ID_NONE)<BR>
	{<BR>
		return;<BR>
	}<BR>
<BR>
	if(pvs-&gt;m_nFFmpegInitialed == 0)<BR>
	{<BR>
		//avcodec_init();<BR>
		avcodec_register_all();<BR>
		av_register_all();<BR>
		pvs-&gt;m_nFFmpegInitialed = 1;<BR>
	}<BR>
<BR>
	if(pvs-&gt;m_nCodecInitialed == 0 <BR>
		&amp;&amp; pvs-&gt;m_nFFmpegInitialed == 1)<BR>
	{<BR>
		AVCodecID avCodec;<BR>
		switch(pvs-&gt;m_nCodec)<BR>
		{<BR>
		case VE_CODEC_ID_H264:<BR>
			avCodec = AV_CODEC_ID_H264;<BR>
			break;<BR>
		case VE_CODEC_ID_MPEG4:<BR>
			avCodec = AV_CODEC_ID_MPEG4;<BR>
			break;<BR>
		case VE_CODEC_ID_MJPEG:<BR>
			avCodec = AV_CODEC_ID_MJPEG;<BR>
			break;<BR>
		default:<BR>
			avCodec = (AVCodecID)pvs-&gt;m_nCodec;<BR>
			break;<BR>
		}<BR>
		pvs-&gt;codec = avcodec_find_decoder(avCodec);<BR>
		pvs-&gt;context = avcodec_alloc_context3(pvs-&gt;codec);<BR>
		pvs-&gt;frame = av_frame_alloc();<BR>
		av_init_packet(&amp;pvs-&gt;m_avPkt);<BR>
		pvs-&gt;m_nCodecInitialed = 1;<BR>
		avcodec_open2(pvs-&gt;context, pvs-&gt;codec,NULL);<BR>
	}<BR>
<BR>
	if(pvs-&gt;m_nCodecInitialed == 0)<BR>
		return;<BR>
<BR>
	if(pvs-&gt;buffer_pos+size &gt; pvs-&gt;buffer_size)<BR>
	{<BR>
		uint8_t *temp = pvs-&gt;buffer_stream;<BR>
		pvs-&gt;buffer_size = pvs-&gt;buffer_pos+size*2;			<BR>
		pvs-&gt;buffer_stream = new uint8_t[pvs-&gt;buffer_size];<BR>
		memcpy(pvs-&gt;buffer_stream,temp+pvs-&gt;total_decode_len,pvs-&gt;buffer_pos);<BR>
		delete [] temp;<BR>
	}<BR>
<BR>
	memcpy(pvs-&gt;buffer_stream+pvs-&gt;buffer_pos,buff,size);<BR>
	pvs-&gt;buffer_pos+=size;<BR>
	<BR>
	pvs-&gt;m_avPkt.data = (unsigned char*)pvs-&gt;buffer_stream + pvs-&gt;total_decode_len;<BR>
	pvs-&gt;m_avPkt.size = pvs-&gt;buffer_pos;<BR>
<BR>
		//static FILE *file2 = fopen(&quot;12.avi&quot;, &quot;wb+&quot; );<BR>
		//fwrite(avPkt.data, avPkt.size, 1, file2);<BR>
<BR>
	do<BR>
	{<BR>
		decode_len = avcodec_decode_video2(pvs-&gt;context, pvs-&gt;frame, &amp;got_picture, &amp;pvs-&gt;m_avPkt);<BR>
<BR>
		if(decode_len &lt; 0 &amp;&amp; (pvs-&gt;first_frame))<BR>
		{<BR>
			pvs-&gt;buffer_pos = 0;<BR>
			pvs-&gt;first_frame = false;<BR>
		}<BR>
		else if(decode_len &gt; 0)<BR>
		{<BR>
			if(pvs-&gt;m_pfnOnStreamReady != NULL)<BR>
				pvs-&gt;m_pfnOnStreamReady(pvs-&gt;m_pUserData,pvs-&gt;buffer_stream+pvs-&gt;total_decode_len,decode_len,pvs-&gt;frame-&gt;key_frame==1?1:3);<BR>
			//fwrite(pvs-&gt;buffer_stream+pvs-&gt;total_decode_len,decode_len,1,fp);<BR>
<BR>
			pvs-&gt;buffer_pos -= decode_len;<BR>
			pvs-&gt;total_decode_len += decode_len;<BR>
			pvs-&gt;m_avPkt.data = (unsigned char*)pvs-&gt;buffer_stream + pvs-&gt;total_decode_len + decode_len;<BR>
			pvs-&gt;m_avPkt.size -= decode_len;<BR>
		}<BR>
<BR>
		if(got_picture)<BR>
		{<BR>
			if(pvs-&gt;frame_rgb == NULL)<BR>
			{<BR>
				pvs-&gt;frame_rgb = av_frame_alloc();<BR>
				int bytes = avpicture_get_size(AV_PIX_FMT_RGB24, pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;height);<BR>
				pvs-&gt;buffer_rgb=(uint8_t *)av_malloc(bytes);<BR>
				avpicture_fill((AVPicture *)pvs-&gt;frame_rgb, pvs-&gt;buffer_rgb, AV_PIX_FMT_RGB24,pvs-&gt;context-&gt;width, pvs-&gt;context-&gt;height);<BR>
			}<BR>
<BR>
			SwsContext *img_convert_ctx = sws_getContext(pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;height,<BR>
				pvs-&gt;context-&gt;pix_fmt,<BR>
				pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;height,<BR>
				AV_PIX_FMT_BGR24,<BR>
				SWS_FAST_BILINEAR, NULL, NULL, NULL);<BR>
<BR>
			sws_scale(img_convert_ctx, pvs-&gt;frame-&gt;data, <BR>
				pvs-&gt;frame-&gt;linesize, 0, pvs-&gt;context-&gt;height, <BR>
				pvs-&gt;frame_rgb-&gt;data, pvs-&gt;frame_rgb-&gt;linesize);<BR>
<BR>
			sws_freeContext(img_convert_ctx);<BR>
<BR>
			if(pvs-&gt;m_pfnOnRealRGBReady != NULL)<BR>
				pvs-&gt;m_pfnOnRealRGBReady(pvs-&gt;m_pUserData,pvs-&gt;buffer_rgb,pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;width*3,pvs-&gt;context-&gt;height);<BR>
		}<BR>
	}<BR>
	while(decode_len&gt;0);<BR>
<BR>
	if(pvs-&gt;total_decode_len &gt;= pvs-&gt;buffer_pos)<BR>
	{<BR>
		if(pvs-&gt;buffer_pos != 0)<BR>
			memcpy(pvs-&gt;buffer_stream,pvs-&gt;buffer_stream+pvs-&gt;total_decode_len,pvs-&gt;buffer_pos);<BR>
		pvs-&gt;total_decode_len = 0;<BR>
	}<BR>
}<BR>
<BR>
<BR>
void  CYTControlDlg::CalcDisplayRect(LPRECT lpWndRect,int width, int height,CRect&amp; displayRect)<BR>
{<BR>
	CRect rectWnd(lpWndRect);<BR>
<BR>
	float a = (float)width/(float)height;<BR>
	float b = (float)rectWnd.Width()/(float)rectWnd.Height();<BR>
<BR>
	if (a &gt; b)<BR>
	{<BR>
		if (width &gt; rectWnd.Width())<BR>
		{<BR>
			displayRect.left = rectWnd.left;<BR>
			displayRect.right = rectWnd.right;<BR>
			int c = (height*displayRect.Width())/width;<BR>
			displayRect.top = rectWnd.top + (rectWnd.Height()-c)/2;<BR>
			displayRect.bottom = displayRect.top+c;<BR>
		}<BR>
		else<BR>
		{<BR>
			displayRect.left =rectWnd.left + (rectWnd.Width()-width)/2;<BR>
			displayRect.right = displayRect.left + width;<BR>
			displayRect.top = rectWnd.top + (rectWnd.Height()-height)/2;<BR>
			displayRect.bottom = displayRect.top + height;<BR>
		}<BR>
	}<BR>
	else<BR>
	{<BR>
		if (height &gt; rectWnd.Height())<BR>
		{<BR>
			displayRect.top = rectWnd.top;<BR>
			displayRect.bottom = displayRect.top+rectWnd.Height();<BR>
			int c = (width*rectWnd.Height())/height;<BR>
			displayRect.left = rectWnd.left + (rectWnd.Width()-c)/2;<BR>
			displayRect.right = displayRect.left+c;<BR>
		}<BR>
		else<BR>
		{<BR>
			displayRect.top = rectWnd.top+(rectWnd.Height()-height)/2;<BR>
			displayRect.bottom = displayRect.top + height;<BR>
			displayRect.left = rectWnd.left + (rectWnd.Width()-width)/2;<BR>
			displayRect.right = displayRect.left + width;<BR>
		}<BR>
	}<BR>
}<BR>
<BR>
<BR>
void  CYTControlDlg::DisplayRGB24(void* buff, int width,int storewidth, int height)<BR>
{<BR>
	if(m_rcDisplay.Width() == 0)<BR>
	{<BR>
		RECT  rcWnd;<BR>
		rcWnd.left = 0;<BR>
		rcWnd.top = 0;<BR>
		rcWnd.right = m_rcDisplayWnd.Width();<BR>
		rcWnd.bottom = m_rcDisplayWnd.Height();		<BR>
<BR>
		CalcDisplayRect(&amp;rcWnd,width,height,m_rcDisplay);<BR>
	}<BR>
<BR>
	m_nImgWidth = width;<BR>
	m_nImgHeight = height;<BR>
<BR>
<BR>
	IplImage *pDigitVideoImage;<BR>
	pDigitVideoImage = cvCreateImage(cvSize(width,height),8,3);<BR>
	memcpy(pDigitVideoImage-&gt;imageData,buff,width*height*3);<BR>
	ShowImage(pDigitVideoImage,IDC_VIDEO_WND);<BR>
	<BR>
	//测试录像功能结束<BR>
	cvReleaseImage(&amp;pDigitVideoImage);<BR>
	m_nFrameRateCount++;<BR>
}
</DD>
</DL>

</DD>
<DT>Gradle</DT>
<!--property:date_created=1516684902-->
<!--property:date_modified=1516684914-->
<DD>
http://services.gradle.org/distributions/<BR>
<BR>
网上下载
</DD>
<DT>windows多线程笔记</DT>
<!--property:date_created=1516775582-->
<!--property:date_modified=1516777557-->
<DD>
1。防止多个线程同时修改同一块内存，导致的值得不可预见性<BR>
1.增减操作<BR>
LONG__cdeclInterlockedIncrement(LONG volatile* Addend);<BR>
LONG__cdeclInterlockedDecrement(LONG volatile* Addend);<BR>
<BR>
返回变量执行增减操作之后的值。<BR>
LONG__cdec InterlockedExchangeAdd(LONG volatile* Addend, LONGValue);<BR>
返回运算后的值，注意！加个负数就是减。<BR>
 <BR>
2.赋值操作<BR>
LONG__cdeclInterlockedExchange(LONG volatile* Target, LONGValue);<BR>
<BR>
DWORD WINAPI ThreadFun(void *pPM)  <BR>
{  <BR>
    Sleep(100);//some work should to do  <BR>
    //g_nLoginCount++;  <BR>
    InterlockedIncrement((LPLONG)&amp;g_nLoginCount);  <BR>
    Sleep(50);  <BR>
    return 0;  <BR>
}  <BR>
<BR>
<BR>
2.多线程同步-临界区的使用<BR>
<BR>
CRITICAL_SECTION lock<BR>
<BR>
函数功能：初始化<BR>
函数原型：<BR>
void InitializeCriticalSection(LPCRITICAL_SECTIONlpCriticalSection);<BR>
函数说明：定义关键段变量后必须先初始化。<BR>
 <BR>
函数功能：销毁<BR>
函数原型：<BR>
void DeleteCriticalSection(LPCRITICAL_SECTIONlpCriticalSection);<BR>
函数说明：用完之后记得销毁。<BR>
 <BR>
函数功能：进入关键区域<BR>
函数原型：<BR>
void EnterCriticalSection(LPCRITICAL_SECTIONlpCriticalSection);<BR>
函数说明：系统保证各线程互斥的进入关键区域。<BR>
 <BR>
函数功能：离开关关键区域<BR>
函数原型：<BR>
void LeaveCriticalSection(LPCRITICAL_SECTIONlpCriticalSection);<BR>
<BR>
<BR>
3.事件处理<BR>
第一个 CreateEvent<BR>
函数功能：创建事件<BR>
函数原型：<BR>
HANDLECreateEvent(<BR>
 LPSECURITY_ATTRIBUTESlpEventAttributes,<BR>
 BOOLbManualReset,<BR>
 BOOLbInitialState,<BR>
 LPCTSTRlpName<BR>
);<BR>
函数说明：<BR>
第一个参数表示安全控制，一般直接传入NULL。<BR>
第二个参数确定事件是手动置位还是自动置位，传入TRUE表示手动置位，传入FALSE表示自动置位。如果为自动置位，则对该事件调用WaitForSingleObject()后会自动调用ResetEvent()使事件变成未触发状态。打个小小比方，手动置位事件相当于教室门，教室门一旦打开（被触发），所以有人都可以进入直到老师去关上教室门（事件变成未触发）。自动置位事件就相当于医院里拍X光的房间门，门打开后只能进入一个人，这个人进去后会将门关上，其它人不能进入除非门重新被打开（事件重新被触发）。<BR>
第三个参数表示事件的初始状态，传入TRUR表示已触发。<BR>
第四个参数表示事件的名称，传入NULL表示匿名事件。<BR>
<BR>
 第二个 OpenEvent<BR>
函数功能：根据名称获得一个事件句柄。<BR>
函数原型：<BR>
HANDLEOpenEvent(<BR>
 DWORDdwDesiredAccess,<BR>
 BOOLbInheritHandle,<BR>
 LPCTSTRlpName     //名称<BR>
);<BR>
函数说明：<BR>
第一个参数表示访问权限，对事件一般传入EVENT_ALL_ACCESS。详细解释可以查看MSDN文档。<BR>
第二个参数表示事件句柄继承性，一般传入TRUE即可。<BR>
第三个参数表示名称，不同进程中的各线程可以通过名称来确保它们访问同一个事件。<BR>
<BR>
<BR>
第三个SetEvent<BR>
函数功能：触发事件<BR>
函数原型：BOOLSetEvent(HANDLEhEvent);<BR>
函数说明：每次触发后，必有一个或多个处于等待状态下的线程变成可调度状态。<BR>
 <BR>
第四个ResetEvent<BR>
函数功能：将事件设为末触发<BR>
函数原型：BOOLResetEvent(HANDLEhEvent);<BR>
 <BR>
最后一个事件的清理与销毁<BR>
由于事件是内核对象，因此使用CloseHandle()就可以完成清理与销毁了。
</DD>
<DT>OpenH264</DT>
<!--property:date_created=1516785001-->
<!--property:date_modified=1516785076-->
<!--property:expanded-->
<DD>
openH264解码流程<BR>
<BR>
之前项目中用过openH264进行解码，本文介绍一下解码流程，算是对之前项目的一个总结。<BR>
<BR>
同openH264编码一样，openH264的解码流程也主要分为3步： <BR>
1：创建解码器。<BR>
int result = WelsCreateDecoder(&amp;decoder);<BR>
<BR>
同样可以通过判断返回值来判断解码器是否创建成功。 <BR>
2：初始化解码器。<BR>
memset (&amp;pParam, 0, sizeof (SDecodingParam));<BR>
pParam.uiTargetDqLayer = UCHAR_MAX;<BR>
pParam.eEcActiveIdc = ERROR_CON_FRAME_COPY_CROSS_IDR;<BR>
pParam.sVideoProperty.eVideoBsType = VIDEO_BITSTREAM_DEFAULT;<BR>
result = decoder-&gt;Initialize(&amp;pParam);<BR>
<BR>
3：调用解码器开始解码。<BR>
<BR>
int stride[2] = {videoWidth, videoWidth/2};<BR>
uint8_t* dst[3];<BR>
memset (dst, 0, sizeof (dst));<BR>
int result = decoder-&gt;DecodeFrame((const unsigned char*)src, length, dst, stride, videoWidth, videoHeight);<BR>
<BR>
解码后的数据存储在dst中，格式为YUV420P，如果需要其他格式的话，要进行格式转换。<BR>
<BR>
<BR>
YUV420P转RGB32<BR>
从网络摄像机中获取的帧数据是YUV420P格式的，而我们处理图像需要RGB格式，在网上找了一段将YUV420P格式的帧转换为RGB的代码。<BR>
<BR>
&lt;方法一&gt; 直接计算，效率低<BR>
[cpp] view plaincopy<BR>
// 转换 YV12 到 RGB24  <BR>
// pYUV 的大小 (3 * iWidth * iHeight / 2)  <BR>
// pRGB 的大小 (3 * iWidth * iHeight)  <BR>
// 如果成功返回 true, 否则 false  <BR>
bool YV12_to_RGB24(unsigned char* pYV12, unsigned char* pRGB24, int iWidth, int iHeight)  <BR>
{  <BR>
if(!pYV12 || !pRGB24)  <BR>
return false;  <BR>
  <BR>
const long nYLen = long(iHeight * iWidth);  <BR>
const int nHfWidth = (iWidth&gt;&gt;1);  <BR>
  <BR>
if(nYLen&lt;1 || nHfWidth&lt;1)   <BR>
return false;  <BR>
  <BR>
// yv12数据格式，其中Y分量长度为width * height, U和V分量长度都为width * height / 4  <BR>
// |WIDTH |  <BR>
// y......y--------  <BR>
// y......y HEIGHT  <BR>
// y......y  <BR>
// y......y--------  <BR>
// v..v  <BR>
// v..v  <BR>
// u..u  <BR>
// u..u  <BR>
unsigned char* yData = pYV12;  <BR>
unsigned char* vData = &amp;yData[nYLen];  <BR>
unsigned char* uData = &amp;vData[nYLen&gt;&gt;2];  <BR>
  <BR>
if(!uData || !vData)  <BR>
return false;  <BR>
  <BR>
// Convert YV12 to RGB24  <BR>
//   <BR>
// formula  <BR>
// [1 1 1 ]  <BR>
// [r g b] = [y u-128 v-128] [0 0.34375 0 ]  <BR>
// [1.375 0.703125 1.734375]  <BR>
// another formula  <BR>
// [1 1 1 ]  <BR>
// [r g b] = [y u-128 v-128] [0 0.698001 0 ]  <BR>
// [1.370705 0.703125 1.732446]  <BR>
int rgb[3];  <BR>
int i, j, m, n, x, y;  <BR>
m = -iWidth;  <BR>
n = -nHfWidth;  <BR>
for(y=0; y &lt; iHeight; y++)  <BR>
{  <BR>
m += iWidth;  <BR>
if(!(y % 2))  <BR>
n += nHfWidth;  <BR>
for(x=0; x &lt; iWidth; x++)  <BR>
{  <BR>
i = m + x;  <BR>
j = n + (x&gt;&gt;1);  <BR>
rgb[2] = int(yData[i] + 1.370705 * (vData[j] - 128)); // r分量值  <BR>
rgb[1] = int(yData[i] - 0.698001 * (uData[j] - 128) - 0.703125 * (vData[j] - 128)); // g分量值  <BR>
rgb[0] = int(yData[i] + 1.732446 * (uData[j] - 128)); // b分量值  <BR>
  <BR>
j = nYLen - iWidth - m + x;  <BR>
i = (j&lt;&lt;1) + j;  <BR>
for(j=0; j&lt;3; j++)  <BR>
{  <BR>
if(rgb[j]&gt;=0 &amp;&amp; rgb[j]&lt;=255)  <BR>
pRGB24[i + j] = rgb[j];  <BR>
else  <BR>
pRGB24[i + j] = (rgb[j] &lt; 0) ? 0 : 255;  <BR>
}  <BR>
}  <BR>
}  <BR>
return true;  <BR>
}  <BR>
<BR>
在利用OpenCV进行处理时，如果直接将转换好的数据赋给IplImage-&gt;imageData，会出现红蓝通道对调的情况，因为OpenCV中默认使用的是BGR的排列方式。<BR>
将代码中的给rgb复制的一段稍微改一下就行，改为：<BR>
[cpp] view plaincopy<BR>
rgb[0] = int(yData[i] + 1.370705 * (vData[j] - 128)); // r分量值  <BR>
rgb[1] = int(yData[i] - 0.698001 * (uData[j] - 128) - 0.703125 * (vData[j] - 128)); // g分量值  <BR>
rgb[2] = int(yData[i] + 1.732446 * (uData[j] - 128)); // b分量值  <BR>
<BR>
<BR>
&lt;方法二&gt;查表，效率高<BR>
[cpp] view plaincopy<BR>
#include   &lt;string&gt;   <BR>
#include   &lt;string.h&gt;   <BR>
using   namespace   std;   <BR>
  <BR>
static   long   int   crv_tab[256];   <BR>
static   long   int   cbu_tab[256];   <BR>
static   long   int   cgu_tab[256];   <BR>
static   long   int   cgv_tab[256];   <BR>
static   long   int   tab_76309[256];   <BR>
static   unsigned   char   clp[1024]; //for   clip   in   CCIR601   <BR>
  <BR>
  <BR>
void   InitConvtTbl();   <BR>
void   YUV2RGB420(unsigned   char   *src,   unsigned   char   *dst_ori,   <BR>
    int   width,int   height);   <BR>
  <BR>
/****************************************************/   <BR>
/* Sum   the   input */   <BR>
/* Input:   input,   len */   <BR>
/* Output:   input */   <BR>
/* Algorithm:   add */   <BR>
/****************************************************/   <BR>
void   InitConvtTbl()   <BR>
{   <BR>
    long   int   crv,cbu,cgu,cgv;   <BR>
    int   i,ind;         <BR>
  <BR>
    crv   =   104597;   cbu   =   132201;     /*   fra   matrise   i   global.h   */   <BR>
    cgu   =   25675;     cgv   =   53279;   <BR>
  <BR>
    for   (i   =   0;   i   &lt;   256;   i++)   {   <BR>
        crv_tab[i]   =   (i-128)   *   crv;   <BR>
        cbu_tab[i]   =   (i-128)   *   cbu;   <BR>
        cgu_tab[i]   =   (i-128)   *   cgu;   <BR>
        cgv_tab[i]   =   (i-128)   *   cgv;   <BR>
        tab_76309[i]   =   76309*(i-16);   <BR>
    }   <BR>
  <BR>
    for   (i=0;   i &lt;384;   i++)   <BR>
        clp[i]   =0;   <BR>
    ind=384;   <BR>
    for   (i=0;i &lt;256;   i++)   <BR>
        clp[ind++]=i;   <BR>
    ind=640;   <BR>
    for   (i=0;i &lt;384;i++)   <BR>
        clp[ind++]=255;   <BR>
}  <BR>
  <BR>
void   YUV2RGB420(unsigned   char   *src,   unsigned   char   *dst_ori,   <BR>
    int   width,int   height)   <BR>
{   <BR>
    unsigned   char   *src0;   <BR>
    unsigned   char   *src1;   <BR>
    unsigned   char   *src2;   <BR>
    int   y1,y2,u,v;     <BR>
    unsigned   char   *py1,*py2;   <BR>
    int   i,j,   c1,   c2,   c3,   c4;   <BR>
    unsigned   char   *d1,   *d2,   *d3;   <BR>
  <BR>
    //Initialization   <BR>
    src0=src;   <BR>
    src1=src+width*height;   <BR>
    src2=src+width*height+width*height/4;   <BR>
  <BR>
    py1=src0;   <BR>
    py2=py1+width;   <BR>
    d1=dst_ori + 3 * width * (height -1);   <BR>
    d2=d1-3*width;   <BR>
    for   (j   =   0;   j   &lt;   height;   j   +=   2)   {     <BR>
        for   (i   =   0;   i   &lt;   width;   i   +=   2)   {   <BR>
  <BR>
            u   =   *src1++;   <BR>
            v   =   *src2++;   <BR>
  <BR>
            c1   =   crv_tab[v];   <BR>
            c2   =   cgu_tab[u];   <BR>
            c3   =   cgv_tab[v];   <BR>
            c4   =   cbu_tab[u];   <BR>
  <BR>
            //up-left   <BR>
            y1   =   tab_76309[*py1++];   <BR>
            *d1++   =   clp[384+((y1   +   c4)&gt;&gt; 16)];       <BR>
            *d1++   =   clp[384+((y1   -   c2   -   c3)&gt;&gt; 16)];   <BR>
            *d1++   =   clp[384+((y1   +   c1)&gt;&gt; 16)];   <BR>
  <BR>
            //down-left   <BR>
            y2   =   tab_76309[*py2++];   <BR>
            *d2++   =   clp[384+((y2   +   c4)&gt;&gt; 16)];       <BR>
            *d2++   =   clp[384+((y2   -   c2   -   c3)&gt;&gt; 16)];   <BR>
            *d2++   =   clp[384+((y2   +   c1)&gt;&gt; 16)];   <BR>
  <BR>
            //up-right   <BR>
            y1   =   tab_76309[*py1++];   <BR>
            *d1++   =   clp[384+((y1   +   c4)&gt;&gt; 16)];       <BR>
            *d1++   =   clp[384+((y1   -   c2   -   c3)&gt;&gt; 16)];   <BR>
            *d1++   =   clp[384+((y1   +   c1)&gt;&gt; 16)];   <BR>
  <BR>
            //down-right   <BR>
            y2   =   tab_76309[*py2++];   <BR>
            *d2++   =   clp[384+((y2   +   c4)&gt;&gt; 16)];       <BR>
            *d2++   =   clp[384+((y2   -   c2   -   c3)&gt;&gt; 16)];   <BR>
            *d2++   =   clp[384+((y2   +   c1)&gt;&gt; 16)];   <BR>
        }   <BR>
        d1   -=   3*width * 3;   <BR>
        d2   -=   3*width * 3;   <BR>
        py1+=       width;   <BR>
        py2+=       width;   <BR>
    }                 <BR>
  <BR>
  <BR>
}   <BR>
<BR>
<BR>
<DL>
<DT>编译openh264</DT>
<!--property:date_created=1516931551-->
<!--property:date_modified=1516937295-->
<DD>
下载nasm<BR>
<BR>
设置环境变量<BR>
export PATH = &quot;$PATH:/D:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin:/D:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\IDE&quot;<BR>
export INCLUDE=&quot;D:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\include;C:\Program Files (x86)\Windows Kits\8.0\Include\um;C:\Program Files (x86)\Windows Kits\8.0\Include\shared&quot;<BR>
export LIB=&quot;C:\Program Files (x86)\Windows Kits\8.0\Lib\Win8\um\x64;D:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\lib\amd64&quot;<BR>
<BR>
Windows 下用 VS2015+MSYS 一键编译 OpenH264<BR>
前提条件:<BR>
1、你已经安装好了VS2015；<BR>
2、你已经安装好了MSYS；<BR>
3、你已经从 从github上下载了OpenH264 源码；https://github.com/cisco/openh264.git<BR>
在源代码目录下建立BAT文件，build.bat，内容如下：<BR>
call &quot;D:\Language\VS2015\VC\bin\vcvars32.bat&quot; set MSYS=D:\Language\MinGW32\msys\1.0\bin PATH=%MSYS%;%path% set INCLUDE=%INCLUDE% set LIB=%lib%  bash -c &quot;make OS=msvc&quot; pause<BR>
<BR>
<BR>
    common.lib<BR>
    console_common.lib<BR>
    decoder.lib<BR>
    encoder.lib<BR>
    openh264.lib<BR>
    openh264_dll.lib<BR>
    processing.lib<BR>
   Openh264.dll<BR>
    h264dec.exe<BR>
    h264enc.exe<BR>

</DD>
</DL>

</DD>
<DT>H264解码比较</DT>
<!--property:date_created=1516930365-->
<!--property:date_modified=1516930426-->
<DD>
JM86 decoder: vc71 release<BR>
T264 decoder: vc71 release<BR>
x264 decodeer: vc71 release<BR>
ffmpeg libavcodec: MinGW<BR>
Intel IPP simple player: vc71 release + directX 9.0c sdk<BR>
<BR>
<BR>
http://blog.csdn.net/xy365/article/details/8424600<BR>
排名分先后。<BR>
一、ffmpeg<BR>
    ffmpeg属于GPL或者LGPL，确切属于哪一种，要根据编译选项，因为它里面的库有些属于GPL的有些属于LGPL的，你编译的时候打开或者关闭这些库的选项，就决定了它属于哪一种。<BR>
http://www.ffmpeg.org/legal.html<BR>
ffmpeg项目由以下几部分组成:<BR>
ffmpeg 视频文件转换命令行工具,也支持经过实时电视卡抓取和编码成视频文件.<BR>
ffserver 基于HTTP(RTSP正在开发中)用于实时广播的多媒体服务器.也支持时间平移<BR>
ffplay 用 SDL和FFmpeg库开发的一个简单的媒体播放器<BR>
libavcodec 一个包含了所有FFmpeg音视频编解码器的库.为了保证最优性能和高可复用性,大多数编解码器从头开发的.<BR>
libavformat 一个包含了所有的普通音视格式的解析器和产生器的库.<BR>
 <BR>
二、Xvid<BR>
     Xvid（旧称为XviD）是一个开放源代码的MPEG-4视频编解码器，它是基于OpenDivX而编写的。官方网站：www.xvid.org<BR>
 <BR>
三、X264<BR>
    X264是一种免费的、具有更优秀算法的符合H.264/MPEG-4 AVC视频压缩编码标准格式的编码库。x264压缩出的视频文件在相同质量下要比xvid压缩出的文件要小，或者也可以说，在相同体积下比xvid压缩出的文件质量要好。它符合GPL（General Public License，是一份GNU通用公共授权）许可证。X264属于videolan开源工程的一部分。http://www.videolan.org/developers/x264.html<BR>
　　采用CAVLC/CABAC多种算法编码<BR>
　　内置所有macroblock格式（16x16, 8x8, and 4x4 ）<BR>
　　Inter P：所有的分割块（从16x16到4x4 ）<BR>
　　Inter B：分割块从16x16到8x8<BR>
　　码率控制：恒定的分层编制，单次或多次的ABR压制，可选的VBV压制<BR>
　　场景剪切侦测<BR>
　　支持B-frame<BR>
　　能够任意编制B-frame命令行<BR>
　　无损模式<BR>
　　8x8和4x4的格式能够进行翻转或旋转<BR>
　　自定义精确的矩阵模板<BR>
　　可在多个CPU平行编码<BR>
　　隔行扫描<BR>
 <BR>
    X264只提供编码，不提供解码。 解码部分需要FFMPEG完成；XVID有编解码部分，其中解码亦可以利用FFMPEG中的MPEG4完成解码。<BR>
 <BR>
四、ffdshow<BR>
    ffdshow是对一些codec（ffmpeg, xvid， and other）的封装，封装成了DirectShow和VFW的标准组件。该库（软件）只能在windows平台运行，是属于GPL<BR>
比如对于xvid来讲，ffdshow是可以选择具体使用那个codec的，ffmpeg(libavcodec) or xvid。那么封装有没有额外的成本哪？有，但对大部分应用来讲，可以忽略不计。就如c++和c。<BR>
vfw和dshow里的CODEC分别是通过fourcc码和guid机制寻找的,可以在系统注册codec后调用,比自带编解码库形式更加统一,便于使用。此外，vfw和dshow是代表了两个微软不同时期的音视频处理封装库，里面包含了音视频驱动，音视频处理的一整套方案。<BR>
    DirectShow是微软公司在ActiveMovie和Video for Windows的基础上推出的新一代基于COM的流媒体处理的开发包，与DirectX开发包一起发布。目前，DirectX最新版本为9.0。 DirectShow为多媒体流的捕捉和回放提供了强有力的支持。运用DirectShow，我们可以很方便地从支持WDM驱动模型的采集卡上捕获数据， 并且进行相应的后期处理乃至存储到文件中。这样使在多媒体数据库管理系统（MDBMS）中多媒体数据的存取变得更加方便。DirectShow是微软公司 提供的一套在Windows平台上进行流媒体处理的开发包，与DirectX开发包一起发布。运用DirectShow，我们可以很方便地从支持WDM驱动模型的采集卡上捕获数据，并且进行相应的后期处理乃至存储到文件中。它广泛地支持各种媒体格 式，包括Asf、Mpeg、Avi、Dv、Mp3、Wave等等，使得多媒体数据的回放变得轻而易举。另外，DirectShow还集成了DirectX 其它部分（比如DirectDraw、DirectSound）的技术，直接支持DVD的播放，视频的非线性编辑，以及与数字摄像机的数据交换。<BR>
    vfw（Video For Windows）<BR>
 <BR>
五、CoreAVC<BR>
     CoreCodec的CoreAVC高清H.264视频解码器是基于已经被用于AVCHD、蓝光光盘和HD-DVD中的MPEG-4 Part 10标准构建的。H.264是下一代的视频编码标准，而CoreAVC?是目前公认世界上最快的H.264软解码器。
</DD>
<DT>解码视频流</DT>
<!--property:date_created=1516960692-->
<!--property:date_modified=1516960712-->
<DD>
	<BR>
	初始化<BR>
	{<BR>
	avcodec_register_all();<BR>
		av_register_all();<BR>
	AVCodecID avCodec;<BR>
		switch(pvs-&gt;m_nCodec)<BR>
		{<BR>
		case VE_CODEC_ID_H264:<BR>
			avCodec = AV_CODEC_ID_H264;<BR>
			break;<BR>
		case VE_CODEC_ID_MPEG4:<BR>
			avCodec = AV_CODEC_ID_MPEG4;<BR>
			break;<BR>
		case VE_CODEC_ID_MJPEG:<BR>
			avCodec = AV_CODEC_ID_MJPEG;<BR>
			break;<BR>
		default:<BR>
			avCodec = (AVCodecID)pvs-&gt;m_nCodec;<BR>
			break;<BR>
		}<BR>
		pvs-&gt;codec = avcodec_find_decoder(avCodec);<BR>
		pvs-&gt;context = avcodec_alloc_context3(pvs-&gt;codec);<BR>
		pvs-&gt;frame = av_frame_alloc();<BR>
		av_init_packet(&amp;pvs-&gt;m_avPkt);<BR>
		pvs-&gt;m_nCodecInitialed = 1;<BR>
		avcodec_open2(pvs-&gt;context, pvs-&gt;codec,NULL);<BR>
	}<BR>
	memcpy(pvs-&gt;buffer_stream+pvs-&gt;buffer_pos,buff,size);<BR>
	pvs-&gt;buffer_pos+=size;<BR>
	<BR>
	pvs-&gt;m_avPkt.data = (unsigned char*)pvs-&gt;buffer_stream + pvs-&gt;total_decode_len;<BR>
	pvs-&gt;m_avPkt.size = pvs-&gt;buffer_pos;<BR>
	<BR>
	decode_len = avcodec_decode_video2(pvs-&gt;context, pvs-&gt;frame, &amp;got_picture, &amp;pvs-&gt;m_avPkt);<BR>
	<BR>
	if(decode_len &lt; 0 &amp;&amp; (pvs-&gt;first_frame))<BR>
		{<BR>
			pvs-&gt;buffer_pos = 0;<BR>
			pvs-&gt;first_frame = false;<BR>
		}<BR>
		else if(decode_len &gt; 0)<BR>
		{<BR>
			if(pvs-&gt;m_pfnOnStreamReady != NULL)<BR>
				pvs-&gt;m_pfnOnStreamReady(pvs-&gt;m_pUserData,pvs-&gt;buffer_stream+pvs-&gt;total_decode_len,decode_len,pvs-&gt;frame-&gt;key_frame==1?1:3);<BR>
			//fwrite(pvs-&gt;buffer_stream+pvs-&gt;total_decode_len,decode_len,1,fp);<BR>
<BR>
			pvs-&gt;buffer_pos -= decode_len;<BR>
			pvs-&gt;total_decode_len += decode_len;<BR>
			pvs-&gt;m_avPkt.data = (unsigned char*)pvs-&gt;buffer_stream + pvs-&gt;total_decode_len + decode_len;<BR>
			pvs-&gt;m_avPkt.size -= decode_len;<BR>
		}<BR>
<BR>
		if(got_picture)<BR>
		{<BR>
			if(pvs-&gt;frame_rgb == NULL)<BR>
			{<BR>
				pvs-&gt;frame_rgb = av_frame_alloc();<BR>
				int bytes = avpicture_get_size(AV_PIX_FMT_RGB24, pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;height);<BR>
				pvs-&gt;buffer_rgb=(uint8_t *)av_malloc(bytes);<BR>
				avpicture_fill((AVPicture *)pvs-&gt;frame_rgb, pvs-&gt;buffer_rgb, AV_PIX_FMT_RGB24,pvs-&gt;context-&gt;width, pvs-&gt;context-&gt;height);<BR>
			}<BR>
<BR>
			SwsContext *img_convert_ctx = sws_getContext(pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;height,<BR>
				pvs-&gt;context-&gt;pix_fmt,<BR>
				pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;height,<BR>
				AV_PIX_FMT_BGR24,<BR>
				SWS_FAST_BILINEAR, NULL, NULL, NULL);<BR>
<BR>
			sws_scale(img_convert_ctx, pvs-&gt;frame-&gt;data, <BR>
				pvs-&gt;frame-&gt;linesize, 0, pvs-&gt;context-&gt;height, <BR>
				pvs-&gt;frame_rgb-&gt;data, pvs-&gt;frame_rgb-&gt;linesize);<BR>
<BR>
			sws_freeContext(img_convert_ctx);<BR>
<BR>
			if(pvs-&gt;m_pfnOnRealRGBReady != NULL)<BR>
				pvs-&gt;m_pfnOnRealRGBReady(pvs-&gt;m_pUserData,pvs-&gt;buffer_rgb,pvs-&gt;context-&gt;width,pvs-&gt;context-&gt;width*3,pvs-&gt;context-&gt;height);<BR>
		}
</DD>
<DT>系统方案</DT>
<!--property:date_created=1516961851-->
<!--property:date_modified=1516961851-->
<!--property:expanded-->
<DD>
<DL>
<DT>环境变量不重启</DT>
<!--property:date_created=1516961865-->
<!--property:date_modified=1516961875-->
<DD>
在“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中增加或修改环境变量后，需重启系统才能使之生效。有没有什么方法可让它即时生效呢？下面介绍一种方法：<BR>
<BR>
　　以修改环境变量“PATH”为例，修改完成后，进入DOS命令提示符，输入：set PATH=C: ，关闭DOS窗口。再次打开DOS窗口，输入：echo %PATH% ，可以发现“我的电脑”-&gt;“属性”-&gt;“高级”-&gt;“环境变量”中设置的 PATH 值已经生效。<BR>
<BR>
　　不用担心DOS窗口中的修改会影响环境变量的值，DOS窗口中的环境变量只是Windows环境变量的一个副本而已。但是对副本的修改却会引发Windows环境变量的刷新，这正是我们想要的!<BR>
<BR>
 <BR>
<BR>
诡异啊，使用win+R-&gt;cmd 启动的cmd.exe 会发现在电脑属性中设置的环境变量立马生效了，在其他模式下启动的cmd却没有发生效果，怪哉！！查看了一下资料，在电脑属性中设置环境变量以后，以后启动的程序和线程会生效，而对以前驻留内存的程序不起作用，也有人说kill explorer.exe 再启动explorer.exe 可以激发设置其作用。<BR>
<BR>
 <BR>
<BR>
这里要理解的是，一个程序启动时，环境变量被复制到该程序所在的环境中，在该程序执行过程中不会被除该程序以外的其他程序所改变。也就是说，假设我们启动了一个cmd程序，然后通过控制面板修改了环境变量设置，但是已经启动了的cmd所拥有的环境变量并不会被改变。如果我们在修改环境变量之后启动cmd程序，则该程序将拥有新的环境变量。<BR>
那么结论就很明显了：修改环境变量之后，如果受影响的是应用程序，那么只要简单地重新启动此应用程序，环境变量的修改就会反映到该程序中，而不必重新启动计算机；但是，如果受影响的是系统服务，就必须重新启动才能将环境变量的修改反映到系统服务中（因为没有办法在不重启计算机的情况下重新启动系统服务管理器）。<BR>
<BR>
 <BR>
<BR>
方案一：修改注册表，并向系统广播消息<BR>
<BR>
修改Windows环境变量后不重新启动使之立即生效的方法<BR>
<BR>
 <BR>
<BR>
不少程序需要添加各自的环境变量，方便定制性使用。用得最多的是用户指定目录如JAVA_HOME等变量，程序中可以根据获取变量%JAVA_HOME%，来获取对应设置的字符串。<BR>
<BR>
<BR>
 <BR>
<BR>
一般做法是安装的时候就指定，或者程序中设定。<BR>
<BR>
用批处理临时设置环境变量就不提了，这里讲让环境变量始终生效。<BR>
<BR>
一般做法是修改环境变量注册表。<BR>
<BR>
整个Windows都有效的环境变量在<BR>
HKEY_LOCAL_MACHINESYSTEMControlSet001ControlSession ManagerEnvironment<BR>
中设置<BR>
<BR>
对当前用户有效的环境变量在<BR>
HKEY_CURRENT_USEREnvironment<BR>
中设置<BR>
<BR>
其实只是简单的元数据<BR>
<BR>
但往往修改玩后无法即时生效，往往需要重启系统。<BR>
<BR>
要解决即时生效的问题，可以再在我的电脑属性中设置环境变量中确定一下即可。<BR>
<BR>
依此看来，这个过程肯定是读取了注册表，再调用一个系统函数来更新整个系统的变量。一定可以编程解决的。<BR>
<BR>
可惜网海茫茫，收不到。<BR>
<BR>
一不做二不休，直接下载打开innosetup的代码，搜索Environment，果真找到了。<BR>
<BR>
很简单：<BR>
<BR>
SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0,LPARAM(&quot;Environment&quot;), SMTO_ABORTIFHUNG, 5000, &amp;MsgResult);<BR>
<BR>
发一个全局的广播，等待各自相应后，立即生效。<BR>
<BR>
  { Note: We originally used SendNotifyMessage to broadcast the message but it<BR>
    turned out that while it worked fine on NT 4 and 2000 it didn't work on XP<BR>
    -- the string &quot;Environment&quot; in lParam would be garbled on the receiving<BR>
    end (why I'm not exactly sure). We now use SendMessageTimeout as directed<BR>
    in the KB article 104011. It isn't as elegant since it could cause us to<BR>
    be delayed if another app is hung, but it'll have to do. }<BR>
<BR>
 <BR>
<BR>
 <BR>
<BR>
方案二：在高级属性中设置完毕后，在任意cmd下设置一次path的值，达到全局广播的目的<BR>
<BR>
让环境变量生效不需重启Windows<BR>
<BR>
很多安装程序在安装完成后并不要求重启Windows，而新的环境变量已经生效了，可见在不重启Windows的情况下让环境变量生效是完全可行的。 <BR>
<BR>
可我搜索如何不需重启Windows让环境变量生效的方法，只找到三类方案： <BR>
<BR>
下载一个专门的软件 <BR>
编个小程序 <BR>
修改注册表 <BR>
我既然是个懒得重启Windows的人，难道我会不厌其烦按上述三种方法去做吗？没办法，我只有自己摸索。最后找到一个非常简单的在Windows下直接让环境变量生效的办法： <BR>
<BR>
先到我的电脑&gt;属性&gt;高级&gt;环境变量，添加新环境变量或修改已有的环境变量，然后运行“DOS命令提示符”或run cmd，假设要修改PATH变量，不管PATH的原值是什么，在DOS窗口直接把PATH修改为任意值，如：输入：set PATH=C:，关闭DOS窗口。再次打开DOS窗口，输入：echo %PATH% ，这时可以发现，我的电脑&gt;属 性&gt;高级&gt;环境变量里PATH已经在Windows全局生效了。 <BR>
<BR>
不用担心在DOS窗口的修改会影响我的电脑&gt;属性&gt;高级&gt;环境变量里的修改，DOS窗口的环境变量只是Windows环境变量的一个副本，副本的改动不会影响正本，但会触发正本的刷新，这正是我想要的&#8212;&#8212;让环境变量生效。<BR>
<BR>
 <BR>
<BR>
 <BR>
<BR>
方案三：<BR>
<BR>
修改Windows环境变量并使之立即生效<BR>
<BR>
想在Windows下通过编程修改环境变量的值，并且希望修改完后立即生效。<BR>
一、环境变量的修改<BR>
（1）修改当前进程的某个环境变量：SetEnvironmentVariable。<BR>
（2）修改系统环境变量：在注册表HKEY_LOCAL_MACHINESystemCurrentControlSetControlSession ManagerEnvironment中修改。<BR>
（3）修改用户环境变量：在注册表中HKEY_CURRENT_USEREnvironment修改。<BR>
二、环境变量的生效<BR>
在网上搜了一下，有两种说法：<BR>
（1）SendMessage(HWND_BROADCAST,WM_SETTINGCHANGE,0,(LPARAM)TEXT(&quot;Environment&quot;));<BR>
（2）SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, 0,LPARAM(&quot;Environment&quot;), SMTO_ABORTIFHUNG, 5000, &amp;MsgResult);<BR>
没有尝试，先记在这儿。<BR>
<BR>
 <BR>
<BR>
==========================================================================================<BR>
<BR>
下面是网阅的Windows官方资料，文档中阐述了环境变量更改后如何即时生效的原理。
</DD>
</DL>

</DD>
<DT>Tensorflow</DT>
<!--property:date_created=1517217182-->
<!--property:date_modified=1517217182-->
<!--property:expanded-->
<DD>
<DL>
<DT>编译</DT>
<!--property:date_created=1517217190-->
<!--property:date_modified=1517222466-->
<DD>
cmake .. -A x64 -DCMAKE_BUILD_TYPE=Release <BR>
More? -DSWIG_EXECUTABLE=E:/code/tensorflow/swigwin-3.0.12/swig.exe <BR>
More? -DPYTHON_WXECUTABLE=D:/Program Files/Anaconda3/python.exe <BR>
More? -DPYTHON_LIBRARYS=D:/Program Files/Anaconda3/libs/python35.lib <BR>
More? -Dtensorflow_ENABLE_GPU=ON <BR>
More? -DCUDNN_HOME=&quot;D:/cudnn-9.1-windows10-x64-v7/cuda&quot;<BR>
<BR>
MSBuild /p:/Configuration=Release tf_python_build_pip_package.vcxproj<BR>
<BR>
http://blog.csdn.net/DawnRanger/article/details/77755412
</DD>
</DL>

</DD>
<DT>caffe</DT>
<!--property:date_created=1517222419-->
<!--property:date_modified=1517222419-->
<!--property:expanded-->
<DD>
<DL>
<DT>编译</DT>
<!--property:date_created=1517222424-->
<!--property:date_modified=1517222439-->
<DD>
http://blog.csdn.net/shakevincent/article/details/51694686
</DD>
</DL>

</DD>
<DT>FTP</DT>
<!--property:date_created=1516785432-->
<!--property:date_modified=1516785438-->
<!--property:expanded-->
<DD>
C<DL>
<DT>C#获取网络文件夹文件</DT>
<!--property:date_created=1516785440-->
<!--property:date_modified=1516785458-->
<DD>
我在之前做过一个FTP的客户端工具。<BR>
drw   文件夹<BR>
-rw    文件（有扩展名或无扩展名）<BR>
我是根据服务端返回的报文进行分析获取的列表。<BR>
给你一些代码片段：<BR>
/// &lt;summary&gt;<BR>
        /// 获取指定目录下的文件和文件夹。<BR>
        /// &lt;/summary&gt;<BR>
        /// &lt;param name=&quot;path&quot;&gt;要获取的目录&lt;/param&gt;<BR>
        /// &lt;param name=&quot;WRMethods&quot;&gt;要发送到FTP服务器的密令。&lt;/param&gt;<BR>
        /// &lt;returns&gt;&lt;/returns&gt;<BR>
        public string[] GetFileList(string path, string WRMethods)//从ftp服务器上获得文件列表<BR>
        {<BR>
            WebResponse response;<BR>
            string[] downloadFiles;<BR>
            int conut = 4;<BR>
            StringBuilder result = new StringBuilder();<BR>
            Connect(path);<BR>
            if (FTPVariable.IsUseProxy_ftp)<BR>
            {<BR>
                reqFTP.Proxy = FtpProxy.GetFtpSelectProxy(FTPVariable.FtpCommand_transferProxyName);<BR>
            }<BR>
            reqFTP.ReadWriteTimeout = 12000;<BR>
            //如果不应销毁到服务器的连接，则为 true；否则为 false。默认值为 true。<BR>
            //<BR>
            reqFTP.Method = WRMethods;<BR>
            try<BR>
            {<BR>
                response = (FtpWebResponse)reqFTP.GetResponse();<BR>
                goto Ftp_lbl_03;<BR>
            }<BR>
            catch (WebException webex)<BR>
            {<BR>
                GetReply(webex.Message);<BR>
                if (ReplyCode == 530)// 未登录。<BR>
                {<BR>
                    goto Ftp_lbl_04;<BR>
                }<BR>
                else if (ReplyCode == 550)<BR>
                {<BR>
                    goto Ftp_lbl_04;<BR>
                }<BR>
                else<BR>
                {<BR>
                    FtpManage.SetLog(&quot;获取列表超时,等候1秒后重试!&quot;);<BR>
                    goto Ftp_lbl_01;<BR>
                }<BR>
            }<BR>
        Ftp_lbl_01:<BR>
            try<BR>
            {<BR>
                FtpManage.SetLog(&quot;正在连接服务器 &quot; + FtpRemoteHost);<BR>
                response = GetRequest(path, WRMethods);<BR>
            }<BR>
            catch (WebException)<BR>
            {<BR>
                FtpManage.SetLog(&quot;获取列表超时,等候1秒后重试!&quot;);<BR>
                downloadFiles = null;<BR>
                System.Threading.Thread.Sleep(1000);<BR>
                if (conut == 0)<BR>
                {<BR>
                    goto Ftp_lbl_02;<BR>
                }<BR>
                conut--;<BR>
                goto Ftp_lbl_01;<BR>
            }<BR>
            catch (Exception ex)<BR>
            {<BR>
                MSG.Show(ex.Message, Global.GetRS[&quot;msgTilteError&quot;], MessageBoxButton.OK, MsgIco.Error);<BR>
                FtpManage.SetLog(&quot;命令执行失败,原因:&quot; + ex.Message);<BR>
                downloadFiles = null;<BR>
                return downloadFiles;<BR>
            }<BR>
        Ftp_lbl_03:<BR>
            StreamReader reader = new StreamReader(response.GetResponseStream(), System.Text.Encoding.Default);//中文文件名<BR>
            string line = reader.ReadLine();<BR>
            while (line != null)<BR>
            {<BR>
                result.Append(line);<BR>
                result.Append(&quot;\n&quot;);<BR>
                line = reader.ReadLine();<BR>
            }<BR>
            if (result.Length == 0)<BR>
            {<BR>
                return null;<BR>
            }<BR>
            // to remove the trailing '\n'<BR>
            result.Remove(result.ToString().LastIndexOf('\n'), 1);<BR>
            reader.Close();<BR>
            response.Close();<BR>
            FtpManage.SetLog(&quot;命令已成功执行&quot;);<BR>
            return result.ToString().Split('\n');<BR>
        Ftp_lbl_04:<BR>
            FtpManage.SetLog(ReplyInfo);<BR>
            return null;<BR>
        Ftp_lbl_02:<BR>
            FtpManage.SetLog(&quot;550 获取列表失败,无法连接远程服务器!&quot;);<BR>
            FtpManage.ftpmanage.IsRefurbish = true;<BR>
            return null;<BR>
        }<BR>
/// &lt;summary&gt;<BR>
        /// 获取指定目录下的文件和文件夹。<BR>
        /// &lt;/summary&gt;<BR>
        /// &lt;param name=&quot;path&quot;&gt;要获取的目录&lt;/param&gt;<BR>
        /// &lt;returns&gt;&lt;/returns&gt;<BR>
        public string[] GetFileList(string path)//从ftp服务器上获得文件列表<BR>
        {<BR>
            return GetFileList(FTPVariable.FtpURLhead + FtpRemoteHost + &quot;/&quot; + path, WebRequestMethods.Ftp.ListDirectory);<BR>
        }<BR>
        /// &lt;summary&gt;<BR>
        /// 获取指定目录下的文件和文件夹。<BR>
        /// &lt;/summary&gt;<BR>
        /// &lt;returns&gt;&lt;/returns&gt;<BR>
        public string[] GetFileList()//从ftp服务器上获得文件列表<BR>
        {<BR>
            return GetFileList(FTPVariable.FtpURLhead + FtpRemoteHost + &quot;/&quot;, WebRequestMethods.Ftp.ListDirectory);<BR>
        }<BR>
        /// &lt;summary&gt;<BR>
        /// 获取目录和文件名,返回目录表。<BR>
        /// &lt;/summary&gt;<BR>
        /// &lt;param name=&quot;path&quot;&gt;要获取的目录&lt;/param&gt;<BR>
        /// &lt;returns&gt;&lt;/returns&gt;<BR>
        public string[] GetCatalog_FileList(string path)<BR>
        {<BR>
            string[] fountainhead = GetFileList(FTPVariable.FtpURLhead + FtpRemoteHost + &quot;/&quot; + path, WebRequestMethods.Ftp.ListDirectoryDetails);<BR>
            string[] Catalog = null;<BR>
            if (fountainhead == null)<BR>
            {<BR>
                return null;<BR>
            }<BR>
            Catalog = new string[fountainhead.Length];<BR>
            for (int i = 3; i &lt; fountainhead.Length; i++)<BR>
            {<BR>
                Catalog[i - 3] += fountainhead[i].Substring(55, fountainhead[i].Length - 55) + &quot;&amp;&quot;;//FileName<BR>
                Catalog[i - 3] += fountainhead[i].Substring(30, 12) + &quot;&amp;&quot;;//FileSize<BR>
                Catalog[i - 3] += fountainhead[i].Substring(42, 13) + &quot;&amp;&quot;;//AmendDate<BR>
                Catalog[i - 3] += fountainhead[i].Substring(0, 3) + &quot;&amp;&quot;;<BR>
            }<BR>
            return Catalog;<BR>
        }
</DD>
<DT>C/C++</DT>
<!--property:date_created=1516785498-->
<!--property:date_modified=1516785620-->
<DD>
libcurl<BR>
wininet<BR>
<BR>
查看lftp源码中mget怎么实现的
</DD>
</DL>

</DD>
<DT>RTSP</DT>
<!--property:date_created=1516328752-->
<!--property:date_modified=1516328840-->
<DD>
主码流<BR>
rtsp://admin:admin12345@192.168.4.64:554/h264/ch1/main/av_stream 			vlc请求视频流<BR>
rtsp://admin:12345@192.0.0.64:554/MPEG-4/ch1/main/av_stream  <BR>
<BR>
//自麻溜<BR>
rtsp://admin:12345@192.0.0.64/mpeg4/ch1/sub/av_stream  <BR>
  <BR>
rtsp://admin:12345@192.0.0.64/h264/ch1/sub/av_stream  
</DD>
<DT>相机连接流程</DT>
<!--property:date_created=1515574729-->
<!--property:date_modified=1515574790-->
<DD>
必须要素：<BR>
<BR>
1.      必须包含subject头域<BR>
2.      SDP中session name必须填写Play<BR>
3.      SDP中不能懈怠audio<BR>
4.      SDP中的video必须携带PS属性<BR>
<BR>
以上4要素缺一不可。<BR>
示例：<BR>
<BR>
1.      正确流程<BR>
<BR>
P1-&gt;IPC<BR>
<BR>
INVITEsip:34020000001320000001@192.168.50.171 SIP/2.0<BR>
Via: SIP/2.0/UDP192.168.50.22:5060;branch=32dbcde3<BR>
From: &quot;1001&quot;&lt;sip:1001@192.168.50.22&gt;;tag=591cf984<BR>
Contact:&lt;sip:1001@192.168.50.22:5060&gt;<BR>
To:&lt;sip:34020000001320000001@192.168.50.171&gt;<BR>
Call-ID:14416987936de3e8ed55fe07400dcce022@1632a8c0<BR>
CSeq: 172 INVITE<BR>
Max-Forwards: 70<BR>
Subject:34020000001320000001:0,1001:0<BR>
Content-Type: application/sdp<BR>
Content-Length: 381<BR>
 <BR>
v=0<BR>
o=root 853265891 853265891 IN IP4192.168.50.22<BR>
s=Play<BR>
c=IN IP4 192.168.50.22<BR>
t=0 0<BR>
m=video 19690 RTP/AVP 126 125 99 34 96<BR>
a=rtpmap:126 H264/90000<BR>
a=fmtp:126 profile-level-id=42e01e<BR>
a=rtpmap:125 H264S/90000<BR>
a=fmtp:125 profile-level-id=42e01e<BR>
a=rtpmap:99 MP4V-ES/90000<BR>
a=fmtp:99 profile-level-id=3<BR>
a=rtpmap:96 PS/90000<BR>
 <BR>
IPC-&gt;P1<BR>
SIP/2.0 200 OK<BR>
Via: SIP/2.0/UDP192.168.50.22:5060;branch=32dbcde3<BR>
From: &quot;1001&quot;&lt;sip:1001@192.168.50.22&gt;;tag=591cf984<BR>
To:&lt;sip:34020000001320000001@192.168.50.171&gt;;tag=1292444290<BR>
Call-ID:14416987936de3e8ed55fe07400dcce022@1632a8c0<BR>
CSeq: 172 INVITE<BR>
Contact:&lt;sip:1005@192.168.50.171:5060&gt;<BR>
Content-Type: application/sdp<BR>
User-Agent: IP Camera<BR>
Content-Length:   267<BR>
 <BR>
v=0<BR>
o=1005 1935 1935 IN IP4 192.168.50.171<BR>
s=play<BR>
c=IN IP4 192.168.50.171<BR>
t=0 0<BR>
m=video 15060 RTP/AVP 96<BR>
a=sendonly<BR>
a=rtpmap:96 PS/90000<BR>
 <BR>
2.      不正确流程<BR>
<BR>
P1-&gt;IPC<BR>
INVITEsip:34020000001320000001@192.168.50.171 SIP/2.0<BR>
Via: SIP/2.0/UDP192.168.50.22:5060;branch=55b46723<BR>
From: &quot;1001&quot;&lt;sip:1001@192.168.50.22&gt;;tag=1a72242e<BR>
Contact: &lt;sip:1001@192.168.50.22:5060&gt;<BR>
To:&lt;sip:34020000001320000001@192.168.50.171&gt;<BR>
Call-ID:1441698966743435f475c5f89133b42b83@1632a8c0<BR>
CSeq: 170 INVITE<BR>
Max-Forwards: 70<BR>
Subject:34020000001320000001:0,1001:0<BR>
Content-Type: application/sdp<BR>
Content-Length: 553<BR>
 <BR>
v=0<BR>
o=root 1437886243 1437886243 IN IP4192.168.50.22<BR>
s=Play<BR>
c=IN IP4 192.168.50.22<BR>
t=0 0<BR>
m=audio38406 RTP/AVP 0 8 3 114 18<BR>
a=rtpmap:0 PCMU/8000<BR>
a=rtpmap:8 PCMA/8000<BR>
a=rtpmap:3 GSM/8000<BR>
a=rtpmap:114 AMR/8000<BR>
a=fmtp:114 mode-set=7<BR>
a=rtpmap:18 G729/8000<BR>
m=video24674 RTP/AVP 126 125 99<BR>
a=recvonly<BR>
a=rtpmap:126 H264/90000<BR>
a=fmtp:126 profile-level-id=42e01e<BR>
a=rtpmap:125 H264S/90000<BR>
a=fmtp:125 profile-level-id=42e01e<BR>
a=rtpmap:99 MP4V-ES/90000<BR>
a=fmtp:99 profile-level-id=3<BR>
 <BR>
 <BR>
IPC-&gt;P1<BR>
SIP/2.0 200 OK<BR>
Via: SIP/2.0/UDP 192.168.50.22:5060;branch=55b46723<BR>
From: &quot;1001&quot;&lt;sip:1001@192.168.50.22&gt;;tag=1a72242e<BR>
To:&lt;sip:34020000001320000001@192.168.50.171&gt;;tag=2000948179<BR>
Call-ID:1441698966743435f475c5f89133b42b83@1632a8c0<BR>
CSeq: 170 INVITE<BR>
Contact:&lt;sip:1005@192.168.50.171:5060&gt;<BR>
Content-Type: application/sdp<BR>
User-Agent: IP Camera<BR>
Content-Length:   108<BR>
 <BR>
v=0<BR>
o=1005 3764 3764 IN IP4 192.168.50.171<BR>
s=play<BR>
c=IN IP4 192.168.50.171<BR>
t=0 0<BR>
m=video 15060RTP/AVP
</DD>
</DL>
</BODY>
</HTML>
